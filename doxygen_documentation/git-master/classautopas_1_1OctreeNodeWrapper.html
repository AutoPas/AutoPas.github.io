<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html">OctreeNodeWrapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classautopas_1_1OctreeNodeWrapper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::OctreeNodeWrapper&lt; Particle_T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class wraps the functionality provided by the octree leaves and inner nodes in a structure that adheres to the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> concept.  
 <a href="classautopas_1_1OctreeNodeWrapper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OctreeNodeWrapper_8h_source.html">OctreeNodeWrapper.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::OctreeNodeWrapper&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1OctreeNodeWrapper__inherit__graph.png" border="0" usemap="#aautopas_1_1OctreeNodeWrapper_3_01Particle__T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1OctreeNodeWrapper_3_01Particle__T_01_4_inherit__map" id="aautopas_1_1OctreeNodeWrapper_3_01Particle__T_01_4_inherit__map">
<area shape="rect" title="This class wraps the functionality provided by the octree leaves and inner nodes in a structure that ..." alt="" coords="5,93,220,133"/>
<area shape="rect" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles." alt="" coords="35,5,190,45"/>
<area shape="poly" title=" " alt="" coords="115,59,115,93,110,93,110,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for autopas::OctreeNodeWrapper&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1OctreeNodeWrapper__coll__graph.png" border="0" usemap="#aautopas_1_1OctreeNodeWrapper_3_01Particle__T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aautopas_1_1OctreeNodeWrapper_3_01Particle__T_01_4_coll__map" id="aautopas_1_1OctreeNodeWrapper_3_01Particle__T_01_4_coll__map">
<area shape="rect" title="This class wraps the functionality provided by the octree leaves and inner nodes in a structure that ..." alt="" coords="5,183,220,223"/>
<area shape="rect" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles." alt="" coords="35,93,190,133"/>
<area shape="poly" title=" " alt="" coords="115,147,115,183,110,183,110,147"/>
<area shape="rect" href="classautopas_1_1AutoPasLock.html" title="AutoPasLock for the sequential case." alt="" coords="31,5,195,31"/>
<area shape="poly" title=" " alt="" coords="115,44,115,93,110,93,110,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a25474ec7efe74eeb400a425101461d57"><td class="memItemLeft" align="right" valign="top"><a id="a25474ec7efe74eeb400a425101461d57" name="a25474ec7efe74eeb400a425101461d57"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleCell</b> = <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">OctreeNodeWrapper</a>&lt; Particle_T &gt;</td></tr>
<tr class="memdesc:a25474ec7efe74eeb400a425101461d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contained particle cell. <br /></td></tr>
<tr class="separator:a25474ec7efe74eeb400a425101461d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9e49eabad264060f61d283f231b9f3"><td class="memItemLeft" align="right" valign="top"><a id="aee9e49eabad264060f61d283f231b9f3" name="aee9e49eabad264060f61d283f231b9f3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleType</b> = typename <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#aee9e49eabad264060f61d283f231b9f3">ParticleCell::ParticleType</a></td></tr>
<tr class="memdesc:aee9e49eabad264060f61d283f231b9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contained particle type. <br /></td></tr>
<tr class="separator:aee9e49eabad264060f61d283f231b9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace58f88efa73f47aa31aa777978e893e"><td class="memItemLeft" align="right" valign="top"><a id="ace58f88efa73f47aa31aa777978e893e" name="ace58f88efa73f47aa31aa777978e893e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StorageType</b> = std::vector&lt; Particle_T * &gt;</td></tr>
<tr class="memdesc:ace58f88efa73f47aa31aa777978e893e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that holds or refers to the actual particles. <br /></td></tr>
<tr class="separator:ace58f88efa73f47aa31aa777978e893e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classautopas_1_1ParticleCell"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classautopas_1_1ParticleCell')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classautopas_1_1ParticleCell.html">autopas::ParticleCell&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:af02347c5927b01556f16d950de9f5a53 inherit pub_types_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#af02347c5927b01556f16d950de9f5a53">ParticleType</a> = Particle_T</td></tr>
<tr class="memdesc:af02347c5927b01556f16d950de9f5a53 inherit pub_types_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">The particle type for this cell.  <br /></td></tr>
<tr class="separator:af02347c5927b01556f16d950de9f5a53 inherit pub_types_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a947b6283fcf50081b4ec36834d8895cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a947b6283fcf50081b4ec36834d8895cb">OctreeNodeWrapper</a> (const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax, int unsigned const treeSplitThreshold, double const interactionLength, double const cellSizeFactor)</td></tr>
<tr class="memdesc:a947b6283fcf50081b4ec36834d8895cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new, empty octree and stores the root.  <br /></td></tr>
<tr class="separator:a947b6283fcf50081b4ec36834d8895cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe20b80211f224dc97fdbcd3540c775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a6fe20b80211f224dc97fdbcd3540c775">collectAllParticles</a> (<a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a> &amp;ps)</td></tr>
<tr class="memdesc:a6fe20b80211f224dc97fdbcd3540c775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all particles in the octree to a list using DFS.  <br /></td></tr>
<tr class="separator:a6fe20b80211f224dc97fdbcd3540c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed4db5868acc408d2bde676e9cca038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a0ed4db5868acc408d2bde676e9cca038">appendAllLeaves</a> (std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;leaves)</td></tr>
<tr class="memdesc:a0ed4db5868acc408d2bde676e9cca038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all leaves in the octree to a list.  <br /></td></tr>
<tr class="separator:a0ed4db5868acc408d2bde676e9cca038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b121e4796603564af1a4bd639111fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ae3b121e4796603564af1a4bd639111fe">addParticle</a> (const Particle_T &amp;p) override</td></tr>
<tr class="memdesc:ae3b121e4796603564af1a4bd639111fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Particle to the cell.  <br /></td></tr>
<tr class="separator:ae3b121e4796603564af1a4bd639111fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54d213cd9b668c1cca9234acfab025d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ab54d213cd9b668c1cca9234acfab025d">begin</a> ()</td></tr>
<tr class="memdesc:ab54d213cd9b668c1cca9234acfab025d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the start of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.  <br /></td></tr>
<tr class="separator:ab54d213cd9b668c1cca9234acfab025d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6896c52193bbef4007ad89307afa1764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a6896c52193bbef4007ad89307afa1764">begin</a> () const</td></tr>
<tr class="memdesc:a6896c52193bbef4007ad89307afa1764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the start of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.    <br /></td></tr>
<tr class="separator:a6896c52193bbef4007ad89307afa1764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32b1543280840ebba0141f76e6cf3f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ab32b1543280840ebba0141f76e6cf3f7">end</a> ()</td></tr>
<tr class="memdesc:ab32b1543280840ebba0141f76e6cf3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.    <br /></td></tr>
<tr class="separator:ab32b1543280840ebba0141f76e6cf3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8842fdc4fac269ba56dc560805882c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a8842fdc4fac269ba56dc560805882c61">end</a> () const</td></tr>
<tr class="memdesc:a8842fdc4fac269ba56dc560805882c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.    <br /></td></tr>
<tr class="separator:a8842fdc4fac269ba56dc560805882c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e135e41c88741c3bff93f17341895d6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a9e135e41c88741c3bff93f17341895d6">size</a> () const override</td></tr>
<tr class="memdesc:a9e135e41c88741c3bff93f17341895d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of all particles stored in this cell (owned, halo and dummy).  <br /></td></tr>
<tr class="separator:a9e135e41c88741c3bff93f17341895d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d704db6349715e7d561fc1c1537509"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a38d704db6349715e7d561fc1c1537509">getNumberOfParticles</a> (IteratorBehavior behavior) const override</td></tr>
<tr class="memdesc:a38d704db6349715e7d561fc1c1537509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.    <br /></td></tr>
<tr class="separator:a38d704db6349715e7d561fc1c1537509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ce39af53921ceb8caa4091015b3865"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a52ce39af53921ceb8caa4091015b3865">isEmpty</a> () const override</td></tr>
<tr class="memdesc:a52ce39af53921ceb8caa4091015b3865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the cell is not empty.  <br /></td></tr>
<tr class="separator:a52ce39af53921ceb8caa4091015b3865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac03af6d8510dcfa9026d5b5c6dac3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a3ac03af6d8510dcfa9026d5b5c6dac3a">clear</a> () override</td></tr>
<tr class="memdesc:a3ac03af6d8510dcfa9026d5b5c6dac3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles in this cell.  <br /></td></tr>
<tr class="separator:a3ac03af6d8510dcfa9026d5b5c6dac3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0bfe25cd0ec51080322c32220b12d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#aaf0bfe25cd0ec51080322c32220b12d8">deleteDummyParticles</a> () override</td></tr>
<tr class="memdesc:aaf0bfe25cd0ec51080322c32220b12d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all dummy particles in this cell.  <br /></td></tr>
<tr class="separator:aaf0bfe25cd0ec51080322c32220b12d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df1279921840d891fccf4174a0b4b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a4df1279921840d891fccf4174a0b4b91">getParticleCellTypeAsEnum</a> () override</td></tr>
<tr class="memdesc:a4df1279921840d891fccf4174a0b4b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an ParticleCellTypeEnum.  <br /></td></tr>
<tr class="separator:a4df1279921840d891fccf4174a0b4b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641d8df94f0a6cccd26bb36a2b50d380"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a641d8df94f0a6cccd26bb36a2b50d380">deleteParticle</a> (Particle_T &amp;particle)</td></tr>
<tr class="memdesc:a641d8df94f0a6cccd26bb36a2b50d380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given particle from the data structure.  <br /></td></tr>
<tr class="separator:a641d8df94f0a6cccd26bb36a2b50d380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e6a426d7ce239ed99854191d7cf0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ac8e6a426d7ce239ed99854191d7cf0c3">deleteByIndex</a> (size_t index) override</td></tr>
<tr class="memdesc:ac8e6a426d7ce239ed99854191d7cf0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the index-th particle.  <br /></td></tr>
<tr class="separator:ac8e6a426d7ce239ed99854191d7cf0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bbc6c8bf3b6564f87a7e909fa07a35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a69bbc6c8bf3b6564f87a7e909fa07a35">setCellLength</a> (std::array&lt; double, 3 &gt; &amp;cellLength) override</td></tr>
<tr class="memdesc:a69bbc6c8bf3b6564f87a7e909fa07a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the side lengths of this cell.  <br /></td></tr>
<tr class="separator:a69bbc6c8bf3b6564f87a7e909fa07a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f23ec8d22c3dff17dc8ca2c44dc52bf"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a0f23ec8d22c3dff17dc8ca2c44dc52bf">getCellLength</a> () const override</td></tr>
<tr class="memdesc:a0f23ec8d22c3dff17dc8ca2c44dc52bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the side lengths of this cell.  <br /></td></tr>
<tr class="separator:a0f23ec8d22c3dff17dc8ca2c44dc52bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde30591ec0a6f8aa39c99a8cb5d08b9"><td class="memItemLeft" align="right" valign="top">Particle_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#acde30591ec0a6f8aa39c99a8cb5d08b9">at</a> (size_t index)</td></tr>
<tr class="memdesc:acde30591ec0a6f8aa39c99a8cb5d08b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a particle from the iterator.  <br /></td></tr>
<tr class="separator:acde30591ec0a6f8aa39c99a8cb5d08b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b2fac62184a35f991cac72ad74ab80"><td class="memItemLeft" align="right" valign="top">const Particle_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#aa7b2fac62184a35f991cac72ad74ab80">at</a> (size_t index) const</td></tr>
<tr class="memdesc:aa7b2fac62184a35f991cac72ad74ab80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a particle from the iterator.  <br /></td></tr>
<tr class="separator:aa7b2fac62184a35f991cac72ad74ab80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bec16dab2d2dae28ff432e8cf0c365"><td class="memItemLeft" align="right" valign="top">Particle_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a36bec16dab2d2dae28ff432e8cf0c365">operator[]</a> (size_t index)</td></tr>
<tr class="memdesc:a36bec16dab2d2dae28ff432e8cf0c365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a particle from the iterator.  <br /></td></tr>
<tr class="separator:a36bec16dab2d2dae28ff432e8cf0c365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a919990711761249e7410c33f4c96dd"><td class="memItemLeft" align="right" valign="top">const Particle_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a5a919990711761249e7410c33f4c96dd">operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:a5a919990711761249e7410c33f4c96dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a particle from the iterator.  <br /></td></tr>
<tr class="separator:a5a919990711761249e7410c33f4c96dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfa13b8a2c18eb5c6a4ebf4f54ed724"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a5cfa13b8a2c18eb5c6a4ebf4f54ed724">getLeavesInRange</a> (const std::array&lt; double, 3 &gt; &amp;min, const std::array&lt; double, 3 &gt; &amp;max)</td></tr>
<tr class="memdesc:a5cfa13b8a2c18eb5c6a4ebf4f54ed724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaves below this subtree that are in the given range.  <br /></td></tr>
<tr class="separator:a5cfa13b8a2c18eb5c6a4ebf4f54ed724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad271b7e4f33df478fd42c6d4f6579b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ad271b7e4f33df478fd42c6d4f6579b4d">getRaw</a> () const</td></tr>
<tr class="memdesc:ad271b7e4f33df478fd42c6d4f6579b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a raw pointer to the enclosed cell.  <br /></td></tr>
<tr class="separator:ad271b7e4f33df478fd42c6d4f6579b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d6934d9ad0d71fabb41562971264f0"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:aa0d6934d9ad0d71fabb41562971264f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#aa0d6934d9ad0d71fabb41562971264f0">forEach</a> (Lambda forEachLambda)</td></tr>
<tr class="memdesc:aa0d6934d9ad0d71fabb41562971264f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the forEach lambda to each particle.  <br /></td></tr>
<tr class="separator:aa0d6934d9ad0d71fabb41562971264f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64002d68d4bcf8781671bdfa64ed2458"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:a64002d68d4bcf8781671bdfa64ed2458"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a64002d68d4bcf8781671bdfa64ed2458">reduce</a> (Lambda reduceLambda, A &amp;result)</td></tr>
<tr class="memdesc:a64002d68d4bcf8781671bdfa64ed2458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reduce lambda to each particle.  <br /></td></tr>
<tr class="separator:a64002d68d4bcf8781671bdfa64ed2458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec99650eafbab3c87d48dcd73101a49e"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:aec99650eafbab3c87d48dcd73101a49e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#aec99650eafbab3c87d48dcd73101a49e">forEachInRegion</a> (Lambda forEachLambda, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner)</td></tr>
<tr class="memdesc:aec99650eafbab3c87d48dcd73101a49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the forEach lambda to each particle in the region.  <br /></td></tr>
<tr class="separator:aec99650eafbab3c87d48dcd73101a49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d569cbcfb43264827553a5617a97fb9"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:a3d569cbcfb43264827553a5617a97fb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a3d569cbcfb43264827553a5617a97fb9">reduceInRegion</a> (Lambda reduceLambda, A &amp;result, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner)</td></tr>
<tr class="memdesc:a3d569cbcfb43264827553a5617a97fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reduce lambda to each particle in the region.  <br /></td></tr>
<tr class="separator:a3d569cbcfb43264827553a5617a97fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1ParticleCell"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1ParticleCell')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1ParticleCell.html">autopas::ParticleCell&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a7a5f1fceeb96e9cc5612141ee54ff256 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="a7a5f1fceeb96e9cc5612141ee54ff256" name="a7a5f1fceeb96e9cc5612141ee54ff256"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ParticleCell</b> ()=default</td></tr>
<tr class="memdesc:a7a5f1fceeb96e9cc5612141ee54ff256 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a7a5f1fceeb96e9cc5612141ee54ff256 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b50d7256264cdf152cd214900502e5d inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="a7b50d7256264cdf152cd214900502e5d" name="a7b50d7256264cdf152cd214900502e5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleCell</b> ()=default</td></tr>
<tr class="memdesc:a7b50d7256264cdf152cd214900502e5d inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default default constructor. <br /></td></tr>
<tr class="separator:a7b50d7256264cdf152cd214900502e5d inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af99949724d70bf5f6b2b6583a6e7b7 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a1af99949724d70bf5f6b2b6583a6e7b7">ParticleCell</a> (<a class="el" href="classautopas_1_1ParticleCell.html">ParticleCell</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a1af99949724d70bf5f6b2b6583a6e7b7 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor.  <br /></td></tr>
<tr class="separator:a1af99949724d70bf5f6b2b6583a6e7b7 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91ae00532b039a28c12e33f00c8d28a inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#ad91ae00532b039a28c12e33f00c8d28a">ParticleCell</a> (const <a class="el" href="classautopas_1_1ParticleCell.html">ParticleCell</a> &amp;other)</td></tr>
<tr class="memdesc:ad91ae00532b039a28c12e33f00c8d28a inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that creates a new default constructed lock for the new cell.  <br /></td></tr>
<tr class="separator:ad91ae00532b039a28c12e33f00c8d28a inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a327fba022da069e42f460b063e68 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aa68a327fba022da069e42f460b063e68">addParticle</a> (const Particle_T &amp;p)=0</td></tr>
<tr class="memdesc:aa68a327fba022da069e42f460b063e68 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Particle to the cell.  <br /></td></tr>
<tr class="separator:aa68a327fba022da069e42f460b063e68 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a047b4cc19bc7c29b6153ab48556cc6 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a3a047b4cc19bc7c29b6153ab48556cc6">size</a> () const =0</td></tr>
<tr class="memdesc:a3a047b4cc19bc7c29b6153ab48556cc6 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of all particles stored in this cell (owned, halo and dummy).  <br /></td></tr>
<tr class="separator:a3a047b4cc19bc7c29b6153ab48556cc6 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef492136b8cc0f1c5227b75e8d007223 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aef492136b8cc0f1c5227b75e8d007223">getNumberOfParticles</a> (IteratorBehavior behavior=IteratorBehavior::owned) const =0</td></tr>
<tr class="memdesc:aef492136b8cc0f1c5227b75e8d007223 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.  <br /></td></tr>
<tr class="separator:aef492136b8cc0f1c5227b75e8d007223 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd1a2bf74c3538ae508904fe196c4f0 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a4fd1a2bf74c3538ae508904fe196c4f0">isEmpty</a> () const =0</td></tr>
<tr class="memdesc:a4fd1a2bf74c3538ae508904fe196c4f0 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the cell is empty.  <br /></td></tr>
<tr class="separator:a4fd1a2bf74c3538ae508904fe196c4f0 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a8350d1fc7ea59c0ffdf63d8da8c7d inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a24a8350d1fc7ea59c0ffdf63d8da8c7d">clear</a> ()=0</td></tr>
<tr class="memdesc:a24a8350d1fc7ea59c0ffdf63d8da8c7d inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles in this cell.  <br /></td></tr>
<tr class="separator:a24a8350d1fc7ea59c0ffdf63d8da8c7d inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1600925339d8d42d31abdd8465c15a4 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aa1600925339d8d42d31abdd8465c15a4">deleteDummyParticles</a> ()=0</td></tr>
<tr class="memdesc:aa1600925339d8d42d31abdd8465c15a4 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all dummy particles in this cell.  <br /></td></tr>
<tr class="separator:aa1600925339d8d42d31abdd8465c15a4 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc1db292417b9a91fcbe43a56b4524e inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aabc1db292417b9a91fcbe43a56b4524e">getParticleCellTypeAsEnum</a> ()=0</td></tr>
<tr class="memdesc:aabc1db292417b9a91fcbe43a56b4524e inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an ParticleCellTypeEnum.  <br /></td></tr>
<tr class="separator:aabc1db292417b9a91fcbe43a56b4524e inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946ae25741ba9249081fe24d501ccfa5 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a946ae25741ba9249081fe24d501ccfa5">deleteByIndex</a> (size_t index)=0</td></tr>
<tr class="memdesc:a946ae25741ba9249081fe24d501ccfa5 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the index-th particle.  <br /></td></tr>
<tr class="separator:a946ae25741ba9249081fe24d501ccfa5 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad229dcc7028778120dfe33b3161d9201 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#ad229dcc7028778120dfe33b3161d9201">setCellLength</a> (std::array&lt; double, 3 &gt; &amp;cellLength)=0</td></tr>
<tr class="memdesc:ad229dcc7028778120dfe33b3161d9201 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the side lengths of this cell.  <br /></td></tr>
<tr class="separator:ad229dcc7028778120dfe33b3161d9201 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e68017cfc40ca9407e03e83d888955 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#ac4e68017cfc40ca9407e03e83d888955">getCellLength</a> () const =0</td></tr>
<tr class="memdesc:ac4e68017cfc40ca9407e03e83d888955 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the side lengths of this cell.  <br /></td></tr>
<tr class="separator:ac4e68017cfc40ca9407e03e83d888955 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4034add6b3f0c98afbe69db9552ea8 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0">OwnershipState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aaa4034add6b3f0c98afbe69db9552ea8">getPossibleParticleOwnerships</a> () const</td></tr>
<tr class="memdesc:aaa4034add6b3f0c98afbe69db9552ea8 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of particles contained in this cell.  <br /></td></tr>
<tr class="separator:aaa4034add6b3f0c98afbe69db9552ea8 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ebee3bc723ceb54f11359c9acdebd9 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a90ebee3bc723ceb54f11359c9acdebd9">setPossibleParticleOwnerships</a> (<a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0">OwnershipState</a> state)</td></tr>
<tr class="memdesc:a90ebee3bc723ceb54f11359c9acdebd9 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of particles contained in this cell.  <br /></td></tr>
<tr class="separator:a90ebee3bc723ceb54f11359c9acdebd9 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5856ed7123bda9dbc4044bce889d20 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1AutoPasLock.html">AutoPasLock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aef5856ed7123bda9dbc4044bce889d20">getCellLock</a> () const</td></tr>
<tr class="memdesc:aef5856ed7123bda9dbc4044bce889d20 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lock object for exclusive access to this cell.  <br /></td></tr>
<tr class="separator:aef5856ed7123bda9dbc4044bce889d20 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classautopas_1_1ParticleCell"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classautopas_1_1ParticleCell')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classautopas_1_1ParticleCell.html">autopas::ParticleCell&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:adc1aac6e9554a08ef005ddf036d15c54 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1AutoPasLock.html">AutoPasLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#adc1aac6e9554a08ef005ddf036d15c54">_cellLock</a> {}</td></tr>
<tr class="memdesc:adc1aac6e9554a08ef005ddf036d15c54 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock object for exclusive access to this cell.  <br /></td></tr>
<tr class="separator:adc1aac6e9554a08ef005ddf036d15c54 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912cd158447a3b696071631ac35e46da inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="a912cd158447a3b696071631ac35e46da" name="a912cd158447a3b696071631ac35e46da"></a>
<a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0">OwnershipState</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_ownershipState</b> {<a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0a8f9a4c5fe0824547590a3fc568f5c7c7">autopas::OwnershipState::owned</a> | <a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0a57f842286171094855e51fc3a541c1e2">autopas::OwnershipState::halo</a>}</td></tr>
<tr class="memdesc:a912cd158447a3b696071631ac35e46da inherit pro_attribs_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">The particles which can be contained in this cell are determined by the OwnershipState. <br /></td></tr>
<tr class="separator:a912cd158447a3b696071631ac35e46da inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d779bb5057b5009a167c9e6a4e9305 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="ae0d779bb5057b5009a167c9e6a4e9305" name="ae0d779bb5057b5009a167c9e6a4e9305"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_ownershipStateDefined</b> {false}</td></tr>
<tr class="memdesc:ae0d779bb5057b5009a167c9e6a4e9305 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag that is set to true once OwnershipState has been set to avoid resetting the OwnershipState. <br /></td></tr>
<tr class="separator:ae0d779bb5057b5009a167c9e6a4e9305 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Particle_T&gt;<br />
class autopas::OctreeNodeWrapper&lt; Particle_T &gt;</div><p>This class wraps the functionality provided by the octree leaves and inner nodes in a structure that adheres to the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> concept. </p>
<p>What this wrapper does is the following: It <em>hides implementation details</em> of the octree nodes that should not be exposed to the outside. (For instance, the <code><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab5d236108b1d67a05e03eb0ca49a7422" title="Insert a particle into the octree.">OctreeNodeInterface::insert()</a></code> method has a very specific method signature that requires the caller to change the pointer to a subtree if necessary. Since the user should not care about this, it is wrapped in this class inside of the <code><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ae3b121e4796603564af1a4bd639111fe" title="Adds a Particle to the cell.">addParticle()</a></code> method. This method does not have to be treated special like <code>insert()</code>.)</p>
<p>This class includes some proxy methods: <code>appendAllParticles()</code>, <code><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a0ed4db5868acc408d2bde676e9cca038" title="Append all leaves in the octree to a list.">appendAllLeaves()</a></code> and some more. Those methods only invoke similar functions on the pointer to an octree. This indirection could be removed by implementing the <code><a class="el" href="classautopas_1_1OctreeNodeInterface.html" title="The base class that provides the necessary function definitions that can be applied to an octree.">OctreeNodeInterface</a>&lt;Particle_T&gt;</code>. However, if this class inherited directly from <code><a class="el" href="classautopas_1_1OctreeNodeInterface.html" title="The base class that provides the necessary function definitions that can be applied to an octree.">OctreeNodeInterface</a>&lt;Particle_T&gt;</code>, it would have to implement the <em>entire interface</em> provided by <code><a class="el" href="classautopas_1_1OctreeNodeInterface.html" title="The base class that provides the necessary function definitions that can be applied to an octree.">OctreeNodeInterface</a>&lt;Particle_T&gt;</code>. This does not increase the code quality, since one would have to implement other interface methods (like <code>insert()</code>) that should not be exposed to the outside. Having proxy calls inside this class keeps the interface clean.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle_T</td><td>The particle class that should be used in the octree cell. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a947b6283fcf50081b4ec36834d8895cb" name="a947b6283fcf50081b4ec36834d8895cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947b6283fcf50081b4ec36834d8895cb">&#9670;&#160;</a></span>OctreeNodeWrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::OctreeNodeWrapper </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int unsigned const&#160;</td>
          <td class="paramname"><em>treeSplitThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>interactionLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double const&#160;</td>
          <td class="paramname"><em>cellSizeFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new, empty octree and stores the root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>The min coordinate of the box containing the octree </td></tr>
    <tr><td class="paramname">boxMax</td><td>The max coordinate of the box containing the octree </td></tr>
    <tr><td class="paramname">treeSplitThreshold</td><td>Maximum number of particles inside a leaf before it tries to split itself </td></tr>
    <tr><td class="paramname">interactionLength</td><td>The minimum distance at which a force is considered nonzero, cutoff+skin. </td></tr>
    <tr><td class="paramname">cellSizeFactor</td><td>The cell size factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae3b121e4796603564af1a4bd639111fe" name="ae3b121e4796603564af1a4bd639111fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b121e4796603564af1a4bd639111fe">&#9670;&#160;</a></span>addParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::addParticle </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a Particle to the cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the particle to be added </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#aa68a327fba022da069e42f460b063e68">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a0ed4db5868acc408d2bde676e9cca038" name="a0ed4db5868acc408d2bde676e9cca038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed4db5868acc408d2bde676e9cca038">&#9670;&#160;</a></span>appendAllLeaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::appendAllLeaves </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append all leaves in the octree to a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaves</td><td>The list to which the leaves should be appended to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acde30591ec0a6f8aa39c99a8cb5d08b9" name="acde30591ec0a6f8aa39c99a8cb5d08b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde30591ec0a6f8aa39c99a8cb5d08b9">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Particle_T &amp; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a particle from the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the particle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ref to a particle </dd></dl>

</div>
</div>
<a id="aa7b2fac62184a35f991cac72ad74ab80" name="aa7b2fac62184a35f991cac72ad74ab80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b2fac62184a35f991cac72ad74ab80">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Particle_T &amp; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a particle from the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the particle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const ref to a particle </dd></dl>

</div>
</div>
<a id="ab54d213cd9b668c1cca9234acfab025d" name="ab54d213cd9b668c1cca9234acfab025d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54d213cd9b668c1cca9234acfab025d">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a>, true &gt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the start of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>. </p>
<p>normal use: for(auto iter = cell.begin(); iter.isValid; ++iter){...} </p><dl class="section return"><dt>Returns</dt><dd>the iterator </dd></dl>

</div>
</div>
<a id="a6896c52193bbef4007ad89307afa1764" name="a6896c52193bbef4007ad89307afa1764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6896c52193bbef4007ad89307afa1764">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a>, false &gt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the start of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.   </p>
<p>normal use: for(auto iter = cell.begin(); iter.isValid; ++iter){...} </p><dl class="section return"><dt>Returns</dt><dd>the iterator   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version </dd></dl>

</div>
</div>
<a id="a3ac03af6d8510dcfa9026d5b5c6dac3a" name="a3ac03af6d8510dcfa9026d5b5c6dac3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac03af6d8510dcfa9026d5b5c6dac3a">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all particles in this cell. </p>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#a24a8350d1fc7ea59c0ffdf63d8da8c7d">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a6fe20b80211f224dc97fdbcd3540c775" name="a6fe20b80211f224dc97fdbcd3540c775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe20b80211f224dc97fdbcd3540c775">&#9670;&#160;</a></span>collectAllParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::collectAllParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a> &amp;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append all particles in the octree to a list using DFS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>The list to which the particles should be appended to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8e6a426d7ce239ed99854191d7cf0c3" name="ac8e6a426d7ce239ed99854191d7cf0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e6a426d7ce239ed99854191d7cf0c3">&#9670;&#160;</a></span>deleteByIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::deleteByIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the index-th particle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the particle that shall be deleted </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#a946ae25741ba9249081fe24d501ccfa5">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="aaf0bfe25cd0ec51080322c32220b12d8" name="aaf0bfe25cd0ec51080322c32220b12d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0bfe25cd0ec51080322c32220b12d8">&#9670;&#160;</a></span>deleteDummyParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::deleteDummyParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all dummy particles in this cell. </p>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#aa1600925339d8d42d31abdd8465c15a4">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a641d8df94f0a6cccd26bb36a2b50d380" name="a641d8df94f0a6cccd26bb36a2b50d380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641d8df94f0a6cccd26bb36a2b50d380">&#9670;&#160;</a></span>deleteParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype">Particle_T &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the given particle from the data structure. </p>
<p>This function does not change the tree layout if the node is empty after the operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given pointer still points to a new, valid particle. </dd></dl>

</div>
</div>
<a id="ab32b1543280840ebba0141f76e6cf3f7" name="ab32b1543280840ebba0141f76e6cf3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32b1543280840ebba0141f76e6cf3f7">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a>, true &gt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the end of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.   </p>
<p>normal use: for(auto &amp;p : cell){...} </p><dl class="section return"><dt>Returns</dt><dd>the iterator   </dd></dl>

</div>
</div>
<a id="a8842fdc4fac269ba56dc560805882c61" name="a8842fdc4fac269ba56dc560805882c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8842fdc4fac269ba56dc560805882c61">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#ace58f88efa73f47aa31aa777978e893e">StorageType</a>, false &gt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the end of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.   </p>
<p>normal use: for(auto &amp;p : cell){...} </p><dl class="section return"><dt>Returns</dt><dd>the iterator   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version </dd></dl>

</div>
</div>
<a id="aa0d6934d9ad0d71fabb41562971264f0" name="aa0d6934d9ad0d71fabb41562971264f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d6934d9ad0d71fabb41562971264f0">&#9670;&#160;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the forEach lambda to each particle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>Function to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec99650eafbab3c87d48dcd73101a49e" name="aec99650eafbab3c87d48dcd73101a49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec99650eafbab3c87d48dcd73101a49e">&#9670;&#160;</a></span>forEachInRegion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::forEachInRegion </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the forEach lambda to each particle in the region. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>Function to apply </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f23ec8d22c3dff17dc8ca2c44dc52bf" name="a0f23ec8d22c3dff17dc8ca2c44dc52bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f23ec8d22c3dff17dc8ca2c44dc52bf">&#9670;&#160;</a></span>getCellLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 3 &gt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::getCellLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the side lengths of this cell. </p>
<dl class="section return"><dt>Returns</dt><dd>cell side length </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#ac4e68017cfc40ca9407e03e83d888955">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a5cfa13b8a2c18eb5c6a4ebf4f54ed724" name="a5cfa13b8a2c18eb5c6a4ebf4f54ed724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfa13b8a2c18eb5c6a4ebf4f54ed724">&#9670;&#160;</a></span>getLeavesInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::getLeavesInRange </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all leaves below this subtree that are in the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum coordinate in 3D space of the query area </td></tr>
    <tr><td class="paramname">max</td><td>The maximum coordinate in 3D space of the query area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of all leaf nodes that are in the query region </dd></dl>

</div>
</div>
<a id="a38d704db6349715e7d561fc1c1537509" name="a38d704db6349715e7d561fc1c1537509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d704db6349715e7d561fc1c1537509">&#9670;&#160;</a></span>getNumberOfParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::getNumberOfParticles </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of particles with respect to the specified IteratorBehavior.   </p>
<dl class="section warning"><dt>Warning</dt><dd>: Since this function counts the number of the respective particles in the internal particle storage, this is in O(n) + lock is required. Only use it when it is absolutely necessary to have the exact number of different particle types like owned or halo. If it is enough to have the whole number of particles (owned + halo + dummy), the function <a class="el" href="classautopas_1_1OctreeNodeWrapper.html#a9e135e41c88741c3bff93f17341895d6" title="Get the number of all particles stored in this cell (owned, halo and dummy).">size()</a> can be used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of particles with respect to the specified IteratorBehavior.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#aef492136b8cc0f1c5227b75e8d007223">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a4df1279921840d891fccf4174a0b4b91" name="a4df1279921840d891fccf4174a0b4b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df1279921840d891fccf4174a0b4b91">&#9670;&#160;</a></span>getParticleCellTypeAsEnum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a> <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::getParticleCellTypeAsEnum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an ParticleCellTypeEnum. </p>
<dl class="section return"><dt>Returns</dt><dd>The Cell type as an Enum </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#aabc1db292417b9a91fcbe43a56b4524e">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ad271b7e4f33df478fd42c6d4f6579b4d" name="ad271b7e4f33df478fd42c6d4f6579b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad271b7e4f33df478fd42c6d4f6579b4d">&#9670;&#160;</a></span>getRaw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::getRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a raw pointer to the enclosed cell. </p>
<dl class="section note"><dt>Note</dt><dd>This should only be used for debugging and insight into the internal structure fo the octree. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A raw C pointer to the enclosed node </dd></dl>

</div>
</div>
<a id="a52ce39af53921ceb8caa4091015b3865" name="a52ce39af53921ceb8caa4091015b3865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ce39af53921ceb8caa4091015b3865">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the cell is not empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if at least one particle is stored in this cell </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#a4fd1a2bf74c3538ae508904fe196c4f0">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a36bec16dab2d2dae28ff432e8cf0c365" name="a36bec16dab2d2dae28ff432e8cf0c365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bec16dab2d2dae28ff432e8cf0c365">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Particle_T &amp; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a particle from the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the particle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ref to a particle </dd></dl>

</div>
</div>
<a id="a5a919990711761249e7410c33f4c96dd" name="a5a919990711761249e7410c33f4c96dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a919990711761249e7410c33f4c96dd">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Particle_T &amp; <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a particle from the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the particle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ref to a particle </dd></dl>

</div>
</div>
<a id="a64002d68d4bcf8781671bdfa64ed2458" name="a64002d68d4bcf8781671bdfa64ed2458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64002d68d4bcf8781671bdfa64ed2458">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the reduce lambda to each particle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>Function type </td></tr>
    <tr><td class="paramname">A</td><td>Initial value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>Function to apply </td></tr>
    <tr><td class="paramname">result</td><td>Initial value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d569cbcfb43264827553a5617a97fb9" name="a3d569cbcfb43264827553a5617a97fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d569cbcfb43264827553a5617a97fb9">&#9670;&#160;</a></span>reduceInRegion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::reduceInRegion </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the reduce lambda to each particle in the region. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>Function type </td></tr>
    <tr><td class="paramname">A</td><td>Initial value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>Function to apply </td></tr>
    <tr><td class="paramname">result</td><td>Initial value </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69bbc6c8bf3b6564f87a7e909fa07a35" name="a69bbc6c8bf3b6564f87a7e909fa07a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bbc6c8bf3b6564f87a7e909fa07a35">&#9670;&#160;</a></span>setCellLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::setCellLength </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cellLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the side lengths of this cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellLength</td><td>cell side length </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#ad229dcc7028778120dfe33b3161d9201">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a9e135e41c88741c3bff93f17341895d6" name="a9e135e41c88741c3bff93f17341895d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e135e41c88741c3bff93f17341895d6">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1OctreeNodeWrapper.html">autopas::OctreeNodeWrapper</a>&lt; Particle_T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of all particles stored in this cell (owned, halo and dummy). </p>
<dl class="section return"><dt>Returns</dt><dd>number of particles stored in this cell (owned, halo and dummy). </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleCell.html#a3a047b4cc19bc7c29b6153ab48556cc6">autopas::ParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autopas/containers/octree/<a class="el" href="OctreeNodeWrapper_8h_source.html">OctreeNodeWrapper.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1TuningStrategyInterface.html">TuningStrategyInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classautopas_1_1TuningStrategyInterface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::TuningStrategyInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Interface for tuning strategies for the auto tuner.  
 <a href="classautopas_1_1TuningStrategyInterface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TuningStrategyInterface_8h_source.html">TuningStrategyInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::TuningStrategyInterface:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1TuningStrategyInterface__inherit__graph.png" border="0" usemap="#aautopas_1_1TuningStrategyInterface_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1TuningStrategyInterface_inherit__map" id="aautopas_1_1TuningStrategyInterface_inherit__map">
<area shape="rect" title="Interface for tuning strategies for the auto tuner." alt="" coords="5,260,243,285"/>
<area shape="rect" href="classautopas_1_1ActiveHarmony.html" title="Interface to the Active Harmony (AH) tuning framework." alt="" coords="311,5,493,31"/>
<area shape="poly" title=" " alt="" coords="134,246,156,201,190,145,234,89,261,63,289,41,315,28,318,33,292,46,264,67,238,92,194,149,161,204,139,249"/>
<area shape="rect" href="classautopas_1_1BayesianClusterSearch.html" title="Assume that the stochastic distribution of the execution time while fixing discrete variables corresp..." alt="" coords="308,55,496,95"/>
<area shape="poly" title=" " alt="" coords="141,247,201,177,243,138,289,105,314,93,317,98,292,110,246,142,205,181,145,251"/>
<area shape="rect" href="classautopas_1_1BayesianSearch.html" title="Assume that the stochastic distribution of the execution time corresponds to a Gaussian Process." alt="" coords="309,120,495,145"/>
<area shape="poly" title=" " alt="" coords="148,249,210,202,249,177,290,156,326,143,328,148,292,160,251,181,213,206,151,253"/>
<area shape="rect" href="classautopas_1_1MPIParallelizedStrategy.html" title="This strategy spreads the configuration queue in a round robin fashion over all ranks (with similar d..." alt="" coords="311,170,493,210"/>
<area shape="poly" title=" " alt="" coords="178,253,290,219,330,208,332,213,291,225,180,259"/>
<area shape="rect" href="classautopas_1_1PredictiveTuning.html" title="In every tuning phase, this strategy makes a prediction about the run time for every configuration." alt="" coords="307,235,497,260"/>
<area shape="poly" title=" " alt="" coords="256,258,307,253,307,259,257,263"/>
<area shape="rect" href="classautopas_1_1RandomSearch.html" title="Randomly test a given number of configurations and select the fastest." alt="" coords="312,284,492,309"/>
<area shape="poly" title=" " alt="" coords="257,281,312,286,312,292,256,287"/>
<area shape="rect" href="classautopas_1_1RuleBasedTuning.html" title="A tuning strategy that uses information collected live from the domain to exclude configurations that..." alt="" coords="305,333,499,359"/>
<area shape="poly" title=" " alt="" coords="180,287,291,318,343,331,342,336,290,323,179,292"/>
<area shape="rect" href="classautopas_1_1SlowConfigFilter.html" title="Acts as a blacklist for configurations that have proven to be very slow." alt="" coords="309,383,495,408"/>
<area shape="poly" title=" " alt="" coords="155,291,216,330,292,368,331,380,330,385,290,372,214,335,152,295"/>
<area shape="rect" href="classautopas_1_1SortByName.html" title="This strategy sorts the given queue by Configuration::operator&lt;() to minimize the container conversio..." alt="" coords="320,432,484,457"/>
<area shape="poly" title=" " alt="" coords="147,294,207,356,248,389,292,417,324,430,322,434,289,422,245,394,204,360,143,298"/>
<area shape="rect" href="classautopas_1_1TuningStrategyLogger.html" title="This dummy strategy logs any call made to the list of strategies." alt="" coords="291,481,513,507"/>
<area shape="poly" title=" " alt="" coords="141,296,165,335,199,381,242,428,292,466,320,479,317,484,289,471,239,432,195,384,161,338,137,299"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02d304fb2f47fc32d2662803323fb8b9"><td class="memItemLeft" align="right" valign="top">virtual TuningStrategyOption&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a02d304fb2f47fc32d2662803323fb8b9">getOptionType</a> () const =0</td></tr>
<tr class="memdesc:a02d304fb2f47fc32d2662803323fb8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this object's associated TuningStrategyOption type.  <br /></td></tr>
<tr class="separator:a02d304fb2f47fc32d2662803323fb8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2e11a52988f7c4d67eccf353335b61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a0e2e11a52988f7c4d67eccf353335b61">addEvidence</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;configuration, const <a class="el" href="classautopas_1_1Evidence.html">Evidence</a> &amp;evidence)</td></tr>
<tr class="memdesc:a0e2e11a52988f7c4d67eccf353335b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the strategy about empirically collected information for the given configuration.  <br /></td></tr>
<tr class="separator:a0e2e11a52988f7c4d67eccf353335b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e766b635dea87edc8e81fa85af0f41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a45e766b635dea87edc8e81fa85af0f41">optimizeSuggestions</a> (std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp;evidenceCollection)=0</td></tr>
<tr class="memdesc:a45e766b635dea87edc8e81fa85af0f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes the queue of configurations to process.  <br /></td></tr>
<tr class="separator:a45e766b635dea87edc8e81fa85af0f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9b4f910967a9a9251939ceaec3e755"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7e9b4f910967a9a9251939ceaec3e755">reset</a> (size_t iteration, size_t tuningPhase, std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">autopas::EvidenceCollection</a> &amp;evidenceCollection)=0</td></tr>
<tr class="memdesc:a7e9b4f910967a9a9251939ceaec3e755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all internal parameters to the beginning of a new tuning phase.  <br /></td></tr>
<tr class="separator:a7e9b4f910967a9a9251939ceaec3e755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0bc535436e8aa6a8b25b6f1b50b5e2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7c0bc535436e8aa6a8b25b6f1b50b5e2">needsLiveInfo</a> () const</td></tr>
<tr class="memdesc:a7c0bc535436e8aa6a8b25b6f1b50b5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tuning strategy wants to get a <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object passed before a new tuning phase.  <br /></td></tr>
<tr class="separator:a7c0bc535436e8aa6a8b25b6f1b50b5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb1ba7e258aa647bc0a442a1982f8f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a9cb1ba7e258aa647bc0a442a1982f8f8">receiveLiveInfo</a> (const <a class="el" href="classautopas_1_1LiveInfo.html">LiveInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a9cb1ba7e258aa647bc0a442a1982f8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method that subclasses can override to receive the <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object before a tuning phase if they return true in <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7c0bc535436e8aa6a8b25b6f1b50b5e2" title="Returns whether this tuning strategy wants to get a LiveInfo object passed before a new tuning phase.">needsLiveInfo()</a>.  <br /></td></tr>
<tr class="separator:a9cb1ba7e258aa647bc0a442a1982f8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc2e5b8444200e7429fd7dd457fc13f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a3cc2e5b8444200e7429fd7dd457fc13f">rejectConfiguration</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;configuration, bool indefinitely)</td></tr>
<tr class="memdesc:a3cc2e5b8444200e7429fd7dd457fc13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the strategy about a configuration that is (currently) invalid and thus can potentially be dropped from some internal storage.  <br /></td></tr>
<tr class="separator:a3cc2e5b8444200e7429fd7dd457fc13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f14f8d8fd82e945783a3715452d99f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a55f14f8d8fd82e945783a3715452d99f">needsSmoothedHomogeneityAndMaxDensity</a> () const</td></tr>
<tr class="memdesc:a55f14f8d8fd82e945783a3715452d99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether the strategy needs smoothed values of homogeneity and max density.  <br /></td></tr>
<tr class="separator:a55f14f8d8fd82e945783a3715452d99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f063297e8df6c7903651232b372573c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a3f063297e8df6c7903651232b372573c">receiveSmoothedHomogeneityAndMaxDensity</a> (double homogeneity, double maxDensity)</td></tr>
<tr class="memdesc:a3f063297e8df6c7903651232b372573c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to pass smoothed homogeneity and the maximal density to the tuning strategy.  <br /></td></tr>
<tr class="separator:a3f063297e8df6c7903651232b372573c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for tuning strategies for the auto tuner. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e2e11a52988f7c4d67eccf353335b61" name="a0e2e11a52988f7c4d67eccf353335b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2e11a52988f7c4d67eccf353335b61">&#9670;&#160;</a></span>addEvidence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void autopas::TuningStrategyInterface::addEvidence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1Evidence.html">Evidence</a> &amp;&#160;</td>
          <td class="paramname"><em>evidence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the strategy about empirically collected information for the given configuration. </p>
<p>All evidence is stored centrally in the <a class="el" href="classautopas_1_1AutoTuner.html" title="This class manages all logic related to the auto tuning mechanic.">AutoTuner</a> and its <a class="el" href="classautopas_1_1EvidenceCollection.html" title="Class to manage all evidence.">EvidenceCollection</a> is passed to the tuning strategies during optimization.</p>
<p>Implementing this function is only necessary if the tuning strategy processes evidence differently than <a class="el" href="classautopas_1_1EvidenceCollection.html" title="Class to manage all evidence.">EvidenceCollection</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configuration</td><td><a class="el" href="classautopas_1_1Configuration.html" title="Class containing multiple options that form an algorithm configuration for the pairwise iteration.">Configuration</a> used to obtain the evidence. </td></tr>
    <tr><td class="paramname">evidence</td><td>Measurement and when it was taken. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classautopas_1_1ActiveHarmony.html#ae774e574a88706e41c867bb7dd30e6a6">autopas::ActiveHarmony</a>, <a class="el" href="classautopas_1_1BayesianClusterSearch.html#a6d54481bcc28df5f821fda53390a93f0">autopas::BayesianClusterSearch</a>, <a class="el" href="classautopas_1_1BayesianSearch.html#a189ad8409daed67b39d854d313fd84a4">autopas::BayesianSearch</a>, <a class="el" href="classautopas_1_1PredictiveTuning.html#afab5087c92fd09a7a4aed7f1256c4071">autopas::PredictiveTuning</a>, <a class="el" href="classautopas_1_1RuleBasedTuning.html#a71ecb9ddb93d39f4f71f13a91adef0c7">autopas::RuleBasedTuning</a>, and <a class="el" href="classautopas_1_1TuningStrategyLogger.html#aaf6f8234ae21d16d48e6e6a0b4029dab">autopas::TuningStrategyLogger</a>.</p>

</div>
</div>
<a id="a02d304fb2f47fc32d2662803323fb8b9" name="a02d304fb2f47fc32d2662803323fb8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d304fb2f47fc32d2662803323fb8b9">&#9670;&#160;</a></span>getOptionType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TuningStrategyOption autopas::TuningStrategyInterface::getOptionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get this object's associated TuningStrategyOption type. </p>
<dl class="section return"><dt>Returns</dt><dd>TuningStrategyOption </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1ActiveHarmony.html#a2f63000f38a77c98a64bf3b77194a8a3">autopas::ActiveHarmony</a>, <a class="el" href="classautopas_1_1BayesianClusterSearch.html#a06944115cb3ffcaf09aed524eacc3376">autopas::BayesianClusterSearch</a>, <a class="el" href="classautopas_1_1BayesianSearch.html#a3fe2f1694cd142a583f4026bce0d6e70">autopas::BayesianSearch</a>, <a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#a7bdbe8e620e4be0187c9b1e7ba55726a">autopas::MPIParallelizedStrategy</a>, <a class="el" href="classautopas_1_1PredictiveTuning.html#a73aaadc66d5bdd13193ec6702797e287">autopas::PredictiveTuning</a>, <a class="el" href="classautopas_1_1RandomSearch.html#a35ceeac2727f4ae2b73ff1acc6e5a7ce">autopas::RandomSearch</a>, <a class="el" href="classautopas_1_1RuleBasedTuning.html#a7901d0769308135e6e8ebb7b2e3418e5">autopas::RuleBasedTuning</a>, <a class="el" href="classautopas_1_1SlowConfigFilter.html#ad64bbbc4dc73ce48230ce7eb22c8ef63">autopas::SlowConfigFilter</a>, <a class="el" href="classautopas_1_1SortByName.html#a481d913361dfb911a7a618c8f838b267">autopas::SortByName</a>, and <a class="el" href="classautopas_1_1TuningStrategyLogger.html#a5786f1a6a62b7ae84595b230ec917c37">autopas::TuningStrategyLogger</a>.</p>

</div>
</div>
<a id="a7c0bc535436e8aa6a8b25b6f1b50b5e2" name="a7c0bc535436e8aa6a8b25b6f1b50b5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0bc535436e8aa6a8b25b6f1b50b5e2">&#9670;&#160;</a></span>needsLiveInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool autopas::TuningStrategyInterface::needsLiveInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this tuning strategy wants to get a <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object passed before a new tuning phase. </p>
<dl class="section return"><dt>Returns</dt><dd>True, if this tuning strategy wants a <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object passed before a new tuning phase via <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a9cb1ba7e258aa647bc0a442a1982f8f8" title="Virtual method that subclasses can override to receive the LiveInfo object before a tuning phase if t...">receiveLiveInfo()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classautopas_1_1RuleBasedTuning.html#ad4d9f87c41cdebf10da537e5db555baf">autopas::RuleBasedTuning</a>, and <a class="el" href="classautopas_1_1TuningStrategyLogger.html#abab67c50b4a84902fa5ad9edab56a38e">autopas::TuningStrategyLogger</a>.</p>

</div>
</div>
<a id="a55f14f8d8fd82e945783a3715452d99f" name="a55f14f8d8fd82e945783a3715452d99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f14f8d8fd82e945783a3715452d99f">&#9670;&#160;</a></span>needsSmoothedHomogeneityAndMaxDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool autopas::TuningStrategyInterface::needsSmoothedHomogeneityAndMaxDensity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate whether the strategy needs smoothed values of homogeneity and max density. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Reimplemented in <a class="el" href="classautopas_1_1ActiveHarmony.html#a3145544c3587f8c4a3eabe9657ea5745">autopas::ActiveHarmony</a>, <a class="el" href="classautopas_1_1BayesianClusterSearch.html#a5f46ba5f94ad69ecb866bf0ffb33c2d3">autopas::BayesianClusterSearch</a>, <a class="el" href="classautopas_1_1BayesianSearch.html#adc67b8839af2f517757303a55b4e2a69">autopas::BayesianSearch</a>, and <a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#a83434c982e6f2d4a501e9ee01258b8d9">autopas::MPIParallelizedStrategy</a>.</p>

</div>
</div>
<a id="a45e766b635dea87edc8e81fa85af0f41" name="a45e766b635dea87edc8e81fa85af0f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e766b635dea87edc8e81fa85af0f41">&#9670;&#160;</a></span>optimizeSuggestions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void autopas::TuningStrategyInterface::optimizeSuggestions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>evidenceCollection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimizes the queue of configurations to process. </p>
<p>This function is called once before each iteration in a tuning phase so all tuning strategies can give their input on which configuration to try next. This is done by reordering configQueue so that the next configuration to try is at the end (FIFO).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configQueue</td><td>Queue of configurations to be tested. The tuning strategy should edit this queue. </td></tr>
    <tr><td class="paramname">evidenceCollection</td><td>All collected evidence until now. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1ActiveHarmony.html#a295e2476ea60ca2783e24f2716f1320d">autopas::ActiveHarmony</a>, <a class="el" href="classautopas_1_1BayesianClusterSearch.html#a0f0822a764f4053c283eabea1f06d972">autopas::BayesianClusterSearch</a>, <a class="el" href="classautopas_1_1BayesianSearch.html#a9561b3339d23f948fc40d116704a9237">autopas::BayesianSearch</a>, <a class="el" href="classautopas_1_1PredictiveTuning.html#ac2ca7072b0f69a4e89d89b98bfadeea7">autopas::PredictiveTuning</a>, <a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#af6e9c5cb464646ab4129d48ad26c46c9">autopas::MPIParallelizedStrategy</a>, <a class="el" href="classautopas_1_1RandomSearch.html#ac1202d49cdaa5c89183ff77b5b1fceb5">autopas::RandomSearch</a>, <a class="el" href="classautopas_1_1RuleBasedTuning.html#a70c2df670f375a45e933d522a6515991">autopas::RuleBasedTuning</a>, <a class="el" href="classautopas_1_1SlowConfigFilter.html#aa95b0c365d237b512d1062f748f099ce">autopas::SlowConfigFilter</a>, <a class="el" href="classautopas_1_1SortByName.html#a12fac46a3d5c9abe7d30e397573dd928">autopas::SortByName</a>, and <a class="el" href="classautopas_1_1TuningStrategyLogger.html#aec98eb07f4e048de252eb03b3acb5222">autopas::TuningStrategyLogger</a>.</p>

</div>
</div>
<a id="a9cb1ba7e258aa647bc0a442a1982f8f8" name="a9cb1ba7e258aa647bc0a442a1982f8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb1ba7e258aa647bc0a442a1982f8f8">&#9670;&#160;</a></span>receiveLiveInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void autopas::TuningStrategyInterface::receiveLiveInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1LiveInfo.html">LiveInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method that subclasses can override to receive the <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object before a tuning phase if they return true in <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7c0bc535436e8aa6a8b25b6f1b50b5e2" title="Returns whether this tuning strategy wants to get a LiveInfo object passed before a new tuning phase.">needsLiveInfo()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A new <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object that has already gathered its information. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classautopas_1_1RuleBasedTuning.html#ab39e5d203d278395044c57f9e6e0eb5a">autopas::RuleBasedTuning</a>, and <a class="el" href="classautopas_1_1TuningStrategyLogger.html#aa83f3ab2c154c01790b57feacb9c63a1">autopas::TuningStrategyLogger</a>.</p>

</div>
</div>
<a id="a3f063297e8df6c7903651232b372573c" name="a3f063297e8df6c7903651232b372573c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f063297e8df6c7903651232b372573c">&#9670;&#160;</a></span>receiveSmoothedHomogeneityAndMaxDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void autopas::TuningStrategyInterface::receiveSmoothedHomogeneityAndMaxDensity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>homogeneity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDensity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to pass smoothed homogeneity and the maximal density to the tuning strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">homogeneity</td><td></td></tr>
    <tr><td class="paramname">maxDensity</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#a11fb42dab3f4d7a0193c98a7053bae4e">autopas::MPIParallelizedStrategy</a>.</p>

</div>
</div>
<a id="a3cc2e5b8444200e7429fd7dd457fc13f" name="a3cc2e5b8444200e7429fd7dd457fc13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc2e5b8444200e7429fd7dd457fc13f">&#9670;&#160;</a></span>rejectConfiguration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void autopas::TuningStrategyInterface::rejectConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>indefinitely</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the strategy about a configuration that is (currently) invalid and thus can potentially be dropped from some internal storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configuration</td><td></td></tr>
    <tr><td class="paramname">indefinitely</td><td>Whether the given configuration will never be valid </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classautopas_1_1BayesianClusterSearch.html#a0debb27adbe13634bd910e7e7a8c84fc">autopas::BayesianClusterSearch</a>, <a class="el" href="classautopas_1_1BayesianSearch.html#af0f30177775410c134ebcf62c57ce869">autopas::BayesianSearch</a>, <a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#ab5cadb79788c1b72ff159ecd8dac9b76">autopas::MPIParallelizedStrategy</a>, and <a class="el" href="classautopas_1_1PredictiveTuning.html#a07c52fa740c3badd9d8a253fa3051655">autopas::PredictiveTuning</a>.</p>

</div>
</div>
<a id="a7e9b4f910967a9a9251939ceaec3e755" name="a7e9b4f910967a9a9251939ceaec3e755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9b4f910967a9a9251939ceaec3e755">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void autopas::TuningStrategyInterface::reset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tuningPhase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1EvidenceCollection.html">autopas::EvidenceCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>evidenceCollection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all internal parameters to the beginning of a new tuning phase. </p>
<p>This can also mean to reorder the configQueue to some initially expected state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iteration</td><td>Gives the current iteration to the tuning strategy. </td></tr>
    <tr><td class="paramname">tuningPhase</td><td>Gives the current tuning phase to the tuning strategy. </td></tr>
    <tr><td class="paramname">configQueue</td><td>Queue of configurations to be tested. The tuning strategy should edit this queue. </td></tr>
    <tr><td class="paramname">evidenceCollection</td><td>All collected evidence until now. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1ActiveHarmony.html#a95c6317eb6fe870c3ffd98d6716664bf">autopas::ActiveHarmony</a>, <a class="el" href="classautopas_1_1BayesianClusterSearch.html#a519868de05380b674d27d0c08bf23bea">autopas::BayesianClusterSearch</a>, <a class="el" href="classautopas_1_1BayesianSearch.html#a81797266972ef8c0c6cfaf9e9aa10af0">autopas::BayesianSearch</a>, <a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#afeaed418a45c28014c345e5ee1b92ec3">autopas::MPIParallelizedStrategy</a>, <a class="el" href="classautopas_1_1PredictiveTuning.html#a30982270aaca9715ce57af023a82cd9f">autopas::PredictiveTuning</a>, <a class="el" href="classautopas_1_1RuleBasedTuning.html#a47e1dd2fab99098fb4178f88bc42b929">autopas::RuleBasedTuning</a>, <a class="el" href="classautopas_1_1TuningStrategyLogger.html#a8d646d54c86ffb524f74d2334240aa2d">autopas::TuningStrategyLogger</a>, <a class="el" href="classautopas_1_1SlowConfigFilter.html#a41f04f35ef0b0d3ccd9aa98ffe402001">autopas::SlowConfigFilter</a>, <a class="el" href="classautopas_1_1SortByName.html#a78692b84365d30a13c8f326782d955c9">autopas::SortByName</a>, and <a class="el" href="classautopas_1_1RandomSearch.html#adad7cf804a2799adc8bbdf09d9632dfa">autopas::RandomSearch</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autopas/tuning/tuningStrategy/<a class="el" href="TuningStrategyInterface_8h_source.html">TuningStrategyInterface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

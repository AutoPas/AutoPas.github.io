<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classautopas_1_1ParticleContainerInterface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::ParticleContainerInterface&lt; Particle_T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classautopas_1_1ParticleContainerInterface.html" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas.">ParticleContainerInterface</a> class provides a basic interface for all Containers within <a class="el" href="classautopas_1_1AutoPas.html" title="The AutoPas class is intended to be the main point of Interaction for the user.">AutoPas</a>.  
 <a href="classautopas_1_1ParticleContainerInterface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ParticleContainerInterface_8h_source.html">ParticleContainerInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::ParticleContainerInterface&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1ParticleContainerInterface__inherit__graph.png" border="0" usemap="#aautopas_1_1ParticleContainerInterface_3_01Particle__T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1ParticleContainerInterface_3_01Particle__T_01_4_inherit__map" id="aautopas_1_1ParticleContainerInterface_3_01Particle__T_01_4_inherit__map">
<area shape="rect" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas." alt="" coords="5,133,199,173"/>
<area shape="rect" href="classautopas_1_1VerletClusterLists.html" title=" " alt="" coords="803,5,1013,45"/>
<area shape="poly" title=" " alt="" coords="157,125,222,99,314,69,409,51,513,38,618,29,802,23,802,28,619,35,514,43,410,56,315,74,224,104,159,130"/>
<area shape="rect" href="classautopas_1_1VerletClusterLists.html" title="Particles are divided into clusters." alt="" coords="409,65,605,105"/>
<area shape="poly" title=" " alt="" coords="212,132,409,99,410,104,212,138"/>
<area shape="rect" href="classautopas_1_1VerletListsLinkedBase.html" title="Base class for Verlet lists which use an underlying linked cells container." alt="" coords="411,133,603,173"/>
<area shape="poly" title=" " alt="" coords="212,151,411,151,411,156,212,156"/>
<area shape="rect" href="classautopas_1_1ParticleContainerInterface.html" title=" " alt="" coords="411,341,604,395"/>
<area shape="poly" title=" " alt="" coords="154,177,456,338,453,343,152,182"/>
<area shape="rect" href="classautopas_1_1ParticleContainerInterface.html" title=" " alt="" coords="411,419,604,474"/>
<area shape="poly" title=" " alt="" coords="120,185,161,258,190,297,224,331,268,362,316,386,365,406,411,422,410,427,363,411,314,391,265,366,221,335,186,301,156,261,115,187"/>
<area shape="poly" title=" " alt="" coords="620,91,699,87,739,81,778,71,789,64,801,55,831,43,833,48,804,60,792,68,780,76,740,86,699,93,620,96"/>
<area shape="rect" href="classautopas_1_1VarVerletLists.html" title="Variable Verlet Lists container with different neighbor lists." alt="" coords="805,133,1011,173"/>
<area shape="poly" title=" " alt="" coords="617,151,805,151,805,156,617,156"/>
<area shape="rect" href="classautopas_1_1VerletLists.html" title="Verlet Lists container." alt="" coords="833,197,983,237"/>
<area shape="poly" title=" " alt="" coords="617,168,833,203,832,208,616,173"/>
<area shape="rect" href="classautopas_1_1VerletListsCells.html" title="Linked Cells with Verlet Lists container." alt="" coords="805,69,1011,109"/>
<area shape="poly" title=" " alt="" coords="617,133,805,103,806,108,617,139"/>
<area shape="rect" href="classautopas_1_1CellBasedParticleContainer.html" title=" " alt="" coords="1288,354,1484,409"/>
<area shape="poly" title=" " alt="" coords="618,367,1288,377,1288,383,618,372"/>
<area shape="rect" href="classautopas_1_1CellBasedParticleContainer.html" title=" " alt="" coords="1267,249,1505,303"/>
<area shape="poly" title=" " alt="" coords="617,347,812,318,1037,291,1266,277,1266,282,1038,296,813,323,618,352"/>
<area shape="rect" href="classautopas_1_1CellBasedParticleContainer.html" title=" " alt="" coords="1270,514,1502,569"/>
<area shape="poly" title=" " alt="" coords="594,399,607,406,631,423,739,472,827,501,919,518,1038,533,1157,542,1270,543,1270,549,1157,548,1037,539,918,523,826,506,737,477,628,428,604,410,591,404"/>
<area shape="rect" href="classautopas_1_1CellBasedParticleContainer.html" title=" " alt="" coords="1273,599,1499,654"/>
<area shape="poly" title=" " alt="" coords="604,402,608,406,619,429,620,451,620,471,631,492,679,536,724,566,768,587,813,599,913,612,1038,627,1098,634,1158,637,1272,634,1273,640,1158,642,1097,639,1037,632,912,617,812,604,766,592,721,571,675,540,627,495,615,473,614,451,614,430,603,410,600,406"/>
<area shape="rect" href="classautopas_1_1CellBasedParticleContainer.html" title="The CellBasedParticleContainer class stores particles in some object and provides methods to iterate ..." alt="" coords="807,427,1009,467"/>
<area shape="poly" title=" " alt="" coords="618,387,807,424,806,429,617,392"/>
<area shape="rect" href="classautopas_1_1DirectSum.html" title="This class stores all owned particles in a single cell." alt="" coords="1594,320,1745,360"/>
<area shape="poly" title=" " alt="" coords="1498,362,1593,348,1594,354,1498,368"/>
<area shape="rect" href="classautopas_1_1LinkedCells.html" title="LinkedCells class." alt="" coords="1591,384,1747,424"/>
<area shape="poly" title=" " alt="" coords="1498,388,1591,395,1591,400,1498,393"/>
<area shape="rect" href="classautopas_1_1LinkedCells.html" title=" " alt="" coords="1981,420,2192,460"/>
<area shape="poly" title=" " alt="" coords="1761,409,1981,428,1981,434,1761,415"/>
<area shape="rect" href="classautopas_1_1LinkedCellsReferences.html" title="LinkedCells class." alt="" coords="1555,256,1784,296"/>
<area shape="poly" title=" " alt="" coords="1519,273,1554,273,1554,279,1519,279"/>
<area shape="rect" href="classautopas_1_1Octree.html" title="The octree is a CellBasedParticleContainer that consists internally of two octrees." alt="" coords="1560,529,1779,554"/>
<area shape="poly" title=" " alt="" coords="1516,539,1560,539,1560,544,1516,544"/>
<area shape="poly" title=" " alt="" coords="1023,438,1130,428,1242,413,1287,404,1288,410,1243,419,1130,434,1023,443"/>
<area shape="poly" title=" " alt="" coords="1023,443,1981,438,1981,443,1023,449"/>
<area shape="poly" title=" " alt="" coords="955,418,1036,379,1093,359,1138,347,1242,320,1302,301,1304,306,1243,325,1140,352,1095,364,1038,384,957,422"/>
<area shape="poly" title=" " alt="" coords="955,471,995,491,1038,507,1096,520,1157,530,1270,538,1270,544,1156,535,1095,526,1037,512,993,496,953,476"/>
<area shape="poly" title=" " alt="" coords="933,476,978,526,1007,551,1039,571,1096,594,1156,610,1217,619,1273,624,1272,630,1216,625,1155,615,1094,599,1036,576,1004,555,974,530,929,480"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4f0695c5d46b1e1c8fce247204e82dee"><td class="memItemLeft" align="right" valign="top"><a id="a4f0695c5d46b1e1c8fce247204e82dee" name="a4f0695c5d46b1e1c8fce247204e82dee"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleType</b> = Particle_T</td></tr>
<tr class="memdesc:a4f0695c5d46b1e1c8fce247204e82dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Particle. <br /></td></tr>
<tr class="separator:a4f0695c5d46b1e1c8fce247204e82dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad9a908bc9d3768eae4611816b65265f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ad9a908bc9d3768eae4611816b65265f5">ParticleContainerInterface</a> (double skin)</td></tr>
<tr class="memdesc:ad9a908bc9d3768eae4611816b65265f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ad9a908bc9d3768eae4611816b65265f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc06b03e7a877579abba7e458f1142b4"><td class="memItemLeft" align="right" valign="top"><a id="afc06b03e7a877579abba7e458f1142b4" name="afc06b03e7a877579abba7e458f1142b4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ParticleContainerInterface</b> ()=default</td></tr>
<tr class="memdesc:afc06b03e7a877579abba7e458f1142b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of <a class="el" href="classautopas_1_1ParticleContainerInterface.html" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas.">ParticleContainerInterface</a>. <br /></td></tr>
<tr class="separator:afc06b03e7a877579abba7e458f1142b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7de3c91ce2894734525cd7362ed0050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ae7de3c91ce2894734525cd7362ed0050">ParticleContainerInterface</a> (const <a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp;obj)=delete</td></tr>
<tr class="memdesc:ae7de3c91ce2894734525cd7362ed0050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the copy constructor to prevent unwanted copies.  <br /></td></tr>
<tr class="separator:ae7de3c91ce2894734525cd7362ed0050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116a79a89fac9059da41e2ada2257a3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a116a79a89fac9059da41e2ada2257a3c">operator=</a> (const <a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a116a79a89fac9059da41e2ada2257a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the copy assignment operator to prevent unwanted copies.  <br /></td></tr>
<tr class="separator:a116a79a89fac9059da41e2ada2257a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941f6d9f49ee4a45f0ba0ea6bf64fd3c"><td class="memItemLeft" align="right" valign="top">virtual ContainerOption&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a941f6d9f49ee4a45f0ba0ea6bf64fd3c">getContainerType</a> () const =0</td></tr>
<tr class="memdesc:a941f6d9f49ee4a45f0ba0ea6bf64fd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ContainerType.  <br /></td></tr>
<tr class="separator:a941f6d9f49ee4a45f0ba0ea6bf64fd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d65a563cfbdb1828379458db0dfadf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a81d65a563cfbdb1828379458db0dfadf">reserve</a> (size_t numParticles, size_t numParticlesHaloEstimate)=0</td></tr>
<tr class="memdesc:a81d65a563cfbdb1828379458db0dfadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for a given number of particles in the container and logic layers.    <br /></td></tr>
<tr class="separator:a81d65a563cfbdb1828379458db0dfadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c350201102d10da0e549435e9b1d99"><td class="memTemplParams" colspan="2">template&lt;bool checkInBox = true&gt; </td></tr>
<tr class="memitem:ab2c350201102d10da0e549435e9b1d99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab2c350201102d10da0e549435e9b1d99">addParticle</a> (const Particle_T &amp;p)</td></tr>
<tr class="memdesc:ab2c350201102d10da0e549435e9b1d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container.  <br /></td></tr>
<tr class="separator:ab2c350201102d10da0e549435e9b1d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570ce9e1be3e46cd15135fa965a39bc7"><td class="memTemplParams" colspan="2">template&lt;bool checkInBox = true&gt; </td></tr>
<tr class="memitem:a570ce9e1be3e46cd15135fa965a39bc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a570ce9e1be3e46cd15135fa965a39bc7">addHaloParticle</a> (const Particle_T &amp;haloParticle)</td></tr>
<tr class="memdesc:a570ce9e1be3e46cd15135fa965a39bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container that lies in the halo region of the container.  <br /></td></tr>
<tr class="separator:a570ce9e1be3e46cd15135fa965a39bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b43eec590054db74704b88d2d896937"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a7b43eec590054db74704b88d2d896937">updateHaloParticle</a> (const Particle_T &amp;haloParticle)=0</td></tr>
<tr class="memdesc:a7b43eec590054db74704b88d2d896937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a halo particle of the container with the given haloParticle.  <br /></td></tr>
<tr class="separator:a7b43eec590054db74704b88d2d896937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a3ffb69099a0917c456e0b844c222b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a08a3ffb69099a0917c456e0b844c222b">rebuildNeighborLists</a> (<a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *traversal)=0</td></tr>
<tr class="memdesc:a08a3ffb69099a0917c456e0b844c222b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuilds the neighbor lists for the next traversals.  <br /></td></tr>
<tr class="separator:a08a3ffb69099a0917c456e0b844c222b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab430b1916311400b6b4108a5596ff8b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab430b1916311400b6b4108a5596ff8b9">deleteHaloParticles</a> ()=0</td></tr>
<tr class="memdesc:ab430b1916311400b6b4108a5596ff8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all halo particles.  <br /></td></tr>
<tr class="separator:ab430b1916311400b6b4108a5596ff8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740fc3a18464478bffd53abadcf9071d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a740fc3a18464478bffd53abadcf9071d">deleteAllParticles</a> ()=0</td></tr>
<tr class="memdesc:a740fc3a18464478bffd53abadcf9071d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles.  <br /></td></tr>
<tr class="separator:a740fc3a18464478bffd53abadcf9071d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cffaa132a5ef9d1f8fc72845bfc81f"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a74cffaa132a5ef9d1f8fc72845bfc81f">getNumberOfParticles</a> (IteratorBehavior behavior=IteratorBehavior::owned) const =0</td></tr>
<tr class="memdesc:a74cffaa132a5ef9d1f8fc72845bfc81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.  <br /></td></tr>
<tr class="separator:a74cffaa132a5ef9d1f8fc72845bfc81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4c790d1bbf0d35988bea267a2e0f59"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aef4c790d1bbf0d35988bea267a2e0f59">size</a> () const =0</td></tr>
<tr class="memdesc:aef4c790d1bbf0d35988bea267a2e0f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of particles saved in the container (owned + halo + dummy).  <br /></td></tr>
<tr class="separator:aef4c790d1bbf0d35988bea267a2e0f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c44a77a74529bb916956269cc617a47"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a8c44a77a74529bb916956269cc617a47">begin</a> (IteratorBehavior behavior=IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, false &gt;::ParticleVecType *additionalVectors=nullptr)=0</td></tr>
<tr class="memdesc:a8c44a77a74529bb916956269cc617a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .  <br /></td></tr>
<tr class="separator:a8c44a77a74529bb916956269cc617a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b0fdbbcb1d9dc20e44948e50519638"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a65b0fdbbcb1d9dc20e44948e50519638">begin</a> (IteratorBehavior behavior=IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt;::ParticleVecType *additionalVectors=nullptr) const =0</td></tr>
<tr class="memdesc:a65b0fdbbcb1d9dc20e44948e50519638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:a65b0fdbbcb1d9dc20e44948e50519638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a49dfbd5a55d9feb38f1297ac4c0262"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a5a49dfbd5a55d9feb38f1297ac4c0262">cbegin</a> (IteratorBehavior behavior=IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt;::ParticleVecType *additionalVectors=nullptr) const</td></tr>
<tr class="memdesc:a5a49dfbd5a55d9feb38f1297ac4c0262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:a5a49dfbd5a55d9feb38f1297ac4c0262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a11f12455c67ec3c000fb09d5de8a7b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a5a11f12455c67ec3c000fb09d5de8a7b">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, true &gt;::ParticleVecType *additionalVectors=nullptr)=0</td></tr>
<tr class="memdesc:a5a11f12455c67ec3c000fb09d5de8a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .  <br /></td></tr>
<tr class="separator:a5a11f12455c67ec3c000fb09d5de8a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9a78a6d0e561463260b10e7ba61f9f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a2c9a78a6d0e561463260b10e7ba61f9f">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, true &gt;::ParticleVecType *additionalVectors=nullptr) const =0</td></tr>
<tr class="memdesc:a2c9a78a6d0e561463260b10e7ba61f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .    <br /></td></tr>
<tr class="separator:a2c9a78a6d0e561463260b10e7ba61f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3092c7f1c29e955d01faed348021ea6c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a3092c7f1c29e955d01faed348021ea6c">end</a> () const</td></tr>
<tr class="memdesc:a3092c7f1c29e955d01faed348021ea6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy to make range-based for loops work.    <br /></td></tr>
<tr class="separator:a3092c7f1c29e955d01faed348021ea6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab383284c81486ed2eeaf8af598c4a4cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab383284c81486ed2eeaf8af598c4a4cb">computeInteractions</a> (<a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *traversal)=0</td></tr>
<tr class="memdesc:ab383284c81486ed2eeaf8af598c4a4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all particle multiples (e.g.  <br /></td></tr>
<tr class="separator:ab383284c81486ed2eeaf8af598c4a4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1778749aee00722d67d0ac4067df602e"><td class="memItemLeft" align="right" valign="top">virtual const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a1778749aee00722d67d0ac4067df602e">getBoxMax</a> () const =0</td></tr>
<tr class="memdesc:a1778749aee00722d67d0ac4067df602e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the upper corner of the container without halo.  <br /></td></tr>
<tr class="separator:a1778749aee00722d67d0ac4067df602e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f55afacd6446eeea5fc34e6468c56f4"><td class="memItemLeft" align="right" valign="top">virtual const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a0f55afacd6446eeea5fc34e6468c56f4">getBoxMin</a> () const =0</td></tr>
<tr class="memdesc:a0f55afacd6446eeea5fc34e6468c56f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lower corner of the container without halo.  <br /></td></tr>
<tr class="separator:a0f55afacd6446eeea5fc34e6468c56f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c65dd1a6a3e98f016d3373b835e3a3"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a15c65dd1a6a3e98f016d3373b835e3a3">getCutoff</a> () const =0</td></tr>
<tr class="memdesc:a15c65dd1a6a3e98f016d3373b835e3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cutoff of the container.  <br /></td></tr>
<tr class="separator:a15c65dd1a6a3e98f016d3373b835e3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6271bbef734203f7d902f61a1e7c9cc3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a6271bbef734203f7d902f61a1e7c9cc3">setCutoff</a> (double cutoff)=0</td></tr>
<tr class="memdesc:a6271bbef734203f7d902f61a1e7c9cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cutoff of the container.  <br /></td></tr>
<tr class="separator:a6271bbef734203f7d902f61a1e7c9cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ff749bcd4540af8bbdda48064dd6c4"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a31ff749bcd4540af8bbdda48064dd6c4">getVerletSkin</a> () const =0</td></tr>
<tr class="memdesc:a31ff749bcd4540af8bbdda48064dd6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the verletSkin of the container verletSkin.  <br /></td></tr>
<tr class="separator:a31ff749bcd4540af8bbdda48064dd6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade006f01a9966aeaee7ff6aff677a995"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ade006f01a9966aeaee7ff6aff677a995">getStepsSinceLastRebuild</a> () const</td></tr>
<tr class="memdesc:ade006f01a9966aeaee7ff6aff677a995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of time-steps since last neighbor list rebuild.  <br /></td></tr>
<tr class="separator:ade006f01a9966aeaee7ff6aff677a995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94447de936c48623cb7f5e71972dd5cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a94447de936c48623cb7f5e71972dd5cb">setStepsSinceLastRebuild</a> (size_t stepsSinceLastRebuild)</td></tr>
<tr class="memdesc:a94447de936c48623cb7f5e71972dd5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of time-steps since last neighbor list rebuild.  <br /></td></tr>
<tr class="separator:a94447de936c48623cb7f5e71972dd5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e30b5867e028a31976bbcb57b8275"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4a7e30b5867e028a31976bbcb57b8275">getInteractionLength</a> () const =0</td></tr>
<tr class="memdesc:a4a7e30b5867e028a31976bbcb57b8275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the interaction length (cutoff+skin) of the container.  <br /></td></tr>
<tr class="separator:a4a7e30b5867e028a31976bbcb57b8275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecc728dcc3e19d6a1219d42580207c4"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; Particle_T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4ecc728dcc3e19d6a1219d42580207c4">updateContainer</a> (bool keepNeighborListsValid)=0</td></tr>
<tr class="memdesc:a4ecc728dcc3e19d6a1219d42580207c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the container.  <br /></td></tr>
<tr class="separator:a4ecc728dcc3e19d6a1219d42580207c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e4db645c91162b8ce86c33436edd64"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1TraversalSelectorInfo.html">TraversalSelectorInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a28e4db645c91162b8ce86c33436edd64">getTraversalSelectorInfo</a> () const =0</td></tr>
<tr class="memdesc:a28e4db645c91162b8ce86c33436edd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a traversal selector info for this container.  <br /></td></tr>
<tr class="separator:a28e4db645c91162b8ce86c33436edd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0243c31f249174d3bec3dfadbceb4dc6"><td class="memItemLeft" align="right" valign="top">std::set&lt; TraversalOption &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a0243c31f249174d3bec3dfadbceb4dc6">getAllTraversals</a> (const InteractionTypeOption interactionType) const</td></tr>
<tr class="memdesc:a0243c31f249174d3bec3dfadbceb4dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a list of all traversals that are theoretically applicable to this container.  <br /></td></tr>
<tr class="separator:a0243c31f249174d3bec3dfadbceb4dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa909a2630ee1f75ad609d926ed3aef67"><td class="memItemLeft" align="right" valign="top">virtual std::tuple&lt; const Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa909a2630ee1f75ad609d926ed3aef67">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior) const =0</td></tr>
<tr class="memdesc:aa909a2630ee1f75ad609d926ed3aef67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.  <br /></td></tr>
<tr class="separator:aa909a2630ee1f75ad609d926ed3aef67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb63771d84be8bb8c0e670aea36bb228"><td class="memItemLeft" align="right" valign="top">virtual std::tuple&lt; const Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#adb63771d84be8bb8c0e670aea36bb228">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax) const =0</td></tr>
<tr class="memdesc:adb63771d84be8bb8c0e670aea36bb228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.    <br /></td></tr>
<tr class="separator:adb63771d84be8bb8c0e670aea36bb228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cda68ae216565832f6ed7de5254b046"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a0cda68ae216565832f6ed7de5254b046">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax)</td></tr>
<tr class="memdesc:a0cda68ae216565832f6ed7de5254b046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.      <br /></td></tr>
<tr class="separator:a0cda68ae216565832f6ed7de5254b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0ba632522a88de24c8da072d9ebe0c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a3e0ba632522a88de24c8da072d9ebe0c">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior)</td></tr>
<tr class="memdesc:a3e0ba632522a88de24c8da072d9ebe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.    <br /></td></tr>
<tr class="separator:a3e0ba632522a88de24c8da072d9ebe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d1f4d9292b1f7759cd0764afcddcc3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ad8d1f4d9292b1f7759cd0764afcddcc3">deleteParticle</a> (Particle_T &amp;particle)=0</td></tr>
<tr class="memdesc:ad8d1f4d9292b1f7759cd0764afcddcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the given particle as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:ad8d1f4d9292b1f7759cd0764afcddcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0d45825b7200f790e120b17c480d32"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4b0d45825b7200f790e120b17c480d32">deleteParticle</a> (size_t cellIndex, size_t particleIndex)=0</td></tr>
<tr class="memdesc:a4b0d45825b7200f790e120b17c480d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the particle at the given index positions as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:a4b0d45825b7200f790e120b17c480d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a963269f22e648091366b4bcd4280532c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a963269f22e648091366b4bcd4280532c">addParticleImpl</a> (const Particle_T &amp;p)=0</td></tr>
<tr class="memdesc:a963269f22e648091366b4bcd4280532c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container.  <br /></td></tr>
<tr class="separator:a963269f22e648091366b4bcd4280532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22a9cf2391cf726105e1a55c1cb03d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ae22a9cf2391cf726105e1a55c1cb03d6">addHaloParticleImpl</a> (const Particle_T &amp;haloParticle)=0</td></tr>
<tr class="memdesc:ae22a9cf2391cf726105e1a55c1cb03d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container that lies in the halo region of the container.  <br /></td></tr>
<tr class="separator:ae22a9cf2391cf726105e1a55c1cb03d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6a5e4ad2c387e347a8c9dfc49bbbb946"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a6a5e4ad2c387e347a8c9dfc49bbbb946">_stepsSinceLastRebuild</a> {0}</td></tr>
<tr class="memdesc:a6a5e4ad2c387e347a8c9dfc49bbbb946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the number of time-steps since last neighbor list rebuild.  <br /></td></tr>
<tr class="separator:a6a5e4ad2c387e347a8c9dfc49bbbb946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c20cff49ca6e0ca6c31ae32c2639b55"><td class="memItemLeft" align="right" valign="top"><a id="a9c20cff49ca6e0ca6c31ae32c2639b55" name="a9c20cff49ca6e0ca6c31ae32c2639b55"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_skin</b></td></tr>
<tr class="memdesc:a9c20cff49ca6e0ca6c31ae32c2639b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skin distance a particle is allowed to move in one time-step. <br /></td></tr>
<tr class="separator:a9c20cff49ca6e0ca6c31ae32c2639b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Particle_T&gt;<br />
class autopas::ParticleContainerInterface&lt; Particle_T &gt;</div><p>The <a class="el" href="classautopas_1_1ParticleContainerInterface.html" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas.">ParticleContainerInterface</a> class provides a basic interface for all Containers within <a class="el" href="classautopas_1_1AutoPas.html" title="The AutoPas class is intended to be the main point of Interaction for the user.">AutoPas</a>. </p>
<p>It defines method interfaces for addition and deletion of particles, accessing general container properties and creating iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle_T</td><td>Class for particle. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad9a908bc9d3768eae4611816b65265f5" name="ad9a908bc9d3768eae4611816b65265f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a908bc9d3768eae4611816b65265f5">&#9670;&#160;</a></span>ParticleContainerInterface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::ParticleContainerInterface </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>skin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skin</td><td>Skin distance a particle is allowed to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7de3c91ce2894734525cd7362ed0050" name="ae7de3c91ce2894734525cd7362ed0050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7de3c91ce2894734525cd7362ed0050">&#9670;&#160;</a></span>ParticleContainerInterface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::ParticleContainerInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a>&lt; Particle_T &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the copy constructor to prevent unwanted copies. </p>
<p>No particle container should ever be copied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a570ce9e1be3e46cd15135fa965a39bc7" name="a570ce9e1be3e46cd15135fa965a39bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570ce9e1be3e46cd15135fa965a39bc7">&#9670;&#160;</a></span>addHaloParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;bool checkInBox = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::addHaloParticle </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>haloParticle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a particle to the container that lies in the halo region of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haloParticle</td><td>Particle to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">checkInBox</td><td>Specifies whether a boundary check should be performed. Only disable this if the check has already been performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>do we want a check of the particle not being too far away in here as well? </dd></dl>

</div>
</div>
<a id="ae22a9cf2391cf726105e1a55c1cb03d6" name="ae22a9cf2391cf726105e1a55c1cb03d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22a9cf2391cf726105e1a55c1cb03d6">&#9670;&#160;</a></span>addHaloParticleImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::addHaloParticleImpl </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>haloParticle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a particle to the container that lies in the halo region of the container. </p>
<p>This is an unsafe version of <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab2c350201102d10da0e549435e9b1d99" title="Adds a particle to the container.">addParticle()</a> and does not perform a boundary check. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haloParticle</td><td>Particle to be added. This particle is already checked to be outside of the bounding box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only call this function if the position of the particle is guaranteed to be outside of the bounding box! </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1VerletClusterLists.html#a21e26dd1553a91908ba5db398a185162">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#af92378034166971d86bd4f43b29dfcc0">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#a21e26dd1553a91908ba5db398a185162">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="ab2c350201102d10da0e549435e9b1d99" name="ab2c350201102d10da0e549435e9b1d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c350201102d10da0e549435e9b1d99">&#9670;&#160;</a></span>addParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;bool checkInBox = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::addParticle </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a particle to the container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">checkInBox</td><td>Specifies whether a boundary check should be performed. Only disable this if the check has already been performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The particle to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a963269f22e648091366b4bcd4280532c" name="a963269f22e648091366b4bcd4280532c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963269f22e648091366b4bcd4280532c">&#9670;&#160;</a></span>addParticleImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::addParticleImpl </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a particle to the container. </p>
<p>This is an unsafe version of <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab2c350201102d10da0e549435e9b1d99" title="Adds a particle to the container.">addParticle()</a> and does not perform a boundary check. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The particle to be added. This particle is already checked to be inside of the bounding box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only call this function if the position of the particle is guaranteed to be inside of the bounding box! </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1VerletClusterLists.html#a3cd9d360440301e98bc16bc656a14f6c">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a11455d1e7ae1481c5156df4673e4d2a5">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#a3cd9d360440301e98bc16bc656a14f6c">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a65b0fdbbcb1d9dc20e44948e50519638" name="a65b0fdbbcb1d9dc20e44948e50519638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b0fdbbcb1d9dc20e44948e50519638">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>IteratorBehavior::ownedOrHalo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .   </p>
<dl class="section note"><dt>Note</dt><dd>The default argument for behavior is necessary to enable range based for loops. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first particle.   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1VerletClusterLists.html#a928ab9793a62685d2f5c69f300c56148">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a928ab9793a62685d2f5c69f300c56148">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a41fff9b096403519365ffa59173c34aa">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a8c44a77a74529bb916956269cc617a47" name="a8c44a77a74529bb916956269cc617a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c44a77a74529bb916956269cc617a47">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, false &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>IteratorBehavior::ownedOrHalo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, false &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) . </p>
<dl class="section note"><dt>Note</dt><dd>The default argument for behavior is necessary to enable range based for loops. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first particle. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1VerletClusterLists.html#a4687fe0b0a49562cb885d6e11153e93d">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a420417c2a1b196422288d9f70f2de3a2">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#a4687fe0b0a49562cb885d6e11153e93d">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a5a49dfbd5a55d9feb38f1297ac4c0262" name="a5a49dfbd5a55d9feb38f1297ac4c0262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a49dfbd5a55d9feb38f1297ac4c0262">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>IteratorBehavior::ownedOrHalo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .   </p>
<dl class="section note"><dt>Note</dt><dd>The default argument for behavior is necessary to enable range based for loops. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first particle.   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>cbegin will guarantee to return a const_iterator. </dd></dl>

</div>
</div>
<a id="ab383284c81486ed2eeaf8af598c4a4cb" name="ab383284c81486ed2eeaf8af598c4a4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab383284c81486ed2eeaf8af598c4a4cb">&#9670;&#160;</a></span>computeInteractions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::computeInteractions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates over all particle multiples (e.g. </p>
<p>pairs, triplets) in the container using the given traversal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traversal</td><td>The traversal to use for the iteration. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#a8fa6bf21c7ff2bf42f472e5da853d9be">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a9908f76829bb9d6dcfa31edbaa362b48">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a9908f76829bb9d6dcfa31edbaa362b48">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#abc7118392c39a608ace6c6ada94de5db">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#a2e9c6a2b892f3e63695d1f9b5acb3ab5">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a4c0551e9640a418836b1fead798929ec">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a4c0551e9640a418836b1fead798929ec">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1VarVerletLists.html#ac16211c73ef3e534cab9da14f4662212">autopas::VarVerletLists&lt; Particle_T, NeighborList &gt;</a>, <a class="el" href="classautopas_1_1VerletLists.html#a8c5efa98ede827e3ba2666c538132932">autopas::VerletLists&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsCells.html#ac50b5daeb29526c3e1a53bc1924463a7">autopas::VerletListsCells&lt; Particle_T, NeighborList &gt;</a>.</p>

</div>
</div>
<a id="a740fc3a18464478bffd53abadcf9071d" name="a740fc3a18464478bffd53abadcf9071d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740fc3a18464478bffd53abadcf9071d">&#9670;&#160;</a></span>deleteAllParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::deleteAllParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all particles. </p>

<p>Implemented in <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#aa62300e6423eb6851984f62aafef056b">autopas::CellBasedParticleContainer&lt; ParticleCell_T &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#aa62300e6423eb6851984f62aafef056b">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#aa62300e6423eb6851984f62aafef056b">autopas::CellBasedParticleContainer&lt; ReferenceParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#aa62300e6423eb6851984f62aafef056b">autopas::CellBasedParticleContainer&lt; OctreeNodeWrapper&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#aa62300e6423eb6851984f62aafef056b">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; ParticleCell::ParticleType &gt; &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#ad9fcb5f445ed83bda8c8f45d70033f5a">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a710dd760bec4a9d3c6637057f0138586">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a710dd760bec4a9d3c6637057f0138586">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a4a141094f03b5d65c271d3d8ef3ad516">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ab430b1916311400b6b4108a5596ff8b9" name="ab430b1916311400b6b4108a5596ff8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab430b1916311400b6b4108a5596ff8b9">&#9670;&#160;</a></span>deleteHaloParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::deleteHaloParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all halo particles. </p>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#a6b3c9058af9c2d19d1b92282c24a3582">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a326d6251f9bebde10c7af6b3965cd2d4">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a326d6251f9bebde10c7af6b3965cd2d4">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#aee7a37cbd0ac9c6dd4d4fd69a757fdff">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#a749963c343aeecbc1e950381e32d5673">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a0e4d116035dd5634d6ec79ce97beb3e7">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a0e4d116035dd5634d6ec79ce97beb3e7">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aedc31f20163c4af0a3336e51e58caa5e">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ad8d1f4d9292b1f7759cd0764afcddcc3" name="ad8d1f4d9292b1f7759cd0764afcddcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d1f4d9292b1f7759cd0764afcddcc3">&#9670;&#160;</a></span>deleteParticle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype">Particle_T &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the given particle as long as this does not compromise the validity of the container. </p>
<p>If this is not possible the particle is just marked as deleted. </p><dl class="section note"><dt>Note</dt><dd>This function might be implemented via swap-delete and is thus not completely thread safe. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td>Reference to the particle that is to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given pointer still points to a new particle. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1VerletClusterLists.html#ac7e2302e8879d46e8a7b753ce4e6b308">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a92984f356e0834768bff7349acea46d7">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#ac7e2302e8879d46e8a7b753ce4e6b308">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a4b0d45825b7200f790e120b17c480d32" name="a4b0d45825b7200f790e120b17c480d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0d45825b7200f790e120b17c480d32">&#9670;&#160;</a></span>deleteParticle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the particle at the given index positions as long as this does not compromise the validity of the container. </p>
<p>If this is not possible the particle is just marked as deleted. If the positions do not exist the behavior is undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td></td></tr>
    <tr><td class="paramname">particleIndex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given indices still point to a new particle. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#a0731b80f733e8785f55850980a4ba0bb">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a08624eb04710a63791c7057e5cb42ea7">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a08624eb04710a63791c7057e5cb42ea7">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#a401e044cb622201f84d4043ea6f1fc64">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#aedaa2a7d3a6a5764cb8160271bb4defe">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a55be4abe60627adcfd6b76407acbc23b">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a55be4abe60627adcfd6b76407acbc23b">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aee248cab15b26a33b9ae714bbd0a1674">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a3092c7f1c29e955d01faed348021ea6c" name="a3092c7f1c29e955d01faed348021ea6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3092c7f1c29e955d01faed348021ea6c">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy to make range-based for loops work.   </p>
<p>Range-Based for loops use the incremented <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a8c44a77a74529bb916956269cc617a47" title="Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .">begin()</a> expression and compare it against the <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a3092c7f1c29e955d01faed348021ea6c" title="Dummy to make range-based for loops work.">end()</a> expression. <a class="el" href="classautopas_1_1ContainerIterator.html" title="Public iterator class that iterates over a particle container and additional vectors (which are typic...">ContainerIterator</a> implements <a class="el" href="classautopas_1_1ContainerIterator.html#a9b7164f0fab9722cb3314b94781f7da9" title="Checks if the current iterator has a given validity.">ContainerIterator::operator==()</a> that accepts a bool as right hand side argument, which is triggered by this <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a3092c7f1c29e955d01faed348021ea6c" title="Dummy to make range-based for loops work.">end()</a> function. This operator then proceeds to check the validity of the iterator itself.</p>
<dl class="section return"><dt>Returns</dt><dd>false   </dd></dl>

</div>
</div>
<a id="a0243c31f249174d3bec3dfadbceb4dc6" name="a0243c31f249174d3bec3dfadbceb4dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0243c31f249174d3bec3dfadbceb4dc6">&#9670;&#160;</a></span>getAllTraversals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; TraversalOption &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getAllTraversals </td>
          <td>(</td>
          <td class="paramtype">const InteractionTypeOption&#160;</td>
          <td class="paramname"><em>interactionType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a list of all traversals that are theoretically applicable to this container. </p>
<p>Traversals might still be not applicable for other reasons so call traversal.isApplicable to be safe!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interactionType</td><td>interaction type for which to get all traversals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of traversal options. </dd></dl>

</div>
</div>
<a id="a1778749aee00722d67d0ac4067df602e" name="a1778749aee00722d67d0ac4067df602e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1778749aee00722d67d0ac4067df602e">&#9670;&#160;</a></span>getBoxMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getBoxMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the upper corner of the container without halo. </p>
<dl class="section return"><dt>Returns</dt><dd>Upper corner of the container. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a0ecacde31fe01789c7ffb0cf3cbd39c1">autopas::CellBasedParticleContainer&lt; ParticleCell_T &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a0ecacde31fe01789c7ffb0cf3cbd39c1">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a0ecacde31fe01789c7ffb0cf3cbd39c1">autopas::CellBasedParticleContainer&lt; ReferenceParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a0ecacde31fe01789c7ffb0cf3cbd39c1">autopas::CellBasedParticleContainer&lt; OctreeNodeWrapper&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a0ecacde31fe01789c7ffb0cf3cbd39c1">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; ParticleCell::ParticleType &gt; &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a934ca3e02ecc49362309596f40b22b5c">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#abf60bffec20e413de3c3664c6edb99b0">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#abf60bffec20e413de3c3664c6edb99b0">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a0f55afacd6446eeea5fc34e6468c56f4" name="a0f55afacd6446eeea5fc34e6468c56f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f55afacd6446eeea5fc34e6468c56f4">&#9670;&#160;</a></span>getBoxMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getBoxMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the lower corner of the container without halo. </p>
<dl class="section return"><dt>Returns</dt><dd>Lower corner of the container. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#ac6cf02ba9095f8fb3bc1c11f7a2eba0a">autopas::CellBasedParticleContainer&lt; ParticleCell_T &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#ac6cf02ba9095f8fb3bc1c11f7a2eba0a">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#ac6cf02ba9095f8fb3bc1c11f7a2eba0a">autopas::CellBasedParticleContainer&lt; ReferenceParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#ac6cf02ba9095f8fb3bc1c11f7a2eba0a">autopas::CellBasedParticleContainer&lt; OctreeNodeWrapper&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#ac6cf02ba9095f8fb3bc1c11f7a2eba0a">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; ParticleCell::ParticleType &gt; &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a56146a17f3339468dda6bd578cf17dd3">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a6ba534ae69f63023db3685bb22c865ba">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#a6ba534ae69f63023db3685bb22c865ba">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a941f6d9f49ee4a45f0ba0ea6bf64fd3c" name="a941f6d9f49ee4a45f0ba0ea6bf64fd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941f6d9f49ee4a45f0ba0ea6bf64fd3c">&#9670;&#160;</a></span>getContainerType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ContainerOption <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getContainerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ContainerType. </p>
<dl class="section return"><dt>Returns</dt><dd>ContainerOption of the type of this container. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#ac314a926deb8f346315ccb1d296f556d">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#ac3e5b45afb685c62a0d2b8629214bbd9">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#ac3e5b45afb685c62a0d2b8629214bbd9">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#a52396ab785af5f825d8b1a34f11c6ebb">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#aed0b0c72400a70eff740e22ac2d077c0">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a0b8ca65253cf663ec829c3a325ec6533">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a0b8ca65253cf663ec829c3a325ec6533">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1VarVerletLists.html#ad7e4edf10d3da7fcecc17d225c2561d3">autopas::VarVerletLists&lt; Particle_T, NeighborList &gt;</a>, <a class="el" href="classautopas_1_1VerletLists.html#a638d892386b38365f8f4d595b2ddfde9">autopas::VerletLists&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsCells.html#a6608658b04cac5667546b3bd63fde628">autopas::VerletListsCells&lt; Particle_T, NeighborList &gt;</a>.</p>

</div>
</div>
<a id="a15c65dd1a6a3e98f016d3373b835e3a3" name="a15c65dd1a6a3e98f016d3373b835e3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c65dd1a6a3e98f016d3373b835e3a3">&#9670;&#160;</a></span>getCutoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getCutoff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cutoff of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Cutoff radius. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a8ed5401f23d06cb3542c0a9ce4fc1459">autopas::CellBasedParticleContainer&lt; ParticleCell_T &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a8ed5401f23d06cb3542c0a9ce4fc1459">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a8ed5401f23d06cb3542c0a9ce4fc1459">autopas::CellBasedParticleContainer&lt; ReferenceParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a8ed5401f23d06cb3542c0a9ce4fc1459">autopas::CellBasedParticleContainer&lt; OctreeNodeWrapper&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a8ed5401f23d06cb3542c0a9ce4fc1459">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; ParticleCell::ParticleType &gt; &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#afb42a60779f2587821a50b9de83bc8c6">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#ab03e33e41f332c36388df75b4869484f">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#ab03e33e41f332c36388df75b4869484f">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a4a7e30b5867e028a31976bbcb57b8275" name="a4a7e30b5867e028a31976bbcb57b8275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7e30b5867e028a31976bbcb57b8275">&#9670;&#160;</a></span>getInteractionLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getInteractionLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the interaction length (cutoff+skin) of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>interaction length </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#addb3dc52380d9be43a64c23942cbf7b4">autopas::CellBasedParticleContainer&lt; ParticleCell_T &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#addb3dc52380d9be43a64c23942cbf7b4">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#addb3dc52380d9be43a64c23942cbf7b4">autopas::CellBasedParticleContainer&lt; ReferenceParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#addb3dc52380d9be43a64c23942cbf7b4">autopas::CellBasedParticleContainer&lt; OctreeNodeWrapper&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#addb3dc52380d9be43a64c23942cbf7b4">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; ParticleCell::ParticleType &gt; &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#acf4d1ae2a5ae96f88686b7868daa8583">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a4eef381162f18a6b4d1a81ce9798b22b">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#a4eef381162f18a6b4d1a81ce9798b22b">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a74cffaa132a5ef9d1f8fc72845bfc81f" name="a74cffaa132a5ef9d1f8fc72845bfc81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cffaa132a5ef9d1f8fc72845bfc81f">&#9670;&#160;</a></span>getNumberOfParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getNumberOfParticles </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>IteratorBehavior::owned</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of particles with respect to the specified IteratorBehavior. </p>
<dl class="section warning"><dt>Warning</dt><dd>: Since this function counts the number of the respective particles in the internal particle storage, this is in O(n) + lock is required. Only use it when it is absolutely necessary to have the exact number of different particle types like owned or halo. If it is enough to have the whole number of particles (owned + halo + dummy), the function <a class="el" href="classautopas_1_1ParticleContainerInterface.html#aef4c790d1bbf0d35988bea267a2e0f59" title="Get the total number of particles saved in the container (owned + halo + dummy).">size()</a> can be used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of particles with respect to the specified IteratorBehavior. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a208e64f272b06814b77a76caf8331f5e">autopas::CellBasedParticleContainer&lt; ParticleCell_T &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a208e64f272b06814b77a76caf8331f5e">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a208e64f272b06814b77a76caf8331f5e">autopas::CellBasedParticleContainer&lt; ReferenceParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a208e64f272b06814b77a76caf8331f5e">autopas::CellBasedParticleContainer&lt; OctreeNodeWrapper&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a208e64f272b06814b77a76caf8331f5e">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; ParticleCell::ParticleType &gt; &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#a3ef337ae90a6985906b05fc10261d779">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a8e60670574a50205009c5449e68853c7">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a8e60670574a50205009c5449e68853c7">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a74d3898b5f634391c4fd8b523ac556a9">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a3e0ba632522a88de24c8da072d9ebe0c" name="a3e0ba632522a88de24c8da072d9ebe0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0ba632522a88de24c8da072d9ebe0c">&#9670;&#160;</a></span>getParticle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; Particle_T *, size_t, size_t &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the pointer to a particle, identified via a cell and particle index.   </p>
<p>These indices are only meaningful in the context of the current container at its current state. The same indices might (and probably will) yield different particles for different container types or might not even exist. The only guarantee is that the indices {0,0} yield the first particle in the container that satisfies the iterator requirements.</p>
<dl class="section note"><dt>Note</dt><dd>This function should handle any offsets if used in a parallel iterator.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td>Index of the cell the particle is located in. </td></tr>
    <tr><td class="paramname">particleIndex</td><td>Particle index within the cell. </td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td>Which ownership states should be considered for the next particle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the particle and its indices. tuple&lt;Particle_T*, cellIndex, particleIndex&gt; If a index pair is given that does not exist but is also not beyond the last cell, the next fitting particle shall be returned. Example: If [4,2] does not exist, [5,1] shall be returned (or whatever is the next particle that fulfills the iterator requirements). If there is no next fitting particle {nullptr, 0, 0} is returned.  </dd></dl>
<dl class="section note"><dt>Note</dt><dd>non-const non-region iter version </dd></dl>

</div>
</div>
<a id="aa909a2630ee1f75ad609d926ed3aef67" name="aa909a2630ee1f75ad609d926ed3aef67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa909a2630ee1f75ad609d926ed3aef67">&#9670;&#160;</a></span>getParticle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::tuple&lt; const Particle_T *, size_t, size_t &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the pointer to a particle, identified via a cell and particle index. </p>
<p>These indices are only meaningful in the context of the current container at its current state. The same indices might (and probably will) yield different particles for different container types or might not even exist. The only guarantee is that the indices {0,0} yield the first particle in the container that satisfies the iterator requirements.</p>
<dl class="section note"><dt>Note</dt><dd>This function should handle any offsets if used in a parallel iterator.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td>Index of the cell the particle is located in. </td></tr>
    <tr><td class="paramname">particleIndex</td><td>Particle index within the cell. </td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td>Which ownership states should be considered for the next particle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the particle and its indices. tuple&lt;Particle_T*, cellIndex, particleIndex&gt; If a index pair is given that does not exist but is also not beyond the last cell, the next fitting particle shall be returned. Example: If [4,2] does not exist, [5,1] shall be returned (or whatever is the next particle that fulfills the iterator requirements). If there is no next fitting particle {nullptr, 0, 0} is returned. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#a112eb0034f4989a68ddea62cb0b912d5">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#ad1715a89eb0eb66f66babb388717eb91">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#ad1715a89eb0eb66f66babb388717eb91">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#a479c50f3fe5c8f73b0094e1ac45a9cea">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#ac611132b587e7e15b5231b62b50638f0">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#acd5a542e502181622466f10b97152a5e">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#acd5a542e502181622466f10b97152a5e">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aa52ca7f7f8b33f321b2beb86aa1a314f">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a0cda68ae216565832f6ed7de5254b046" name="a0cda68ae216565832f6ed7de5254b046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cda68ae216565832f6ed7de5254b046">&#9670;&#160;</a></span>getParticle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; Particle_T *, size_t, size_t &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the pointer to a particle, identified via a cell and particle index.     </p>
<p>These indices are only meaningful in the context of the current container at its current state. The same indices might (and probably will) yield different particles for different container types or might not even exist. The only guarantee is that the indices {0,0} yield the first particle in the container that satisfies the iterator requirements.</p>
<dl class="section note"><dt>Note</dt><dd>This function should handle any offsets if used in a parallel iterator.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td>Index of the cell the particle is located in. </td></tr>
    <tr><td class="paramname">particleIndex</td><td>Particle index within the cell. </td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td>Which ownership states should be considered for the next particle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the particle and its indices. tuple&lt;Particle_T*, cellIndex, particleIndex&gt; If a index pair is given that does not exist but is also not beyond the last cell, the next fitting particle shall be returned. Example: If [4,2] does not exist, [5,1] shall be returned (or whatever is the next particle that fulfills the iterator requirements). If there is no next fitting particle {nullptr, 0, 0} is returned.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>start of region in which the next particle should be. The coordinates are expected to be within the domain. </td></tr>
    <tr><td class="paramname">boxMax</td><td>end of region in which the next particle should be. The coordinates are expected to be within the domain.  </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>non-const region iter version </dd></dl>

</div>
</div>
<a id="adb63771d84be8bb8c0e670aea36bb228" name="adb63771d84be8bb8c0e670aea36bb228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb63771d84be8bb8c0e670aea36bb228">&#9670;&#160;</a></span>getParticle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::tuple&lt; const Particle_T *, size_t, size_t &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the pointer to a particle, identified via a cell and particle index.   </p>
<p>These indices are only meaningful in the context of the current container at its current state. The same indices might (and probably will) yield different particles for different container types or might not even exist. The only guarantee is that the indices {0,0} yield the first particle in the container that satisfies the iterator requirements.</p>
<dl class="section note"><dt>Note</dt><dd>This function should handle any offsets if used in a parallel iterator.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td>Index of the cell the particle is located in. </td></tr>
    <tr><td class="paramname">particleIndex</td><td>Particle index within the cell. </td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td>Which ownership states should be considered for the next particle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the particle and its indices. tuple&lt;Particle_T*, cellIndex, particleIndex&gt; If a index pair is given that does not exist but is also not beyond the last cell, the next fitting particle shall be returned. Example: If [4,2] does not exist, [5,1] shall be returned (or whatever is the next particle that fulfills the iterator requirements). If there is no next fitting particle {nullptr, 0, 0} is returned.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>start of region in which the next particle should be. The coordinates are expected to be within the domain. </td></tr>
    <tr><td class="paramname">boxMax</td><td>end of region in which the next particle should be. The coordinates are expected to be within the domain. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#a8d72e4d864a65a85cc78dbbcfe31c727">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#abf2abc54814c70764691d1eec62e8c60">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#abf2abc54814c70764691d1eec62e8c60">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#a2bd508e6d2f10d780a01e89234c4ad9c">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#a57973e93cdc0c89931680ae834191009">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a592814d931dd8840752a73ee5ba66371">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a592814d931dd8840752a73ee5ba66371">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a577e3ded3cb81632145482c25a348f27">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a2c9a78a6d0e561463260b10e7ba61f9f" name="a2c9a78a6d0e561463260b10e7ba61f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9a78a6d0e561463260b10e7ba61f9f">&#9670;&#160;</a></span>getRegionIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, true &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getRegionIterator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, true &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of the region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of the region </td></tr>
    <tr><td class="paramname">behavior</td><td>The behavior of the iterator (shall it iterate over halo particles as well?). </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to iterate over all particles in a specific region.   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1VerletClusterLists.html#a4ab0bf0fc27fa0c1ff519fb06d0601bf">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#adc54cd5f59d7f777070e10209201f9b4">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#a4ab0bf0fc27fa0c1ff519fb06d0601bf">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a5a11f12455c67ec3c000fb09d5de8a7b" name="a5a11f12455c67ec3c000fb09d5de8a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a11f12455c67ec3c000fb09d5de8a7b">&#9670;&#160;</a></span>getRegionIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, true &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getRegionIterator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, true &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of the region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of the region </td></tr>
    <tr><td class="paramname">behavior</td><td>The behavior of the iterator (shall it iterate over halo particles as well?). </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to iterate over all particles in a specific region. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1VerletClusterLists.html#a79d43f1c9db593fc7574488dc9c43e24">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#ab64f597ee744514f6557d431e155569e">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#a79d43f1c9db593fc7574488dc9c43e24">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="ade006f01a9966aeaee7ff6aff677a995" name="ade006f01a9966aeaee7ff6aff677a995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade006f01a9966aeaee7ff6aff677a995">&#9670;&#160;</a></span>getStepsSinceLastRebuild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getStepsSinceLastRebuild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of time-steps since last neighbor list rebuild. </p>
<dl class="section note"><dt>Note</dt><dd>: The value has to be set by <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a94447de936c48623cb7f5e71972dd5cb" title="Set the number of time-steps since last neighbor list rebuild.">setStepsSinceLastRebuild()</a> from outside the container. Otherwise this will always return 0 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>steps since last rebuild </dd></dl>

</div>
</div>
<a id="a28e4db645c91162b8ce86c33436edd64" name="a28e4db645c91162b8ce86c33436edd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e4db645c91162b8ce86c33436edd64">&#9670;&#160;</a></span>getTraversalSelectorInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classautopas_1_1TraversalSelectorInfo.html">TraversalSelectorInfo</a> <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getTraversalSelectorInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a traversal selector info for this container. </p>
<dl class="section return"><dt>Returns</dt><dd>Traversal selector info for this container. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#a265c24fb152f0cd526c7c3aa2386173e">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a96063aadffca747edbbebbc95fa5499b">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a96063aadffca747edbbebbc95fa5499b">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#a68b1b52954b5173f98e22dd4863e5148">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#a992430e244f20018f09e6d2e85cb9f41">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a03a07f55ac5c5bf673bd6728b88c9790">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a03a07f55ac5c5bf673bd6728b88c9790">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#ae591a76b308677cffc4210c4dac00f54">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a31ff749bcd4540af8bbdda48064dd6c4" name="a31ff749bcd4540af8bbdda48064dd6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ff749bcd4540af8bbdda48064dd6c4">&#9670;&#160;</a></span>getVerletSkin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::getVerletSkin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the verletSkin of the container verletSkin. </p>
<dl class="section return"><dt>Returns</dt><dd>verletSkin </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a774bd2e2693268f7ee357017ec3e58cd">autopas::CellBasedParticleContainer&lt; ParticleCell_T &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a774bd2e2693268f7ee357017ec3e58cd">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a774bd2e2693268f7ee357017ec3e58cd">autopas::CellBasedParticleContainer&lt; ReferenceParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a774bd2e2693268f7ee357017ec3e58cd">autopas::CellBasedParticleContainer&lt; OctreeNodeWrapper&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a774bd2e2693268f7ee357017ec3e58cd">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; ParticleCell::ParticleType &gt; &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a774e3185f365061ffd949d2af72a2739">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a55ca85fd5f3e76ae2b8f43338009b161">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#a55ca85fd5f3e76ae2b8f43338009b161">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a116a79a89fac9059da41e2ada2257a3c" name="a116a79a89fac9059da41e2ada2257a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116a79a89fac9059da41e2ada2257a3c">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a>&lt; Particle_T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the copy assignment operator to prevent unwanted copies. </p>
<p>No particle container should ever be copied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a08a3ffb69099a0917c456e0b844c222b" name="a08a3ffb69099a0917c456e0b844c222b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a3ffb69099a0917c456e0b844c222b">&#9670;&#160;</a></span>rebuildNeighborLists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::rebuildNeighborLists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rebuilds the neighbor lists for the next traversals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traversal</td><td>The used traversal. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#a466ebcfe237136c29efe21b67d7b55eb">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a9aa3e6217951624ee8ab61491a67f720">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a9aa3e6217951624ee8ab61491a67f720">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#a94b6d4882700c2fc6789fdd2be4f3c98">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#a2833f3207b5e1089e68ea5615dd55e24">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a13b296147b999c8d031cd250092dd146">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a13b296147b999c8d031cd250092dd146">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1VarVerletLists.html#a2dfb7dc9da2ff81730fec6607b106523">autopas::VarVerletLists&lt; Particle_T, NeighborList &gt;</a>, <a class="el" href="classautopas_1_1VerletLists.html#a7a94ffed94309e104a9219a278b89f54">autopas::VerletLists&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsCells.html#a0e0a38c9aeff1823e9be6b767de1c8b5">autopas::VerletListsCells&lt; Particle_T, NeighborList &gt;</a>.</p>

</div>
</div>
<a id="a81d65a563cfbdb1828379458db0dfadf" name="a81d65a563cfbdb1828379458db0dfadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d65a563cfbdb1828379458db0dfadf">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numParticlesHaloEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve memory for a given number of particles in the container and logic layers.   </p>
<p>This function assumes a uniform distribution of particles throughout the domain. For example, this means that in a <a class="el" href="classautopas_1_1LinkedCells.html" title="LinkedCells class.">LinkedCells</a> Container in each cell vector.reserve(numParticles/numCells) is called. </p><dl class="section note"><dt>Note</dt><dd>This functions will create an estimate for the number of halo particles. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numParticles</td><td>No buffer factor is applied. It is probably wise to slightly over-reserve to account for imbalance or particle movement.   </td></tr>
    <tr><td class="paramname">numParticlesHaloEstimate</td><td>Estimate for the number of halo particles. Reserves space in the container data structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#a8ca5fb17d964fed743aeeca6627d1b0a">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a99e86dbaf4a085314cfaa86e1b4b3f0a">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a99e86dbaf4a085314cfaa86e1b4b3f0a">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#a0a3a743cfb8233d23889763408fc6142">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#a22ddfc10ab5c3380f3d794b4991bd49f">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#ac4201c77ac45d2e40d46c16771a8811b">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#ac4201c77ac45d2e40d46c16771a8811b">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a23e51b15eb241ff31812f23a25a897c8">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a6271bbef734203f7d902f61a1e7c9cc3" name="a6271bbef734203f7d902f61a1e7c9cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6271bbef734203f7d902f61a1e7c9cc3">&#9670;&#160;</a></span>setCutoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::setCutoff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cutoff of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cutoff</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a175d76273f8ff402ddcce10e86ed63d6">autopas::CellBasedParticleContainer&lt; ParticleCell_T &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a175d76273f8ff402ddcce10e86ed63d6">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a175d76273f8ff402ddcce10e86ed63d6">autopas::CellBasedParticleContainer&lt; ReferenceParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a175d76273f8ff402ddcce10e86ed63d6">autopas::CellBasedParticleContainer&lt; OctreeNodeWrapper&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a175d76273f8ff402ddcce10e86ed63d6">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; ParticleCell::ParticleType &gt; &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a908f25f81431b27a0db7c35a89145c65">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#ac49e3cb804152f399684d6f646422e5d">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#ac49e3cb804152f399684d6f646422e5d">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<a id="a94447de936c48623cb7f5e71972dd5cb" name="a94447de936c48623cb7f5e71972dd5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94447de936c48623cb7f5e71972dd5cb">&#9670;&#160;</a></span>setStepsSinceLastRebuild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::setStepsSinceLastRebuild </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stepsSinceLastRebuild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of time-steps since last neighbor list rebuild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stepsSinceLastRebuild</td><td>steps since last neighbor list rebuild </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a438c1ea993ac393d3702d719ff9e5a57">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="aef4c790d1bbf0d35988bea267a2e0f59" name="aef4c790d1bbf0d35988bea267a2e0f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4c790d1bbf0d35988bea267a2e0f59">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of particles saved in the container (owned + halo + dummy). </p>
<dl class="section return"><dt>Returns</dt><dd>Number of particles saved in the container (owned + halo + dummy). </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a55756e9c49c11846864222045485591e">autopas::CellBasedParticleContainer&lt; ParticleCell_T &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a55756e9c49c11846864222045485591e">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a55756e9c49c11846864222045485591e">autopas::CellBasedParticleContainer&lt; ReferenceParticleCell&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a55756e9c49c11846864222045485591e">autopas::CellBasedParticleContainer&lt; OctreeNodeWrapper&lt; Particle_T &gt; &gt;</a>, <a class="el" href="classautopas_1_1CellBasedParticleContainer.html#a55756e9c49c11846864222045485591e">autopas::CellBasedParticleContainer&lt; FullParticleCell&lt; ParticleCell::ParticleType &gt; &gt;</a>, <a class="el" href="classautopas_1_1Octree.html#a588829fc6e0c919bc1b760e8682572d7">autopas::Octree&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a12d73f49278986ce321c6129d3fa42ba">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#a12d73f49278986ce321c6129d3fa42ba">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, and <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aff1c2b716ee825291cdac79e4392f08e">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a4ecc728dcc3e19d6a1219d42580207c4" name="a4ecc728dcc3e19d6a1219d42580207c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecc728dcc3e19d6a1219d42580207c4">&#9670;&#160;</a></span>updateContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; Particle_T &gt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::updateContainer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepNeighborListsValid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the container. </p>
<p>This deletes halo particles, resorts particles into appropriate cells and might remove particles from the container, if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepNeighborListsValid</td><td>Defines whether the neighbor lists have to be kept valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of invalid particles that do not belong into the container. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1DirectSum.html#a9514b73e0424c0116929b5c7bbe87a87">autopas::DirectSum&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a54882c22d8cebcadd3f8ccc22a2a2901">autopas::LinkedCells&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1LinkedCells.html#a54882c22d8cebcadd3f8ccc22a2a2901">autopas::LinkedCells&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1LinkedCellsReferences.html#ad87470155ec6041a69f67ac7f1535e91">autopas::LinkedCellsReferences&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#ad945c9ca2db55d25971660300ab7c587">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletClusterLists.html#ad945c9ca2db55d25971660300ab7c587">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a95f4a2bd710e07a891dbc6342b8fcd58">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1Octree.html#a97a635f1c83848bb832ae493b7515936">autopas::Octree&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a7b43eec590054db74704b88d2d896937" name="a7b43eec590054db74704b88d2d896937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b43eec590054db74704b88d2d896937">&#9670;&#160;</a></span>updateHaloParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::updateHaloParticle </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>haloParticle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a halo particle of the container with the given haloParticle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haloParticle</td><td>Particle to be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the particle was updated, false if no particle could be found. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1VerletClusterLists.html#af74f36b67332c31ce87e9b3776858445">autopas::VerletClusterLists&lt; Particle_T &gt;</a>, <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a0353c0f0a44f84cc1cffffd507bbcb14">autopas::VerletListsLinkedBase&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1VerletClusterLists.html#af74f36b67332c31ce87e9b3776858445">autopas::VerletClusterLists&lt; ParticleCell::ParticleType &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6a5e4ad2c387e347a8c9dfc49bbbb946" name="a6a5e4ad2c387e347a8c9dfc49bbbb946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5e4ad2c387e347a8c9dfc49bbbb946">&#9670;&#160;</a></span>_stepsSinceLastRebuild</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; Particle_T &gt;::_stepsSinceLastRebuild {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the number of time-steps since last neighbor list rebuild. </p>
<dl class="section note"><dt>Note</dt><dd>: The value has to be set by <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a94447de936c48623cb7f5e71972dd5cb" title="Set the number of time-steps since last neighbor list rebuild.">setStepsSinceLastRebuild()</a> from outside the container. Otherwise this will always be 0 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autopas/containers/<a class="el" href="ParticleContainerInterface_8h_source.html">ParticleContainerInterface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classautopas_1_1OctreeLeafNode-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::OctreeLeafNode&lt; Particle_T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An octree leaf node.  
 <a href="classautopas_1_1OctreeLeafNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OctreeLeafNode_8h_source.html">OctreeLeafNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::OctreeLeafNode&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1OctreeLeafNode__inherit__graph.png" border="0" usemap="#aautopas_1_1OctreeLeafNode_3_01Particle__T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1OctreeLeafNode_3_01Particle__T_01_4_inherit__map" id="aautopas_1_1OctreeLeafNode_3_01Particle__T_01_4_inherit__map">
<area shape="rect" title="An octree leaf node." alt="" coords="473,37,660,77"/>
<area shape="rect" href="classautopas_1_1OctreeNodeInterface.html" title="The base class that provides the necessary function definitions that can be applied to an octree." alt="" coords="208,5,425,45"/>
<area shape="poly" title=" " alt="" coords="439,38,473,43,473,48,439,44"/>
<area shape="rect" href="classautopas_1_1FullParticleCell.html" title="This class handles the storage of particles in their full form." alt="" coords="227,69,406,109"/>
<area shape="poly" title=" " alt="" coords="419,74,473,67,473,72,420,79"/>
<area shape="rect" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles." alt="" coords="5,69,160,109"/>
<area shape="poly" title=" " alt="" coords="174,87,227,87,227,92,174,92"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for autopas::OctreeLeafNode&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1OctreeLeafNode__coll__graph.png" border="0" usemap="#aautopas_1_1OctreeLeafNode_3_01Particle__T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aautopas_1_1OctreeLeafNode_3_01Particle__T_01_4_coll__map" id="aautopas_1_1OctreeLeafNode_3_01Particle__T_01_4_coll__map">
<area shape="rect" title="An octree leaf node." alt="" coords="753,37,940,77"/>
<area shape="rect" href="classautopas_1_1OctreeNodeInterface.html" title="The base class that provides the necessary function definitions that can be applied to an octree." alt="" coords="487,5,704,45"/>
<area shape="poly" title=" " alt="" coords="718,38,753,43,753,48,717,44"/>
<area shape="rect" href="classautopas_1_1FullParticleCell.html" title="This class handles the storage of particles in their full form." alt="" coords="506,69,685,109"/>
<area shape="poly" title=" " alt="" coords="698,74,753,67,754,72,699,79"/>
<area shape="rect" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles." alt="" coords="283,69,437,109"/>
<area shape="poly" title=" " alt="" coords="451,87,506,87,506,92,451,92"/>
<area shape="rect" href="classautopas_1_1AutoPasLock.html" title="AutoPasLock for the sequential case." alt="" coords="5,77,169,102"/>
<area shape="poly" title=" " alt="" coords="183,87,282,87,282,92,183,92"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab78b41368b1fbaa8ba973b29cdd86381"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#ab78b41368b1fbaa8ba973b29cdd86381">OctreeLeafNode</a> (const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax, <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *parent, const int unsigned treeSplitThreshold, const double interactionLength, const double cellSizeFactor)</td></tr>
<tr class="memdesc:ab78b41368b1fbaa8ba973b29cdd86381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty octree leaf node.  <br /></td></tr>
<tr class="separator:ab78b41368b1fbaa8ba973b29cdd86381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0006420f08dd436b30b05af42a6f0371"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a0006420f08dd436b30b05af42a6f0371">OctreeLeafNode</a> (<a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; const &amp;other)</td></tr>
<tr class="memdesc:a0006420f08dd436b30b05af42a6f0371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a leaf by copying all particles from the other leaf to this leaf.  <br /></td></tr>
<tr class="separator:a0006420f08dd436b30b05af42a6f0371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1a1067a22964be7bf9710a8498b14f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a7e1a1067a22964be7bf9710a8498b14f">insert</a> (const Particle_T &amp;p) override</td></tr>
<tr class="memdesc:a7e1a1067a22964be7bf9710a8498b14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a particle into the octree.    <br /></td></tr>
<tr class="separator:a7e1a1067a22964be7bf9710a8498b14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250826c09fbb03f4137faad70f0bb130"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a250826c09fbb03f4137faad70f0bb130">deleteParticle</a> (Particle_T &amp;particle) override</td></tr>
<tr class="memdesc:a250826c09fbb03f4137faad70f0bb130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given particle from the data structure.    <br /></td></tr>
<tr class="separator:a250826c09fbb03f4137faad70f0bb130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e5cb3d11dacf950d8680cc4901ae6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a12e5cb3d11dacf950d8680cc4901ae6f">collectAllParticles</a> (std::vector&lt; Particle_T * &gt; &amp;ps) const override</td></tr>
<tr class="memdesc:a12e5cb3d11dacf950d8680cc4901ae6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all particles that are below this node into the vector.    <br /></td></tr>
<tr class="separator:a12e5cb3d11dacf950d8680cc4901ae6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b378fdfd9d69219620e1015ba2d09e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a37b378fdfd9d69219620e1015ba2d09e">appendAllLeafBoxes</a> (std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, std::array&lt; double, 3 &gt; &gt; &gt; &amp;boxes) const override</td></tr>
<tr class="memdesc:a37b378fdfd9d69219620e1015ba2d09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the min/max corner coordinates of every leaf into the vector.    <br /></td></tr>
<tr class="separator:a37b378fdfd9d69219620e1015ba2d09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907d0336f707f4a26faccf7ecdf80cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a907d0336f707f4a26faccf7ecdf80cea">clearChildren</a> (std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; &amp;ref) override</td></tr>
<tr class="memdesc:a907d0336f707f4a26faccf7ecdf80cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the entire tree below this node.    <br /></td></tr>
<tr class="separator:a907d0336f707f4a26faccf7ecdf80cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd487f39aaf1747d75a4366dbd931b3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#aadd487f39aaf1747d75a4366dbd931b3">size</a> () const override</td></tr>
<tr class="memdesc:aadd487f39aaf1747d75a4366dbd931b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of particles saved in the container (owned + halo + dummy).      <br /></td></tr>
<tr class="separator:aadd487f39aaf1747d75a4366dbd931b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0809fb178527cb2b55ce01a58b530c3c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a0809fb178527cb2b55ce01a58b530c3c">getNumberOfParticles</a> (IteratorBehavior behavior) const override</td></tr>
<tr class="memdesc:a0809fb178527cb2b55ce01a58b530c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.        <br /></td></tr>
<tr class="separator:a0809fb178527cb2b55ce01a58b530c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae0bac3a0c10b9986be818a06e9fc80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#acae0bac3a0c10b9986be818a06e9fc80">hasChildren</a> () override</td></tr>
<tr class="memdesc:acae0bac3a0c10b9986be818a06e9fc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node is a leaf or an inner node.    <br /></td></tr>
<tr class="separator:acae0bac3a0c10b9986be818a06e9fc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6be9392373429add9ea47a43e09e739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#ad6be9392373429add9ea47a43e09e739">getChild</a> (int index) override</td></tr>
<tr class="memdesc:ad6be9392373429add9ea47a43e09e739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child by its index from the node.    <br /></td></tr>
<tr class="separator:ad6be9392373429add9ea47a43e09e739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8b6459d0bfa515afb599900092e516"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a8e8b6459d0bfa515afb599900092e516">getLeavesFromDirections</a> (const std::vector&lt; <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> &gt; &amp;directions) override</td></tr>
<tr class="memdesc:a8e8b6459d0bfa515afb599900092e516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaf nodes along a list of given directions.  <br /></td></tr>
<tr class="separator:a8e8b6459d0bfa515afb599900092e516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bab1e9bf95d8ff66cbcf4cef4d0c451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a6bab1e9bf95d8ff66cbcf4cef4d0c451">SON</a> (<a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Octant</a> O) override</td></tr>
<tr class="memdesc:a6bab1e9bf95d8ff66cbcf4cef4d0c451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child node of this node (if there are children) given a specific octant using the spacial structure of the stored children.  <br /></td></tr>
<tr class="separator:a6bab1e9bf95d8ff66cbcf4cef4d0c451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3f6b89d2601604466f72a4da9c4907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a6b3f6b89d2601604466f72a4da9c4907">appendAllLeaves</a> (std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;leaves) const override</td></tr>
<tr class="memdesc:a6b3f6b89d2601604466f72a4da9c4907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all leaves below this subtree into a given list.  <br /></td></tr>
<tr class="separator:a6b3f6b89d2601604466f72a4da9c4907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a662b71d40e7c3897e588a3ea193450"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a8a662b71d40e7c3897e588a3ea193450">getLeavesInRange</a> (const std::array&lt; double, 3 &gt; &amp;min, const std::array&lt; double, 3 &gt; &amp;max) override</td></tr>
<tr class="memdesc:a8a662b71d40e7c3897e588a3ea193450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaves below this subtree that are in the given range.  <br /></td></tr>
<tr class="separator:a8a662b71d40e7c3897e588a3ea193450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29511c995905a4f4afaa7f284355e6b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a29511c995905a4f4afaa7f284355e6b8">getID</a> ()</td></tr>
<tr class="memdesc:a29511c995905a4f4afaa7f284355e6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the assigned id of this leaf node.  <br /></td></tr>
<tr class="separator:a29511c995905a4f4afaa7f284355e6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07565041ea14af21a7bff8db6c1cc7bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeLeafNode.html#a07565041ea14af21a7bff8db6c1cc7bd">setID</a> (int id)</td></tr>
<tr class="memdesc:a07565041ea14af21a7bff8db6c1cc7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the ID of this node.  <br /></td></tr>
<tr class="separator:a07565041ea14af21a7bff8db6c1cc7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1OctreeNodeInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1OctreeNodeInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:ad416befeb8d31565ea5bfdeef66fa104 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad416befeb8d31565ea5bfdeef66fa104">OctreeNodeInterface</a> (const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax, <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *parent, const int unsigned treeSplitThreshold, const double interactionLength, const double cellSizeFactor)</td></tr>
<tr class="memdesc:ad416befeb8d31565ea5bfdeef66fa104 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an octree node interface by initializing the given fields.  <br /></td></tr>
<tr class="separator:ad416befeb8d31565ea5bfdeef66fa104 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d4bc0efaad30b855b2ab43672d843b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a66d4bc0efaad30b855b2ab43672d843b" name="a66d4bc0efaad30b855b2ab43672d843b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~OctreeNodeInterface</b> ()=default</td></tr>
<tr class="memdesc:a66d4bc0efaad30b855b2ab43672d843b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">To make clang happy. <br /></td></tr>
<tr class="separator:a66d4bc0efaad30b855b2ab43672d843b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24265c31be2340ab1f62a0a653be0f88 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a24265c31be2340ab1f62a0a653be0f88" name="a24265c31be2340ab1f62a0a653be0f88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OctreeNodeInterface</b> (const <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &amp;)=default</td></tr>
<tr class="memdesc:a24265c31be2340ab1f62a0a653be0f88 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor. <br /></td></tr>
<tr class="separator:a24265c31be2340ab1f62a0a653be0f88 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d236108b1d67a05e03eb0ca49a7422 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab5d236108b1d67a05e03eb0ca49a7422">insert</a> (const Particle_T &amp;p)=0</td></tr>
<tr class="memdesc:ab5d236108b1d67a05e03eb0ca49a7422 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a particle into the octree.  <br /></td></tr>
<tr class="separator:ab5d236108b1d67a05e03eb0ca49a7422 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25687dec42fc04d53c8ad6416290eb6 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad25687dec42fc04d53c8ad6416290eb6">deleteParticle</a> (Particle_T &amp;particle)=0</td></tr>
<tr class="memdesc:ad25687dec42fc04d53c8ad6416290eb6 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given particle from the data structure.    <br /></td></tr>
<tr class="separator:ad25687dec42fc04d53c8ad6416290eb6 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ead81def7160fc03a73c447bf7e53 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a6c6ead81def7160fc03a73c447bf7e53">collectAllParticles</a> (std::vector&lt; Particle_T * &gt; &amp;ps) const =0</td></tr>
<tr class="memdesc:a6c6ead81def7160fc03a73c447bf7e53 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all particles that are below this node into the vector.  <br /></td></tr>
<tr class="separator:a6c6ead81def7160fc03a73c447bf7e53 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb6398c228be2a285ce1f86c02a8d25 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7fb6398c228be2a285ce1f86c02a8d25">appendAllLeafBoxes</a> (std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, std::array&lt; double, 3 &gt; &gt; &gt; &amp;boxes) const =0</td></tr>
<tr class="memdesc:a7fb6398c228be2a285ce1f86c02a8d25 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the min/max corner coordinates of every leaf into the vector.  <br /></td></tr>
<tr class="separator:a7fb6398c228be2a285ce1f86c02a8d25 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a10fa85f01ff57a9a06c57de607d59b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a2a10fa85f01ff57a9a06c57de607d59b">appendAllLeaves</a> (std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;leaves) const =0</td></tr>
<tr class="memdesc:a2a10fa85f01ff57a9a06c57de607d59b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all leaves below this subtree into a given list.  <br /></td></tr>
<tr class="separator:a2a10fa85f01ff57a9a06c57de607d59b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ab6f178fce0a5742d1881021dac4e3 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab2ab6f178fce0a5742d1881021dac4e3">clearChildren</a> (std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; &amp;ref)=0</td></tr>
<tr class="memdesc:ab2ab6f178fce0a5742d1881021dac4e3 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the entire tree below this node.  <br /></td></tr>
<tr class="separator:ab2ab6f178fce0a5742d1881021dac4e3 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6e61aed5fb70cbd069e8f172dc9291 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7e6e61aed5fb70cbd069e8f172dc9291">size</a> () const =0</td></tr>
<tr class="memdesc:a7e6e61aed5fb70cbd069e8f172dc9291 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of particles saved in the container (owned + halo + dummy).    <br /></td></tr>
<tr class="separator:a7e6e61aed5fb70cbd069e8f172dc9291 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31651019cd7e284b620411f1e023a3b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ac31651019cd7e284b620411f1e023a3b">getNumberOfParticles</a> (IteratorBehavior behavior=IteratorBehavior::owned) const =0</td></tr>
<tr class="memdesc:ac31651019cd7e284b620411f1e023a3b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.      <br /></td></tr>
<tr class="separator:ac31651019cd7e284b620411f1e023a3b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df399ebdc0b38620a35af63bcf13271 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a4df399ebdc0b38620a35af63bcf13271">SON</a> (<a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Octant</a> O)=0</td></tr>
<tr class="memdesc:a4df399ebdc0b38620a35af63bcf13271 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child node of this node (if there are children) given a specific octant using the spacial structure of the stored children.  <br /></td></tr>
<tr class="separator:a4df399ebdc0b38620a35af63bcf13271 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a1188bc4e80325b23040b921e2aaf inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#add2a1188bc4e80325b23040b921e2aaf">hasChildren</a> ()=0</td></tr>
<tr class="memdesc:add2a1188bc4e80325b23040b921e2aaf inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node is a leaf or an inner node.  <br /></td></tr>
<tr class="separator:add2a1188bc4e80325b23040b921e2aaf inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a83ac4270e177bc03215e0378064aa inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a42a83ac4270e177bc03215e0378064aa">getChild</a> (int index)=0</td></tr>
<tr class="memdesc:a42a83ac4270e177bc03215e0378064aa inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child by its index from the node.  <br /></td></tr>
<tr class="separator:a42a83ac4270e177bc03215e0378064aa inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120821d0ce7268603cafb9f720526b85 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a120821d0ce7268603cafb9f720526b85">getLeavesInRange</a> (const std::array&lt; double, 3 &gt; &amp;min, const std::array&lt; double, 3 &gt; &amp;max)=0</td></tr>
<tr class="memdesc:a120821d0ce7268603cafb9f720526b85 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaves below this subtree that are in the given range.  <br /></td></tr>
<tr class="separator:a120821d0ce7268603cafb9f720526b85 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49a028da76d8b6d201593c618414563 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ae49a028da76d8b6d201593c618414563">isInside</a> (const std::array&lt; double, 3 &gt; &amp;point)</td></tr>
<tr class="memdesc:ae49a028da76d8b6d201593c618414563 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a 3d point is inside the node's axis aligned bounding box.  <br /></td></tr>
<tr class="separator:ae49a028da76d8b6d201593c618414563 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c63883d72a6c02c4c104bda68bbff2 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a07c63883d72a6c02c4c104bda68bbff2">enclosesVolumeWithOtherOnAxis</a> (const int axis, const <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *other)</td></tr>
<tr class="memdesc:a07c63883d72a6c02c4c104bda68bbff2 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an octree node's box encloses volume with another octree node's box on a specific axis.  <br /></td></tr>
<tr class="separator:a07c63883d72a6c02c4c104bda68bbff2 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89bb30dbb1b22ab41f94f87d01ba145 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ac89bb30dbb1b22ab41f94f87d01ba145">overlapsBox</a> (const std::array&lt; double, 3 &gt; &amp;otherMin, const std::array&lt; double, 3 &gt; &amp;otherMax)</td></tr>
<tr class="memdesc:ac89bb30dbb1b22ab41f94f87d01ba145 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node's axis aligned bounding box overlaps with the given axis aligned bounding box.  <br /></td></tr>
<tr class="separator:ac89bb30dbb1b22ab41f94f87d01ba145 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b732ab55963e9575b3dc07f67e5e9 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#acf5b732ab55963e9575b3dc07f67e5e9">getEnclosedVolumeWith</a> (const std::array&lt; double, 3 &gt; &amp;otherMin, const std::array&lt; double, 3 &gt; &amp;otherMax)</td></tr>
<tr class="memdesc:acf5b732ab55963e9575b3dc07f67e5e9 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the overlap volume between the node's axis aligned bounding box and the given box.  <br /></td></tr>
<tr class="separator:acf5b732ab55963e9575b3dc07f67e5e9 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5ebf043fb5de4cfdd13593ec13c450 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#aed5ebf043fb5de4cfdd13593ec13c450">EQ_FACE_NEIGHBOR</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a818a2d31517a95d918fa800aec9cd9db">octree::Face</a> I)</td></tr>
<tr class="memdesc:aed5ebf043fb5de4cfdd13593ec13c450 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:aed5ebf043fb5de4cfdd13593ec13c450 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fd47e1959b389889268556bd3c562c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a08fd47e1959b389889268556bd3c562c">EQ_EDGE_NEIGHBOR</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a652aa1ac1df1cb0b731ef71fb4962c13">octree::Edge</a> I)</td></tr>
<tr class="memdesc:a08fd47e1959b389889268556bd3c562c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:a08fd47e1959b389889268556bd3c562c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64300d0c48ead9478bd8b77482a906e4 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a64300d0c48ead9478bd8b77482a906e4">EQ_VERTEX_NEIGHBOR</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> I)</td></tr>
<tr class="memdesc:a64300d0c48ead9478bd8b77482a906e4 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:a64300d0c48ead9478bd8b77482a906e4 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebfbc310d152aa2d67a917db3c3c8a1 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#aaebfbc310d152aa2d67a917db3c3c8a1">GTEQ_FACE_NEIGHBOR</a> (<a class="el" href="namespaceautopas_1_1octree.html#a818a2d31517a95d918fa800aec9cd9db">octree::Face</a> I)</td></tr>
<tr class="memdesc:aaebfbc310d152aa2d67a917db3c3c8a1 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:aaebfbc310d152aa2d67a917db3c3c8a1 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5573639d1edd41e219a137db2c93bf6d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a5573639d1edd41e219a137db2c93bf6d">GTEQ_EDGE_NEIGHBOR</a> (<a class="el" href="namespaceautopas_1_1octree.html#a652aa1ac1df1cb0b731ef71fb4962c13">octree::Edge</a> I)</td></tr>
<tr class="memdesc:a5573639d1edd41e219a137db2c93bf6d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:a5573639d1edd41e219a137db2c93bf6d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb1c48eeb21bd6c9fa5146738a1ab1d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#afdb1c48eeb21bd6c9fa5146738a1ab1d">GTEQ_VERTEX_NEIGHBOR</a> (<a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> I)</td></tr>
<tr class="memdesc:afdb1c48eeb21bd6c9fa5146738a1ab1d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:afdb1c48eeb21bd6c9fa5146738a1ab1d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd593f1ba72c28f5fdeca506a5246c8 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a0cd593f1ba72c28f5fdeca506a5246c8">getLeavesFromDirections</a> (const std::vector&lt; <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> &gt; &amp;directions)=0</td></tr>
<tr class="memdesc:a0cd593f1ba72c28f5fdeca506a5246c8 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaf nodes along a list of given directions.  <br /></td></tr>
<tr class="separator:a0cd593f1ba72c28f5fdeca506a5246c8 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf66b7e2aebf1bc8e07456550955f8a inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#aadf66b7e2aebf1bc8e07456550955f8a">getNeighborLeaves</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a247c6f197293ce9a2b453bc01f7a40cb">octree::Any</a> direction)</td></tr>
<tr class="memdesc:aadf66b7e2aebf1bc8e07456550955f8a inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function combines all required functions when traversing down a subtree of the octree and finding all leaves.  <br /></td></tr>
<tr class="separator:aadf66b7e2aebf1bc8e07456550955f8a inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a7fd43486192546e50b5541a9cc3eb inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a61a7fd43486192546e50b5541a9cc3eb">getNeighborLeaves</a> ()</td></tr>
<tr class="memdesc:a61a7fd43486192546e50b5541a9cc3eb inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the neighbor leaves in all directions.  <br /></td></tr>
<tr class="separator:a61a7fd43486192546e50b5541a9cc3eb inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481b0e8598dd0a88c27ae9196764e387 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a481b0e8598dd0a88c27ae9196764e387">getBoxMin</a> () const</td></tr>
<tr class="memdesc:a481b0e8598dd0a88c27ae9196764e387 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum coordinate of the enclosing box.  <br /></td></tr>
<tr class="separator:a481b0e8598dd0a88c27ae9196764e387 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20088a8ceb4e7cb71a5450075473240c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a20088a8ceb4e7cb71a5450075473240c">getBoxMax</a> () const</td></tr>
<tr class="memdesc:a20088a8ceb4e7cb71a5450075473240c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum coordinate of the enclosing box.  <br /></td></tr>
<tr class="separator:a20088a8ceb4e7cb71a5450075473240c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72617b706afd5a1884400a7b5b0da7ef inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a72617b706afd5a1884400a7b5b0da7ef">getParent</a> () const</td></tr>
<tr class="memdesc:a72617b706afd5a1884400a7b5b0da7ef inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent node of this node.  <br /></td></tr>
<tr class="separator:a72617b706afd5a1884400a7b5b0da7ef inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1FullParticleCell"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1FullParticleCell')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1FullParticleCell.html">autopas::FullParticleCell&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:ae62fdf764339f7f3e469a1196caeba4a inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="ae62fdf764339f7f3e469a1196caeba4a" name="ae62fdf764339f7f3e469a1196caeba4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FullParticleCell</b> ()</td></tr>
<tr class="memdesc:ae62fdf764339f7f3e469a1196caeba4a inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classautopas_1_1FullParticleCell.html" title="This class handles the storage of particles in their full form.">FullParticleCell</a>. <br /></td></tr>
<tr class="separator:ae62fdf764339f7f3e469a1196caeba4a inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02d90c40ba6e10d77046e53f0727875 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#ae02d90c40ba6e10d77046e53f0727875">FullParticleCell</a> (const std::array&lt; double, 3 &gt; &amp;cellLength)</td></tr>
<tr class="memdesc:ae02d90c40ba6e10d77046e53f0727875 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classautopas_1_1FullParticleCell.html" title="This class handles the storage of particles in their full form.">FullParticleCell</a> with the given cell side length.  <br /></td></tr>
<tr class="separator:ae02d90c40ba6e10d77046e53f0727875 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f131e3696e3e4855ad715aad6cef65 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a66f131e3696e3e4855ad715aad6cef65">addParticle</a> (const Particle_T &amp;p) override</td></tr>
<tr class="memdesc:a66f131e3696e3e4855ad715aad6cef65 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Particle to the cell.  <br /></td></tr>
<tr class="separator:a66f131e3696e3e4855ad715aad6cef65 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae987912bd213d3f4b06a5f942ced4470 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1FullParticleCell.html#a0406e37cb3e9d99fe3fa9d18116ea3f3">StorageType</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#ae987912bd213d3f4b06a5f942ced4470">begin</a> ()</td></tr>
<tr class="memdesc:ae987912bd213d3f4b06a5f942ced4470 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the start of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.  <br /></td></tr>
<tr class="separator:ae987912bd213d3f4b06a5f942ced4470 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bde07fadd1b7146f67b96ea02861b4d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1FullParticleCell.html#a0406e37cb3e9d99fe3fa9d18116ea3f3">StorageType</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a7bde07fadd1b7146f67b96ea02861b4d">begin</a> () const</td></tr>
<tr class="memdesc:a7bde07fadd1b7146f67b96ea02861b4d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the start of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.    <br /></td></tr>
<tr class="separator:a7bde07fadd1b7146f67b96ea02861b4d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d563b0734fd0e27f8b439c3695afde inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1FullParticleCell.html#a0406e37cb3e9d99fe3fa9d18116ea3f3">StorageType</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#ab3d563b0734fd0e27f8b439c3695afde">end</a> ()</td></tr>
<tr class="memdesc:ab3d563b0734fd0e27f8b439c3695afde inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.  <br /></td></tr>
<tr class="separator:ab3d563b0734fd0e27f8b439c3695afde inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5426c09292c7adf71feb85599868cb94 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellIterator.html">CellIterator</a>&lt; <a class="el" href="classautopas_1_1FullParticleCell.html#a0406e37cb3e9d99fe3fa9d18116ea3f3">StorageType</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a5426c09292c7adf71feb85599868cb94">end</a> () const</td></tr>
<tr class="memdesc:a5426c09292c7adf71feb85599868cb94 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end of a <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a>.    <br /></td></tr>
<tr class="separator:a5426c09292c7adf71feb85599868cb94 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfd04fffc6ca25289048b9c4e035e79 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a2bfd04fffc6ca25289048b9c4e035e79 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a2bfd04fffc6ca25289048b9c4e035e79">forEach</a> (Lambda forEachLambda)</td></tr>
<tr class="memdesc:a2bfd04fffc6ca25289048b9c4e035e79 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes code for every particle in this cell as defined by lambda function.  <br /></td></tr>
<tr class="separator:a2bfd04fffc6ca25289048b9c4e035e79 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71131fad6aba4352d08c691eb5859c16 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a71131fad6aba4352d08c691eb5859c16 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a71131fad6aba4352d08c691eb5859c16">forEach</a> (Lambda forEachLambda, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:a71131fad6aba4352d08c691eb5859c16 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes code for every particle in this cell as defined by lambda function.  <br /></td></tr>
<tr class="separator:a71131fad6aba4352d08c691eb5859c16 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccca9f969737bb9d71226ea5747af67 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a2ccca9f969737bb9d71226ea5747af67 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a2ccca9f969737bb9d71226ea5747af67">forEach</a> (Lambda forEachLambda, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:a2ccca9f969737bb9d71226ea5747af67 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes code for every particle in this cell as defined by lambda function.  <br /></td></tr>
<tr class="separator:a2ccca9f969737bb9d71226ea5747af67 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c70576150ddadc75f5e7df1a95154d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:a99c70576150ddadc75f5e7df1a95154d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a99c70576150ddadc75f5e7df1a95154d">reduce</a> (Lambda reduceLambda, A &amp;result)</td></tr>
<tr class="memdesc:a99c70576150ddadc75f5e7df1a95154d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce properties of particles as defined by a lambda function.  <br /></td></tr>
<tr class="separator:a99c70576150ddadc75f5e7df1a95154d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa772bbdfdf36dd0d558a981c8c73ed93 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:aa772bbdfdf36dd0d558a981c8c73ed93 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#aa772bbdfdf36dd0d558a981c8c73ed93">reduce</a> (Lambda reduceLambda, A &amp;result, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:aa772bbdfdf36dd0d558a981c8c73ed93 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce properties of particles as defined by a lambda function.  <br /></td></tr>
<tr class="separator:aa772bbdfdf36dd0d558a981c8c73ed93 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723857b68ccc0fd1b473191032380f7f inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:a723857b68ccc0fd1b473191032380f7f inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a723857b68ccc0fd1b473191032380f7f">reduce</a> (Lambda reduceLambda, A &amp;result, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:a723857b68ccc0fd1b473191032380f7f inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce properties of particles as defined by a lambda function.  <br /></td></tr>
<tr class="separator:a723857b68ccc0fd1b473191032380f7f inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2008ea83cf9d3bddff9e6363533476f7 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a2008ea83cf9d3bddff9e6363533476f7">size</a> () const override</td></tr>
<tr class="memdesc:a2008ea83cf9d3bddff9e6363533476f7 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of all particles stored in this cell (owned, halo and dummy).  <br /></td></tr>
<tr class="separator:a2008ea83cf9d3bddff9e6363533476f7 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972f850a2c388f7409573a2390017dae inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a972f850a2c388f7409573a2390017dae">getNumberOfParticles</a> (IteratorBehavior behavior) const override</td></tr>
<tr class="memdesc:a972f850a2c388f7409573a2390017dae inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.    <br /></td></tr>
<tr class="separator:a972f850a2c388f7409573a2390017dae inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2315205ecac9bdb843b4350107cf85 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">Particle_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a6f2315205ecac9bdb843b4350107cf85">operator[]</a> (size_t n)</td></tr>
<tr class="memdesc:a6f2315205ecac9bdb843b4350107cf85 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at position n in the cell.  <br /></td></tr>
<tr class="separator:a6f2315205ecac9bdb843b4350107cf85 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85e761bb0b5bc6a949d37ee0b9207fd inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">const Particle_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#aa85e761bb0b5bc6a949d37ee0b9207fd">operator[]</a> (size_t n) const</td></tr>
<tr class="memdesc:aa85e761bb0b5bc6a949d37ee0b9207fd inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the element at position n in the cell.  <br /></td></tr>
<tr class="separator:aa85e761bb0b5bc6a949d37ee0b9207fd inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf83627ba1bd21ead7f2d6061a96bd3 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">Particle_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a0cf83627ba1bd21ead7f2d6061a96bd3">at</a> (size_t index)</td></tr>
<tr class="memdesc:a0cf83627ba1bd21ead7f2d6061a96bd3 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the particle at position index.  <br /></td></tr>
<tr class="separator:a0cf83627ba1bd21ead7f2d6061a96bd3 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8ca84f0a9f2ac47cb6883fe0734d97 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a8c8ca84f0a9f2ac47cb6883fe0734d97">getParticleCellTypeAsEnum</a> () override</td></tr>
<tr class="memdesc:a8c8ca84f0a9f2ac47cb6883fe0734d97 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an ParticleCellTypeEnum.  <br /></td></tr>
<tr class="separator:a8c8ca84f0a9f2ac47cb6883fe0734d97 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c99676ff044a3fd8820a349e455740 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">const Particle_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#ad0c99676ff044a3fd8820a349e455740">at</a> (size_t index) const</td></tr>
<tr class="memdesc:ad0c99676ff044a3fd8820a349e455740 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the const particle at position index.  <br /></td></tr>
<tr class="separator:ad0c99676ff044a3fd8820a349e455740 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ecd0798adb4f6bf0f1d0bb7f975c37 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a32ecd0798adb4f6bf0f1d0bb7f975c37">isEmpty</a> () const override</td></tr>
<tr class="memdesc:a32ecd0798adb4f6bf0f1d0bb7f975c37 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the cell is empty.  <br /></td></tr>
<tr class="separator:a32ecd0798adb4f6bf0f1d0bb7f975c37 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353a4a796a5d5dddd2e87d87e54ef2d3 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a353a4a796a5d5dddd2e87d87e54ef2d3">clear</a> () override</td></tr>
<tr class="memdesc:a353a4a796a5d5dddd2e87d87e54ef2d3 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles in this cell.  <br /></td></tr>
<tr class="separator:a353a4a796a5d5dddd2e87d87e54ef2d3 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0414ef966db4991be14dc4ef89806115 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a0414ef966db4991be14dc4ef89806115">deleteDummyParticles</a> () override</td></tr>
<tr class="memdesc:a0414ef966db4991be14dc4ef89806115 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all dummy particles in this cell.  <br /></td></tr>
<tr class="separator:a0414ef966db4991be14dc4ef89806115 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050a59b1fc6f61d9f55451f7c159ea82 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a050a59b1fc6f61d9f55451f7c159ea82">deleteByIndex</a> (size_t index) override</td></tr>
<tr class="memdesc:a050a59b1fc6f61d9f55451f7c159ea82 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the index-th particle.  <br /></td></tr>
<tr class="separator:a050a59b1fc6f61d9f55451f7c159ea82 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6282cee8c33fd3b84f712bcbef80d49c inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a6282cee8c33fd3b84f712bcbef80d49c">setCellLength</a> (std::array&lt; double, 3 &gt; &amp;cellLength) override</td></tr>
<tr class="memdesc:a6282cee8c33fd3b84f712bcbef80d49c inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the side lengths of this cell.  <br /></td></tr>
<tr class="separator:a6282cee8c33fd3b84f712bcbef80d49c inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519f12bc75085eeae586ae8db03fd5b4 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a519f12bc75085eeae586ae8db03fd5b4">getCellLength</a> () const override</td></tr>
<tr class="memdesc:a519f12bc75085eeae586ae8db03fd5b4 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the side lengths of this cell.  <br /></td></tr>
<tr class="separator:a519f12bc75085eeae586ae8db03fd5b4 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb72b9acb760e43b04b07d672650b2b1 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#acb72b9acb760e43b04b07d672650b2b1">resize</a> (size_t n, const Particle_T &amp;toInsert)</td></tr>
<tr class="memdesc:acb72b9acb760e43b04b07d672650b2b1 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container so that it contains n elements.  <br /></td></tr>
<tr class="separator:acb72b9acb760e43b04b07d672650b2b1 inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e773d0ec55d22e6afe87665f2d730d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a32e773d0ec55d22e6afe87665f2d730d">sortByDim</a> (const size_t dim)</td></tr>
<tr class="memdesc:a32e773d0ec55d22e6afe87665f2d730d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the particles in the cell by a dimension.  <br /></td></tr>
<tr class="separator:a32e773d0ec55d22e6afe87665f2d730d inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474aabf6c310b9d29fc90b0892b1396e inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FullParticleCell.html#a474aabf6c310b9d29fc90b0892b1396e">reserve</a> (size_t n)</td></tr>
<tr class="memdesc:a474aabf6c310b9d29fc90b0892b1396e inherit pub_methods_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the vector capacity be at least enough to contain n elements.  <br /></td></tr>
<tr class="separator:a474aabf6c310b9d29fc90b0892b1396e inherit pub_methods_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1ParticleCell"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1ParticleCell')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1ParticleCell.html">autopas::ParticleCell&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a7a5f1fceeb96e9cc5612141ee54ff256 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="a7a5f1fceeb96e9cc5612141ee54ff256" name="a7a5f1fceeb96e9cc5612141ee54ff256"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ParticleCell</b> ()=default</td></tr>
<tr class="memdesc:a7a5f1fceeb96e9cc5612141ee54ff256 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a7a5f1fceeb96e9cc5612141ee54ff256 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b50d7256264cdf152cd214900502e5d inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="a7b50d7256264cdf152cd214900502e5d" name="a7b50d7256264cdf152cd214900502e5d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleCell</b> ()=default</td></tr>
<tr class="memdesc:a7b50d7256264cdf152cd214900502e5d inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default default constructor. <br /></td></tr>
<tr class="separator:a7b50d7256264cdf152cd214900502e5d inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af99949724d70bf5f6b2b6583a6e7b7 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a1af99949724d70bf5f6b2b6583a6e7b7">ParticleCell</a> (<a class="el" href="classautopas_1_1ParticleCell.html">ParticleCell</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a1af99949724d70bf5f6b2b6583a6e7b7 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor.  <br /></td></tr>
<tr class="separator:a1af99949724d70bf5f6b2b6583a6e7b7 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91ae00532b039a28c12e33f00c8d28a inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#ad91ae00532b039a28c12e33f00c8d28a">ParticleCell</a> (const <a class="el" href="classautopas_1_1ParticleCell.html">ParticleCell</a> &amp;other)</td></tr>
<tr class="memdesc:ad91ae00532b039a28c12e33f00c8d28a inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor that creates a new default constructed lock for the new cell.  <br /></td></tr>
<tr class="separator:ad91ae00532b039a28c12e33f00c8d28a inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a327fba022da069e42f460b063e68 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aa68a327fba022da069e42f460b063e68">addParticle</a> (const Particle_T &amp;p)=0</td></tr>
<tr class="memdesc:aa68a327fba022da069e42f460b063e68 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Particle to the cell.  <br /></td></tr>
<tr class="separator:aa68a327fba022da069e42f460b063e68 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a047b4cc19bc7c29b6153ab48556cc6 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a3a047b4cc19bc7c29b6153ab48556cc6">size</a> () const =0</td></tr>
<tr class="memdesc:a3a047b4cc19bc7c29b6153ab48556cc6 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of all particles stored in this cell (owned, halo and dummy).  <br /></td></tr>
<tr class="separator:a3a047b4cc19bc7c29b6153ab48556cc6 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef492136b8cc0f1c5227b75e8d007223 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aef492136b8cc0f1c5227b75e8d007223">getNumberOfParticles</a> (IteratorBehavior behavior=IteratorBehavior::owned) const =0</td></tr>
<tr class="memdesc:aef492136b8cc0f1c5227b75e8d007223 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.  <br /></td></tr>
<tr class="separator:aef492136b8cc0f1c5227b75e8d007223 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd1a2bf74c3538ae508904fe196c4f0 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a4fd1a2bf74c3538ae508904fe196c4f0">isEmpty</a> () const =0</td></tr>
<tr class="memdesc:a4fd1a2bf74c3538ae508904fe196c4f0 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the cell is empty.  <br /></td></tr>
<tr class="separator:a4fd1a2bf74c3538ae508904fe196c4f0 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a8350d1fc7ea59c0ffdf63d8da8c7d inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a24a8350d1fc7ea59c0ffdf63d8da8c7d">clear</a> ()=0</td></tr>
<tr class="memdesc:a24a8350d1fc7ea59c0ffdf63d8da8c7d inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles in this cell.  <br /></td></tr>
<tr class="separator:a24a8350d1fc7ea59c0ffdf63d8da8c7d inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1600925339d8d42d31abdd8465c15a4 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aa1600925339d8d42d31abdd8465c15a4">deleteDummyParticles</a> ()=0</td></tr>
<tr class="memdesc:aa1600925339d8d42d31abdd8465c15a4 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all dummy particles in this cell.  <br /></td></tr>
<tr class="separator:aa1600925339d8d42d31abdd8465c15a4 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc1db292417b9a91fcbe43a56b4524e inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aabc1db292417b9a91fcbe43a56b4524e">getParticleCellTypeAsEnum</a> ()=0</td></tr>
<tr class="memdesc:aabc1db292417b9a91fcbe43a56b4524e inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an ParticleCellTypeEnum.  <br /></td></tr>
<tr class="separator:aabc1db292417b9a91fcbe43a56b4524e inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946ae25741ba9249081fe24d501ccfa5 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a946ae25741ba9249081fe24d501ccfa5">deleteByIndex</a> (size_t index)=0</td></tr>
<tr class="memdesc:a946ae25741ba9249081fe24d501ccfa5 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the index-th particle.  <br /></td></tr>
<tr class="separator:a946ae25741ba9249081fe24d501ccfa5 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad229dcc7028778120dfe33b3161d9201 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#ad229dcc7028778120dfe33b3161d9201">setCellLength</a> (std::array&lt; double, 3 &gt; &amp;cellLength)=0</td></tr>
<tr class="memdesc:ad229dcc7028778120dfe33b3161d9201 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the side lengths of this cell.  <br /></td></tr>
<tr class="separator:ad229dcc7028778120dfe33b3161d9201 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e68017cfc40ca9407e03e83d888955 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">virtual std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#ac4e68017cfc40ca9407e03e83d888955">getCellLength</a> () const =0</td></tr>
<tr class="memdesc:ac4e68017cfc40ca9407e03e83d888955 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the side lengths of this cell.  <br /></td></tr>
<tr class="separator:ac4e68017cfc40ca9407e03e83d888955 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4034add6b3f0c98afbe69db9552ea8 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0">OwnershipState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aaa4034add6b3f0c98afbe69db9552ea8">getPossibleParticleOwnerships</a> () const</td></tr>
<tr class="memdesc:aaa4034add6b3f0c98afbe69db9552ea8 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of particles contained in this cell.  <br /></td></tr>
<tr class="separator:aaa4034add6b3f0c98afbe69db9552ea8 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ebee3bc723ceb54f11359c9acdebd9 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#a90ebee3bc723ceb54f11359c9acdebd9">setPossibleParticleOwnerships</a> (<a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0">OwnershipState</a> state)</td></tr>
<tr class="memdesc:a90ebee3bc723ceb54f11359c9acdebd9 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of particles contained in this cell.  <br /></td></tr>
<tr class="separator:a90ebee3bc723ceb54f11359c9acdebd9 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5856ed7123bda9dbc4044bce889d20 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1AutoPasLock.html">AutoPasLock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#aef5856ed7123bda9dbc4044bce889d20">getCellLock</a> () const</td></tr>
<tr class="memdesc:aef5856ed7123bda9dbc4044bce889d20 inherit pub_methods_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lock object for exclusive access to this cell.  <br /></td></tr>
<tr class="separator:aef5856ed7123bda9dbc4044bce889d20 inherit pub_methods_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classautopas_1_1FullParticleCell"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classautopas_1_1FullParticleCell')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classautopas_1_1FullParticleCell.html">autopas::FullParticleCell&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a4602cb2990b0ab8d2c35a16c68dc6b71 inherit pub_types_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="a4602cb2990b0ab8d2c35a16c68dc6b71" name="a4602cb2990b0ab8d2c35a16c68dc6b71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SoAArraysType</b> = typename Particle_T::SoAArraysType</td></tr>
<tr class="memdesc:a4602cb2990b0ab8d2c35a16c68dc6b71 inherit pub_types_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure of the SoAs is defined by the particle. <br /></td></tr>
<tr class="separator:a4602cb2990b0ab8d2c35a16c68dc6b71 inherit pub_types_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0406e37cb3e9d99fe3fa9d18116ea3f3 inherit pub_types_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="a0406e37cb3e9d99fe3fa9d18116ea3f3" name="a0406e37cb3e9d99fe3fa9d18116ea3f3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StorageType</b> = std::vector&lt; Particle_T &gt;</td></tr>
<tr class="memdesc:a0406e37cb3e9d99fe3fa9d18116ea3f3 inherit pub_types_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that holds or refers to the actual particles. <br /></td></tr>
<tr class="separator:a0406e37cb3e9d99fe3fa9d18116ea3f3 inherit pub_types_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classautopas_1_1ParticleCell"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classautopas_1_1ParticleCell')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classautopas_1_1ParticleCell.html">autopas::ParticleCell&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:af02347c5927b01556f16d950de9f5a53 inherit pub_types_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#af02347c5927b01556f16d950de9f5a53">ParticleType</a> = Particle_T</td></tr>
<tr class="memdesc:af02347c5927b01556f16d950de9f5a53 inherit pub_types_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">The particle type for this cell.  <br /></td></tr>
<tr class="separator:af02347c5927b01556f16d950de9f5a53 inherit pub_types_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classautopas_1_1OctreeNodeInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classautopas_1_1OctreeNodeInterface')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:ad0c1d04c45912df3fdd297f3af8dbed5 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad0c1d04c45912df3fdd297f3af8dbed5">volumeExistsOnAxis</a> (const int axis, const std::array&lt; double, 3 &gt; &amp;aMin, const std::array&lt; double, 3 &gt; &amp;aMax, const std::array&lt; double, 3 &gt; &amp;bMin, const std::array&lt; double, 3 &gt; &amp;bMax)</td></tr>
<tr class="memdesc:ad0c1d04c45912df3fdd297f3af8dbed5 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the volume enclosed by two boxes a and b is nonzero on a specific axis.  <br /></td></tr>
<tr class="separator:ad0c1d04c45912df3fdd297f3af8dbed5 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aefc0e5edf8144556465f58419e579 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a04aefc0e5edf8144556465f58419e579">getEnclosedVolumeWith</a> (const std::array&lt; double, 3 &gt; &amp;aMin, const std::array&lt; double, 3 &gt; &amp;aMax, const std::array&lt; double, 3 &gt; &amp;bMin, const std::array&lt; double, 3 &gt; &amp;bMax)</td></tr>
<tr class="memdesc:a04aefc0e5edf8144556465f58419e579 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enclosed volume between two boxes a and b.  <br /></td></tr>
<tr class="separator:a04aefc0e5edf8144556465f58419e579 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classautopas_1_1FullParticleCell"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classautopas_1_1FullParticleCell')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classautopas_1_1FullParticleCell.html">autopas::FullParticleCell&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a1a5fb17011e10f42362b09afee8a6da4 inherit pub_attribs_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="a1a5fb17011e10f42362b09afee8a6da4" name="a1a5fb17011e10f42362b09afee8a6da4"></a>
<a class="el" href="classautopas_1_1FullParticleCell.html#a0406e37cb3e9d99fe3fa9d18116ea3f3">StorageType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_particles</b> {}</td></tr>
<tr class="memdesc:a1a5fb17011e10f42362b09afee8a6da4 inherit pub_attribs_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage of the molecules of the cell. <br /></td></tr>
<tr class="separator:a1a5fb17011e10f42362b09afee8a6da4 inherit pub_attribs_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6129ff74d12caa7cbe179cb96ab7bb0 inherit pub_attribs_classautopas_1_1FullParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="ab6129ff74d12caa7cbe179cb96ab7bb0" name="ab6129ff74d12caa7cbe179cb96ab7bb0"></a>
<a class="el" href="classautopas_1_1SoA.html">SoA</a>&lt; <a class="el" href="classautopas_1_1FullParticleCell.html#a4602cb2990b0ab8d2c35a16c68dc6b71">SoAArraysType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_particleSoABuffer</b> {}</td></tr>
<tr class="memdesc:ab6129ff74d12caa7cbe179cb96ab7bb0 inherit pub_attribs_classautopas_1_1FullParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classautopas_1_1SoA.html" title="Structur of the array class.">SoA</a> buffer of this cell. <br /></td></tr>
<tr class="separator:ab6129ff74d12caa7cbe179cb96ab7bb0 inherit pub_attribs_classautopas_1_1FullParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classautopas_1_1OctreeNodeInterface"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classautopas_1_1OctreeNodeInterface')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a79ddbbda5873b854d2f743873ea371fd inherit pro_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a79ddbbda5873b854d2f743873ea371fd">hasParent</a> ()</td></tr>
<tr class="memdesc:a79ddbbda5873b854d2f743873ea371fd inherit pro_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this is not the root node.  <br /></td></tr>
<tr class="separator:a79ddbbda5873b854d2f743873ea371fd inherit pro_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classautopas_1_1OctreeNodeInterface"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classautopas_1_1OctreeNodeInterface')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a7f7309cc7f3b730c5513ae81f43a716a inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7f7309cc7f3b730c5513ae81f43a716a">_parent</a></td></tr>
<tr class="memdesc:a7f7309cc7f3b730c5513ae81f43a716a inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the parent node.  <br /></td></tr>
<tr class="separator:a7f7309cc7f3b730c5513ae81f43a716a inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5287a3f6fbd9e0e28ab813cd4086e8 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a0f5287a3f6fbd9e0e28ab813cd4086e8" name="a0f5287a3f6fbd9e0e28ab813cd4086e8"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_boxMin</b></td></tr>
<tr class="memdesc:a0f5287a3f6fbd9e0e28ab813cd4086e8 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The min coordinate of the enclosed volume. <br /></td></tr>
<tr class="separator:a0f5287a3f6fbd9e0e28ab813cd4086e8 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4809bbd85e6cb2ee83603f92e22c3178 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a4809bbd85e6cb2ee83603f92e22c3178" name="a4809bbd85e6cb2ee83603f92e22c3178"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_boxMax</b></td></tr>
<tr class="memdesc:a4809bbd85e6cb2ee83603f92e22c3178 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max coordinate of the enclosed volume. <br /></td></tr>
<tr class="separator:a4809bbd85e6cb2ee83603f92e22c3178 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc048ebbdf29cdf3e9218fc44e9e843 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a6cc048ebbdf29cdf3e9218fc44e9e843" name="a6cc048ebbdf29cdf3e9218fc44e9e843"></a>
int unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>_treeSplitThreshold</b></td></tr>
<tr class="memdesc:a6cc048ebbdf29cdf3e9218fc44e9e843 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of particles inside a leaf node before the leaf tries to split itself. <br /></td></tr>
<tr class="separator:a6cc048ebbdf29cdf3e9218fc44e9e843 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63368dc6c9bedc926a3a8f4d2266ddc0 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a63368dc6c9bedc926a3a8f4d2266ddc0" name="a63368dc6c9bedc926a3a8f4d2266ddc0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_interactionLength</b></td></tr>
<tr class="memdesc:a63368dc6c9bedc926a3a8f4d2266ddc0 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum distance at which a force is considered nonzero, cutoff+skin. <br /></td></tr>
<tr class="separator:a63368dc6c9bedc926a3a8f4d2266ddc0 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced807582ba52e048c9620b0b56d5971 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="aced807582ba52e048c9620b0b56d5971" name="aced807582ba52e048c9620b0b56d5971"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_cellSizeFactor</b></td></tr>
<tr class="memdesc:aced807582ba52e048c9620b0b56d5971 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cell size factor for this node. <br /></td></tr>
<tr class="separator:aced807582ba52e048c9620b0b56d5971 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classautopas_1_1ParticleCell"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classautopas_1_1ParticleCell')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classautopas_1_1ParticleCell.html">autopas::ParticleCell&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:adc1aac6e9554a08ef005ddf036d15c54 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1AutoPasLock.html">AutoPasLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleCell.html#adc1aac6e9554a08ef005ddf036d15c54">_cellLock</a> {}</td></tr>
<tr class="memdesc:adc1aac6e9554a08ef005ddf036d15c54 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock object for exclusive access to this cell.  <br /></td></tr>
<tr class="separator:adc1aac6e9554a08ef005ddf036d15c54 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912cd158447a3b696071631ac35e46da inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="a912cd158447a3b696071631ac35e46da" name="a912cd158447a3b696071631ac35e46da"></a>
<a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0">OwnershipState</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_ownershipState</b> {<a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0a8f9a4c5fe0824547590a3fc568f5c7c7">autopas::OwnershipState::owned</a> | <a class="el" href="namespaceautopas.html#a82a8cce861d1c5e0aae32f34ed39e5e0a57f842286171094855e51fc3a541c1e2">autopas::OwnershipState::halo</a>}</td></tr>
<tr class="memdesc:a912cd158447a3b696071631ac35e46da inherit pro_attribs_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">The particles which can be contained in this cell are determined by the OwnershipState. <br /></td></tr>
<tr class="separator:a912cd158447a3b696071631ac35e46da inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d779bb5057b5009a167c9e6a4e9305 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memItemLeft" align="right" valign="top"><a id="ae0d779bb5057b5009a167c9e6a4e9305" name="ae0d779bb5057b5009a167c9e6a4e9305"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_ownershipStateDefined</b> {false}</td></tr>
<tr class="memdesc:ae0d779bb5057b5009a167c9e6a4e9305 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag that is set to true once OwnershipState has been set to avoid resetting the OwnershipState. <br /></td></tr>
<tr class="separator:ae0d779bb5057b5009a167c9e6a4e9305 inherit pro_attribs_classautopas_1_1ParticleCell"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Particle_T&gt;<br />
class autopas::OctreeLeafNode&lt; Particle_T &gt;</div><p>An octree leaf node. </p>
<p>This forward declaration is required since the <code><a class="el" href="classautopas_1_1OctreeNodeInterface.html" title="The base class that provides the necessary function definitions that can be applied to an octree.">OctreeNodeInterface</a></code> provides a method to gather all <code><a class="el" href="classautopas_1_1OctreeLeafNode.html" title="An octree leaf node.">OctreeLeafNode</a></code>s.</p>
<p>This class utilizes the <a class="el" href="classautopas_1_1FullParticleCell.html" title="This class handles the storage of particles in their full form.">FullParticleCell</a> to store the actual particles.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle_T</td><td></td></tr>
    <tr><td class="paramname">Particle_T</td><td></td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab78b41368b1fbaa8ba973b29cdd86381" name="ab78b41368b1fbaa8ba973b29cdd86381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78b41368b1fbaa8ba973b29cdd86381">&#9670;&#160;</a></span>OctreeLeafNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::OctreeLeafNode </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int unsigned&#160;</td>
          <td class="paramname"><em>treeSplitThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>interactionLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cellSizeFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty octree leaf node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>The min coordinate of the octree box </td></tr>
    <tr><td class="paramname">boxMax</td><td>The max coordinate of the octree box </td></tr>
    <tr><td class="paramname">parent</td><td>A pointer to the parent node. Should be nullptr for root nodes. </td></tr>
    <tr><td class="paramname">treeSplitThreshold</td><td>Maximum number of particles inside a leaf before it tries to split itself </td></tr>
    <tr><td class="paramname">interactionLength</td><td>The minimum distance at which a force is considered nonzero, cutoff+skin. </td></tr>
    <tr><td class="paramname">cellSizeFactor</td><td>The cell size factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0006420f08dd436b30b05af42a6f0371" name="a0006420f08dd436b30b05af42a6f0371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0006420f08dd436b30b05af42a6f0371">&#9670;&#160;</a></span>OctreeLeafNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::OctreeLeafNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a leaf by copying all particles from the other leaf to this leaf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The leaf to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a37b378fdfd9d69219620e1015ba2d09e" name="a37b378fdfd9d69219620e1015ba2d09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b378fdfd9d69219620e1015ba2d09e">&#9670;&#160;</a></span>appendAllLeafBoxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::appendAllLeafBoxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, std::array&lt; double, 3 &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the min/max corner coordinates of every leaf into the vector.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>A reference to the vector that should contain pairs of the min/max corner coordinates   </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7fb6398c228be2a285ce1f86c02a8d25">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a6b3f6b89d2601604466f72a4da9c4907" name="a6b3f6b89d2601604466f72a4da9c4907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3f6b89d2601604466f72a4da9c4907">&#9670;&#160;</a></span>appendAllLeaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::appendAllLeaves </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put all leaves below this subtree into a given list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaves</td><td>A reference to the vector that should contain pointers to the leaves </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a2a10fa85f01ff57a9a06c57de607d59b">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a907d0336f707f4a26faccf7ecdf80cea" name="a907d0336f707f4a26faccf7ecdf80cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907d0336f707f4a26faccf7ecdf80cea">&#9670;&#160;</a></span>clearChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::clearChildren </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the entire tree below this node.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>A reference that contains this node   </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab2ab6f178fce0a5742d1881021dac4e3">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a12e5cb3d11dacf950d8680cc4901ae6f" name="a12e5cb3d11dacf950d8680cc4901ae6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e5cb3d11dacf950d8680cc4901ae6f">&#9670;&#160;</a></span>collectAllParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::collectAllParticles </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Particle_T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put all particles that are below this node into the vector.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>A reference to the vector that should contain the particles after the operation   </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a6c6ead81def7160fc03a73c447bf7e53">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a250826c09fbb03f4137faad70f0bb130" name="a250826c09fbb03f4137faad70f0bb130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250826c09fbb03f4137faad70f0bb130">&#9670;&#160;</a></span>deleteParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype">Particle_T &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the given particle from the data structure.   </p>
<p>This function does not change the tree layout if the node is empty after the operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given pointer still points to a new, valid particle.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad25687dec42fc04d53c8ad6416290eb6">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ad6be9392373429add9ea47a43e09e739" name="ad6be9392373429add9ea47a43e09e739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6be9392373429add9ea47a43e09e739">&#9670;&#160;</a></span>getChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::getChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a child by its index from the node.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the child. Must be between 0 and 7 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the child.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a42a83ac4270e177bc03215e0378064aa">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a29511c995905a4f4afaa7f284355e6b8" name="a29511c995905a4f4afaa7f284355e6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29511c995905a4f4afaa7f284355e6b8">&#9670;&#160;</a></span>getID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::getID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the assigned id of this leaf node. </p>
<dl class="section return"><dt>Returns</dt><dd>An ID (or -1 if there was no ID assigned to this node) </dd></dl>

</div>
</div>
<a id="a8e8b6459d0bfa515afb599900092e516" name="a8e8b6459d0bfa515afb599900092e516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8b6459d0bfa515afb599900092e516">&#9670;&#160;</a></span>getLeavesFromDirections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::getLeavesFromDirections </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all leaf nodes along a list of given directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directions</td><td>A list of allowed directions for traversal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of leaf nodes </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a0cd593f1ba72c28f5fdeca506a5246c8">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a8a662b71d40e7c3897e588a3ea193450" name="a8a662b71d40e7c3897e588a3ea193450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a662b71d40e7c3897e588a3ea193450">&#9670;&#160;</a></span>getLeavesInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::getLeavesInRange </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all leaves below this subtree that are in the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum coordinate in 3D space of the query area </td></tr>
    <tr><td class="paramname">max</td><td>The maximum coordinate in 3D space of the query area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of all leaf nodes that are in the query region </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a120821d0ce7268603cafb9f720526b85">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a0809fb178527cb2b55ce01a58b530c3c" name="a0809fb178527cb2b55ce01a58b530c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0809fb178527cb2b55ce01a58b530c3c">&#9670;&#160;</a></span>getNumberOfParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::getNumberOfParticles </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of particles with respect to the specified IteratorBehavior.       </p>
<dl class="section warning"><dt>Warning</dt><dd>: Since this function counts the number of the respective particles in the internal particle storage, this is in O(n) + lock is required. Only use it when it is absolutely necessary to have the exact number of different particle types like owned or halo. If it is enough to have the whole number of particles (owned + halo + dummy), the function <a class="el" href="classautopas_1_1OctreeLeafNode.html#aadd487f39aaf1747d75a4366dbd931b3" title="Get the total number of particles saved in the container (owned + halo + dummy).">size()</a> can be used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of particles with respect to the specified IteratorBehavior.       </dd></dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1FullParticleCell.html#a972f850a2c388f7409573a2390017dae">autopas::FullParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="acae0bac3a0c10b9986be818a06e9fc80" name="acae0bac3a0c10b9986be818a06e9fc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae0bac3a0c10b9986be818a06e9fc80">&#9670;&#160;</a></span>hasChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::hasChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the node is a leaf or an inner node.   </p>
<p>Use this over dynamic_cast to distinguish node types. It is 20-50 times faster! <a href="https://stackoverflow.com/a/49296405/7019073">https://stackoverflow.com/a/49296405/7019073</a> </p><dl class="section return"><dt>Returns</dt><dd>true iff the node is a leaf, false otherwise.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#add2a1188bc4e80325b23040b921e2aaf">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a7e1a1067a22964be7bf9710a8498b14f" name="a7e1a1067a22964be7bf9710a8498b14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1a1067a22964be7bf9710a8498b14f">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a particle into the octree.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The particle to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::unique_ptr to a newly created subtree or nullptr if the subtree did not change   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab5d236108b1d67a05e03eb0ca49a7422">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a07565041ea14af21a7bff8db6c1cc7bd" name="a07565041ea14af21a7bff8db6c1cc7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07565041ea14af21a7bff8db6c1cc7bd">&#9670;&#160;</a></span>setID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::setID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the ID of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>An integer ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadd487f39aaf1747d75a4366dbd931b3" name="aadd487f39aaf1747d75a4366dbd931b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd487f39aaf1747d75a4366dbd931b3">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of particles saved in the container (owned + halo + dummy).     </p>
<dl class="section return"><dt>Returns</dt><dd>Number of particles saved in the container (owned + halo + dummy).     </dd></dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1FullParticleCell.html#a2008ea83cf9d3bddff9e6363533476f7">autopas::FullParticleCell&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a6bab1e9bf95d8ff66cbcf4cef4d0c451" name="a6bab1e9bf95d8ff66cbcf4cef4d0c451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bab1e9bf95d8ff66cbcf4cef4d0c451">&#9670;&#160;</a></span>SON()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeLeafNode.html">autopas::OctreeLeafNode</a>&lt; Particle_T &gt;::SON </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Octant</a>&#160;</td>
          <td class="paramname"><em>O</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a child node of this node (if there are children) given a specific octant using the spacial structure of the stored children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>The octant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a child node </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a4df399ebdc0b38620a35af63bcf13271">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autopas/containers/octree/<a class="el" href="OctreeLeafNode_8h_source.html">OctreeLeafNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="namespaceautopas_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">VerletClusterListsRebuilder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classautopas_1_1internal_1_1VerletClusterListsRebuilder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::internal::VerletClusterListsRebuilder&lt; Particle_T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Helper class for rebuilding the <a class="el" href="classautopas_1_1VerletClusterLists.html" title="Particles are divided into clusters.">VerletClusterLists</a> container.  
 <a href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VerletClusterListsRebuilder_8h_source.html">VerletClusterListsRebuilder.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::internal::VerletClusterListsRebuilder&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1internal_1_1VerletClusterListsRebuilder__inherit__graph.png" border="0" usemap="#aautopas_1_1internal_1_1VerletClusterListsRebuilder_3_01Particle__T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1internal_1_1VerletClusterListsRebuilder_3_01Particle__T_01_4_inherit__map" id="aautopas_1_1internal_1_1VerletClusterListsRebuilder_3_01Particle__T_01_4_inherit__map">
<area shape="rect" title="Helper class for rebuilding the VerletClusterLists container." alt="" coords="11,5,210,60"/>
<area shape="rect" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html" title=" " alt="" coords="5,137,216,192"/>
<area shape="poly" title=" " alt="" coords="113,74,113,137,108,137,108,74"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac488082874949fb5f546906a77a90eb4"><td class="memItemLeft" align="right" valign="top"><a id="ac488082874949fb5f546906a77a90eb4" name="ac488082874949fb5f546906a77a90eb4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NeighborListsBuffer_T</b> = <a class="el" href="classautopas_1_1NeighborListsBuffer.html">NeighborListsBuffer</a>&lt; const <a class="el" href="classautopas_1_1internal_1_1Cluster.html">internal::Cluster</a>&lt; Particle_T &gt; *, <a class="el" href="classautopas_1_1internal_1_1Cluster.html">internal::Cluster</a>&lt; Particle_T &gt; * &gt;</td></tr>
<tr class="memdesc:ac488082874949fb5f546906a77a90eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the neighbor list buffer. <br /></td></tr>
<tr class="separator:ac488082874949fb5f546906a77a90eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af533a794c556c61aa2ba04748841e4f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#af533a794c556c61aa2ba04748841e4f4">VerletClusterListsRebuilder</a> (<a class="el" href="classautopas_1_1internal_1_1ClusterTowerBlock2D.html">ClusterTowerBlock2D</a>&lt; Particle_T &gt; &amp;towerBlock, std::vector&lt; Particle_T &gt; &amp;particlesToAdd, <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#ac488082874949fb5f546906a77a90eb4">NeighborListsBuffer_T</a> &amp;neighborListsBuffer, size_t clusterSize, double interactionLengthSqr, bool newton3)</td></tr>
<tr class="memdesc:af533a794c556c61aa2ba04748841e4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the builder from the cluster list.  <br /></td></tr>
<tr class="separator:af533a794c556c61aa2ba04748841e4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b708ec3fbb9964fb2b363539bfbbb87"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a9b708ec3fbb9964fb2b363539bfbbb87">rebuildTowersAndClusters</a> ()</td></tr>
<tr class="memdesc:a9b708ec3fbb9964fb2b363539bfbbb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuilds the towers, sorts the particles into them and creates the clusters with a reference to an uninitialized neighbor list.  <br /></td></tr>
<tr class="separator:a9b708ec3fbb9964fb2b363539bfbbb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6aef88f42741fcf1e32c14fd2741b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a9b6aef88f42741fcf1e32c14fd2741b0">rebuildNeighborListsAndFillClusters</a> ()</td></tr>
<tr class="memdesc:a9b6aef88f42741fcf1e32c14fd2741b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuilds the neighbor lists and fills Clusters with dummies as described in <a class="el" href="classautopas_1_1internal_1_1ClusterTower.html#af0408295bcd6ea827c1375327817a45c" title="Replaces the copies of the last particle made in generateClusters() with dummies.">ClusterTower::setDummyValues</a>.  <br /></td></tr>
<tr class="separator:a9b6aef88f42741fcf1e32c14fd2741b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a840fb84c9b88a685bf968cf1f649f"><td class="memItemLeft" align="right" valign="top"><a id="ab4a840fb84c9b88a685bf968cf1f649f" name="ab4a840fb84c9b88a685bf968cf1f649f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearNeighborListsAndMoveDummiesIntoClusters</b> ()</td></tr>
<tr class="memdesc:ab4a840fb84c9b88a685bf968cf1f649f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears previously saved neighbors from clusters and sets the 3D positions of the dummy particles to inside of the cluster to avoid all dummies being in one place and potentially trigger cluster-cluster distance evaluations. <br /></td></tr>
<tr class="separator:ab4a840fb84c9b88a685bf968cf1f649f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31236b78c5861ca635e88a131b8d9911"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Particle_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a31236b78c5861ca635e88a131b8d9911">collectAllParticlesFromTowers</a> ()</td></tr>
<tr class="memdesc:a31236b78c5861ca635e88a131b8d9911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes all particles from all towers and returns them.  <br /></td></tr>
<tr class="separator:a31236b78c5861ca635e88a131b8d9911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e00e1f262e029c7f17b1f446a62b2ee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Particle_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a7e00e1f262e029c7f17b1f446a62b2ee">collectOutOfBoundsParticlesFromTowers</a> ()</td></tr>
<tr class="memdesc:a7e00e1f262e029c7f17b1f446a62b2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all particles that are stored in the wrong towers.  <br /></td></tr>
<tr class="separator:a7e00e1f262e029c7f17b1f446a62b2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7125a6d2e615ef30a79db2df8d069c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#ad7125a6d2e615ef30a79db2df8d069c5">sortParticlesIntoTowers</a> (const std::vector&lt; std::vector&lt; Particle_T &gt; &gt; &amp;particles2D)</td></tr>
<tr class="memdesc:ad7125a6d2e615ef30a79db2df8d069c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all passed particles in the appropriate clusters.  <br /></td></tr>
<tr class="separator:ad7125a6d2e615ef30a79db2df8d069c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2816b0e1981c0609db7997cd86fc60fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a2816b0e1981c0609db7997cd86fc60fe">updateNeighborLists</a> ()</td></tr>
<tr class="memdesc:a2816b0e1981c0609db7997cd86fc60fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the neighbor lists for all clusters.  <br /></td></tr>
<tr class="separator:a2816b0e1981c0609db7997cd86fc60fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46910e03c79fc95ee5c8796fb70df513"><td class="memTemplParams" colspan="2">template&lt;class FunType &gt; </td></tr>
<tr class="memitem:a46910e03c79fc95ee5c8796fb70df513"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a46910e03c79fc95ee5c8796fb70df513">iterateNeighborTowers</a> (const int towerIndexX, const int towerIndexY, const int minNeighborIndexX, const int maxNeighborIndexX, const int minNeighborIndexY, const int maxNeighborIndexY, FunType function)</td></tr>
<tr class="memdesc:a46910e03c79fc95ee5c8796fb70df513"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all clusters in a tower, given by it's x/y indices, find all neighbors in towers that are given by an area (min/max x/y neighbor indices).  <br /></td></tr>
<tr class="separator:a46910e03c79fc95ee5c8796fb70df513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf23f55ab52aca922615f0ef1746c00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a6bf23f55ab52aca922615f0ef1746c00">get1DInteractionCellIndexForTower</a> (const int towerIndexX, const int towerIndexY)</td></tr>
<tr class="memdesc:a6bf23f55ab52aca922615f0ef1746c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a imagined interaction cell with side length equal the interaction length that contains the given tower.  <br /></td></tr>
<tr class="separator:a6bf23f55ab52aca922615f0ef1746c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7155f3775efa53e7cdeae8741030a19e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a7155f3775efa53e7cdeae8741030a19e">isForwardNeighbor</a> (const int towerIndexX, const int towerIndexY, const int neighborIndexX, const int neighborIndexY)</td></tr>
<tr class="memdesc:a7155f3775efa53e7cdeae8741030a19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides if a given neighbor tower is a forward neighbor to a given tower.  <br /></td></tr>
<tr class="separator:a7155f3775efa53e7cdeae8741030a19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e627d86745cb8ecf8bd2a1edfcfd58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a28e627d86745cb8ecf8bd2a1edfcfd58">calculateNeighborsBetweenTowers</a> (<a class="el" href="classautopas_1_1internal_1_1ClusterTower.html">internal::ClusterTower</a>&lt; Particle_T &gt; &amp;towerA, <a class="el" href="classautopas_1_1internal_1_1ClusterTower.html">internal::ClusterTower</a>&lt; Particle_T &gt; &amp;towerB)</td></tr>
<tr class="memdesc:a28e627d86745cb8ecf8bd2a1edfcfd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates for all clusters in the given tower:  <br /></td></tr>
<tr class="separator:a28e627d86745cb8ecf8bd2a1edfcfd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd62e234277a128c818607ade6bfc931"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#abd62e234277a128c818607ade6bfc931">getNewton3</a> () const</td></tr>
<tr class="memdesc:abd62e234277a128c818607ade6bfc931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter.  <br /></td></tr>
<tr class="separator:abd62e234277a128c818607ade6bfc931"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Particle_T&gt;<br />
class autopas::internal::VerletClusterListsRebuilder&lt; Particle_T &gt;</div><p>Helper class for rebuilding the <a class="el" href="classautopas_1_1VerletClusterLists.html" title="Particles are divided into clusters.">VerletClusterLists</a> container. </p>
<dl class="section note"><dt>Note</dt><dd>Towers are always built on the xy plane towering into the z dimension.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle_T</td><td>The type of the particle the container contains. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af533a794c556c61aa2ba04748841e4f4" name="af533a794c556c61aa2ba04748841e4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af533a794c556c61aa2ba04748841e4f4">&#9670;&#160;</a></span>VerletClusterListsRebuilder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::VerletClusterListsRebuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1internal_1_1ClusterTowerBlock2D.html">ClusterTowerBlock2D</a>&lt; Particle_T &gt; &amp;&#160;</td>
          <td class="paramname"><em>towerBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Particle_T &gt; &amp;&#160;</td>
          <td class="paramname"><em>particlesToAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#ac488082874949fb5f546906a77a90eb4">NeighborListsBuffer_T</a> &amp;&#160;</td>
          <td class="paramname"><em>neighborListsBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>clusterSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>interactionLengthSqr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newton3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the builder from the cluster list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">towerBlock</td><td>The towers from the cluster list to rebuild. </td></tr>
    <tr><td class="paramname">particlesToAdd</td><td>New particles to add. </td></tr>
    <tr><td class="paramname">neighborListsBuffer</td><td>Buffer structure to hold all neighbor lists. </td></tr>
    <tr><td class="paramname">clusterSize</td><td>Size of the clusters in particles. </td></tr>
    <tr><td class="paramname">interactionLengthSqr</td><td>Squared interaction length (cutoff + skin)^2 </td></tr>
    <tr><td class="paramname">newton3</td><td>If the current configuration uses newton3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a28e627d86745cb8ecf8bd2a1edfcfd58" name="a28e627d86745cb8ecf8bd2a1edfcfd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e627d86745cb8ecf8bd2a1edfcfd58">&#9670;&#160;</a></span>calculateNeighborsBetweenTowers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::calculateNeighborsBetweenTowers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1internal_1_1ClusterTower.html">internal::ClusterTower</a>&lt; Particle_T &gt; &amp;&#160;</td>
          <td class="paramname"><em>towerA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classautopas_1_1internal_1_1ClusterTower.html">internal::ClusterTower</a>&lt; Particle_T &gt; &amp;&#160;</td>
          <td class="paramname"><em>towerB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates for all clusters in the given tower: </p>
<ul>
<li>all neighbor clusters within the interaction length that are contained in the given neighbor tower.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">towerA</td><td>The given tower. </td></tr>
    <tr><td class="paramname">towerB</td><td>The given neighbor tower. contain. If an cluster A interacts with cluster B, then this interaction will either show up only once in the interaction lists of the custers (for newton3 == true) or show up in the interaction lists of both (for newton3 == false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31236b78c5861ca635e88a131b8d9911" name="a31236b78c5861ca635e88a131b8d9911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31236b78c5861ca635e88a131b8d9911">&#9670;&#160;</a></span>collectAllParticlesFromTowers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Particle_T &gt; &gt; <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::collectAllParticlesFromTowers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes all particles from all towers and returns them. </p>
<p>Towers are cleared afterwards. </p><dl class="section return"><dt>Returns</dt><dd>All particles in the container sorted in 2D as they were in the towers. </dd></dl>

</div>
</div>
<a id="a7e00e1f262e029c7f17b1f446a62b2ee" name="a7e00e1f262e029c7f17b1f446a62b2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e00e1f262e029c7f17b1f446a62b2ee">&#9670;&#160;</a></span>collectOutOfBoundsParticlesFromTowers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; Particle_T &gt; &gt; <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::collectOutOfBoundsParticlesFromTowers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all particles that are stored in the wrong towers. </p>
<p>The particles are deleted from their towers.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a6bf23f55ab52aca922615f0ef1746c00" name="a6bf23f55ab52aca922615f0ef1746c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf23f55ab52aca922615f0ef1746c00">&#9670;&#160;</a></span>get1DInteractionCellIndexForTower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::get1DInteractionCellIndexForTower </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>towerIndexX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>towerIndexY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of a imagined interaction cell with side length equal the interaction length that contains the given tower. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">towerIndexX</td><td>The x index of the given tower. </td></tr>
    <tr><td class="paramname">towerIndexY</td><td>The y index of the given tower. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the interaction cell containing the given tower. </dd></dl>

</div>
</div>
<a id="abd62e234277a128c818607ade6bfc931" name="abd62e234277a128c818607ade6bfc931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd62e234277a128c818607ade6bfc931">&#9670;&#160;</a></span>getNewton3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::getNewton3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7155f3775efa53e7cdeae8741030a19e" name="a7155f3775efa53e7cdeae8741030a19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7155f3775efa53e7cdeae8741030a19e">&#9670;&#160;</a></span>isForwardNeighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::isForwardNeighbor </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>towerIndexX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>towerIndexY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>neighborIndexX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>neighborIndexY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decides if a given neighbor tower is a forward neighbor to a given tower. </p>
<p>A forward neighbor is either in a interaction cell with a higher index or in the same interaction cell with a higher tower index.</p>
<p>Helps the <a class="el" href="classautopas_1_1VCLC06Traversal.html" title="A traversal for VerletClusterLists that uses a coloring over the grids of the container.">VCLC06Traversal</a> to have no data races.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">towerIndexX</td><td>The x-index of the given tower. </td></tr>
    <tr><td class="paramname">towerIndexY</td><td>The y-index of the given tower. </td></tr>
    <tr><td class="paramname">neighborIndexX</td><td>The x-index of the given neighbor tower. </td></tr>
    <tr><td class="paramname">neighborIndexY</td><td>The y-index of the given neighbor tower. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if neighbor is a forward neighbor of tower. </dd></dl>

</div>
</div>
<a id="a46910e03c79fc95ee5c8796fb70df513" name="a46910e03c79fc95ee5c8796fb70df513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46910e03c79fc95ee5c8796fb70df513">&#9670;&#160;</a></span>iterateNeighborTowers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;class FunType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::iterateNeighborTowers </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>towerIndexX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>towerIndexY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>minNeighborIndexX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxNeighborIndexX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>minNeighborIndexY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxNeighborIndexY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunType&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For all clusters in a tower, given by it's x/y indices, find all neighbors in towers that are given by an area (min/max x/y neighbor indices). </p>
<p>With the useNewton3 parameter, the lists can be either built containing all, or only the forward neighbors. If an cluster A interacts with cluster B, then this interaction will either show up only once in the interaction lists of the custers (for newton3 == true) or show up in the interaction lists of both (for newton3 == false)</p>
<dl class="section note"><dt>Note</dt><dd>_newton3 Specifies, whether neighbor lists should contain only forward neighbors.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunType</td><td>type of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">towerIndexX</td><td>The x index of the given tower. </td></tr>
    <tr><td class="paramname">towerIndexY</td><td>The y index of the given tower. </td></tr>
    <tr><td class="paramname">minNeighborIndexX</td><td>The minimum neighbor tower index in x direction. </td></tr>
    <tr><td class="paramname">maxNeighborIndexX</td><td>The maximum neighbor tower index in x direction. </td></tr>
    <tr><td class="paramname">minNeighborIndexY</td><td>The minimum neighbor tower index in y direction. </td></tr>
    <tr><td class="paramname">maxNeighborIndexY</td><td>The maximum neighbor tower index in y direction. </td></tr>
    <tr><td class="paramname">function</td><td>Function to apply on every neighbor tower. Typically this is <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html#a28e627d86745cb8ecf8bd2a1edfcfd58" title="Calculates for all clusters in the given tower:">calculateNeighborsBetweenTowers()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b6aef88f42741fcf1e32c14fd2741b0" name="a9b6aef88f42741fcf1e32c14fd2741b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6aef88f42741fcf1e32c14fd2741b0">&#9670;&#160;</a></span>rebuildNeighborListsAndFillClusters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::rebuildNeighborListsAndFillClusters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rebuilds the neighbor lists and fills Clusters with dummies as described in <a class="el" href="classautopas_1_1internal_1_1ClusterTower.html#af0408295bcd6ea827c1375327817a45c" title="Replaces the copies of the last particle made in generateClusters() with dummies.">ClusterTower::setDummyValues</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Here, _newton3 decides, whether neighbor lists should use newton3. This changes what the lists contain. For two interacting clusters A and B, if _newton3 == false, the interaction A-&gt;B is in the list of cluster B, and B-&gt;A is in cluster A. If _newton3 == true, the two-way interaction A&lt;-&gt;B will only be in the cluster that comes first when iterating through towers. </dd></dl>

</div>
</div>
<a id="a9b708ec3fbb9964fb2b363539bfbbb87" name="a9b708ec3fbb9964fb2b363539bfbbb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b708ec3fbb9964fb2b363539bfbbb87">&#9670;&#160;</a></span>rebuildTowersAndClusters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::rebuildTowersAndClusters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rebuilds the towers, sorts the particles into them and creates the clusters with a reference to an uninitialized neighbor list. </p>
<dl class="section return"><dt>Returns</dt><dd>number of clusters </dd></dl>

</div>
</div>
<a id="ad7125a6d2e615ef30a79db2df8d069c5" name="ad7125a6d2e615ef30a79db2df8d069c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7125a6d2e615ef30a79db2df8d069c5">&#9670;&#160;</a></span>sortParticlesIntoTowers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::sortParticlesIntoTowers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Particle_T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>particles2D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts all passed particles in the appropriate clusters. </p>
<dl class="section note"><dt>Note</dt><dd>This Function takes a 2D vector because it expects the layout from the old clusters. The information however, is not utilized hence when in doubt all particles can go in one vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particles2D</td><td>The particles to sort in the towers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2816b0e1981c0609db7997cd86fc60fe" name="a2816b0e1981c0609db7997cd86fc60fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2816b0e1981c0609db7997cd86fc60fe">&#9670;&#160;</a></span>updateNeighborLists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">autopas::internal::VerletClusterListsRebuilder</a>&lt; Particle_T &gt;::updateNeighborLists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the neighbor lists for all clusters. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd>: find sensible chunksize </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autopas/containers/verletClusterLists/<a class="el" href="VerletClusterListsRebuilder_8h_source.html">VerletClusterListsRebuilder.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

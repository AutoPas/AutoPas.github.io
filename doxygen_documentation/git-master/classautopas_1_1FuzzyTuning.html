<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1FuzzyTuning.html">FuzzyTuning</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classautopas_1_1FuzzyTuning-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::FuzzyTuning Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A tuning strategy that uses fuzzy logic to make predictions about the performance of configurations.  
 <a href="classautopas_1_1FuzzyTuning.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FuzzyTuning_8h_source.html">FuzzyTuning.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::FuzzyTuning:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1FuzzyTuning__inherit__graph.png" border="0" usemap="#aautopas_1_1FuzzyTuning_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1FuzzyTuning_inherit__map" id="aautopas_1_1FuzzyTuning_inherit__map">
<area shape="rect" title="A tuning strategy that uses fuzzy logic to make predictions about the performance of configurations." alt="" coords="43,79,205,104"/>
<area shape="rect" href="classautopas_1_1TuningStrategyInterface.html" title="Interface for tuning strategies for the auto tuner." alt="" coords="5,5,243,31"/>
<area shape="poly" title=" " alt="" coords="127,44,127,79,121,79,121,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for autopas::FuzzyTuning:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1FuzzyTuning__coll__graph.png" border="0" usemap="#aautopas_1_1FuzzyTuning_coll__map" alt="Collaboration graph"/></div>
<map name="aautopas_1_1FuzzyTuning_coll__map" id="aautopas_1_1FuzzyTuning_coll__map">
<area shape="rect" title="A tuning strategy that uses fuzzy logic to make predictions about the performance of configurations." alt="" coords="43,79,205,104"/>
<area shape="rect" href="classautopas_1_1TuningStrategyInterface.html" title="Interface for tuning strategies for the auto tuner." alt="" coords="5,5,243,31"/>
<area shape="poly" title=" " alt="" coords="127,44,127,79,121,79,121,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acbba1d2eedb866c497f5c942ffbbdb10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#acbba1d2eedb866c497f5c942ffbbdb10">FuzzyTuning</a> (std::string fuzzyRuleFileName)</td></tr>
<tr class="memdesc:acbba1d2eedb866c497f5c942ffbbdb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="classautopas_1_1FuzzyTuning.html" title="A tuning strategy that uses fuzzy logic to make predictions about the performance of configurations.">FuzzyTuning</a> strategy.  <br /></td></tr>
<tr class="separator:acbba1d2eedb866c497f5c942ffbbdb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a197b4b948180612698ec61489338d3"><td class="memItemLeft" align="right" valign="top">TuningStrategyOption&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#a5a197b4b948180612698ec61489338d3">getOptionType</a> () const override</td></tr>
<tr class="memdesc:a5a197b4b948180612698ec61489338d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this object's associated TuningStrategyOption type.  <br /></td></tr>
<tr class="separator:a5a197b4b948180612698ec61489338d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1855d5f629c894c6a775e99570cc553e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#a1855d5f629c894c6a775e99570cc553e">needsLiveInfo</a> () const override</td></tr>
<tr class="memdesc:a1855d5f629c894c6a775e99570cc553e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tuning strategy wants to get a <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object passed before a new tuning phase.  <br /></td></tr>
<tr class="separator:a1855d5f629c894c6a775e99570cc553e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93c34687f697d2cf373d9b2f6c1313d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#ac93c34687f697d2cf373d9b2f6c1313d">receiveLiveInfo</a> (const <a class="el" href="classautopas_1_1LiveInfo.html">LiveInfo</a> &amp;value) override</td></tr>
<tr class="memdesc:ac93c34687f697d2cf373d9b2f6c1313d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method that subclasses can override to receive the <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object before a tuning phase if they return true in <a class="el" href="classautopas_1_1FuzzyTuning.html#a1855d5f629c894c6a775e99570cc553e" title="Returns whether this tuning strategy wants to get a LiveInfo object passed before a new tuning phase.">needsLiveInfo()</a>.  <br /></td></tr>
<tr class="separator:ac93c34687f697d2cf373d9b2f6c1313d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5db94faadc7d492141edfdf3760b03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#a2a5db94faadc7d492141edfdf3760b03">addEvidence</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;configuration, const <a class="el" href="classautopas_1_1Evidence.html">Evidence</a> &amp;evidence) override</td></tr>
<tr class="memdesc:a2a5db94faadc7d492141edfdf3760b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the strategy about empirically collected information for the given configuration.  <br /></td></tr>
<tr class="separator:a2a5db94faadc7d492141edfdf3760b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74678bc2c624e4687bb3cc7f9b65428"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#ac74678bc2c624e4687bb3cc7f9b65428">reset</a> (size_t iteration, size_t tuningPhase, std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">autopas::EvidenceCollection</a> &amp;evidenceCollection) override</td></tr>
<tr class="memdesc:ac74678bc2c624e4687bb3cc7f9b65428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all internal parameters to the beginning of a new tuning phase.  <br /></td></tr>
<tr class="separator:ac74678bc2c624e4687bb3cc7f9b65428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396d833a8b02b54651f008318972bbd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#a396d833a8b02b54651f008318972bbd6">optimizeSuggestions</a> (std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp;evidenceCollection) override</td></tr>
<tr class="memdesc:a396d833a8b02b54651f008318972bbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes the queue of configurations to process.  <br /></td></tr>
<tr class="separator:a396d833a8b02b54651f008318972bbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadd47542af3e33e3f9e70d033e3b41a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespaceautopas_1_1FuzzyLogic.html#aa8d192a1eda130b06c55648068cd8f0d">FuzzyControlSettings</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#aaadd47542af3e33e3f9e70d033e3b41a">getFuzzyControlSettings</a> () const</td></tr>
<tr class="memdesc:aaadd47542af3e33e3f9e70d033e3b41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the fuzzy control settings.  <br /></td></tr>
<tr class="separator:aaadd47542af3e33e3f9e70d033e3b41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4363c426c8e6b68d6f53df6396f51bd3"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classautopas_1_1FuzzyLogic_1_1FuzzyControlSystem.html">FuzzyControlSystem</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#a4363c426c8e6b68d6f53df6396f51bd3">getFuzzyControlSystems</a> () const</td></tr>
<tr class="memdesc:a4363c426c8e6b68d6f53df6396f51bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the fuzzy control systems.  <br /></td></tr>
<tr class="separator:a4363c426c8e6b68d6f53df6396f51bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e524c09fdcd6dbcdf777053108f8b0"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classautopas_1_1FuzzyLogic_1_1OutputMapper.html">OutputMapper</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1FuzzyTuning.html#a23e524c09fdcd6dbcdf777053108f8b0">getOutputMappings</a> () const</td></tr>
<tr class="memdesc:a23e524c09fdcd6dbcdf777053108f8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the output mappings.  <br /></td></tr>
<tr class="separator:a23e524c09fdcd6dbcdf777053108f8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1TuningStrategyInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1TuningStrategyInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1TuningStrategyInterface.html">autopas::TuningStrategyInterface</a></td></tr>
<tr class="memitem:a02d304fb2f47fc32d2662803323fb8b9 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual TuningStrategyOption&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a02d304fb2f47fc32d2662803323fb8b9">getOptionType</a> () const =0</td></tr>
<tr class="memdesc:a02d304fb2f47fc32d2662803323fb8b9 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this object's associated TuningStrategyOption type.  <br /></td></tr>
<tr class="separator:a02d304fb2f47fc32d2662803323fb8b9 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2e11a52988f7c4d67eccf353335b61 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a0e2e11a52988f7c4d67eccf353335b61">addEvidence</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;configuration, const <a class="el" href="classautopas_1_1Evidence.html">Evidence</a> &amp;evidence)</td></tr>
<tr class="memdesc:a0e2e11a52988f7c4d67eccf353335b61 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the strategy about empirically collected information for the given configuration.  <br /></td></tr>
<tr class="separator:a0e2e11a52988f7c4d67eccf353335b61 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f4d28b36da3543a4766c559563a154 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a16f4d28b36da3543a4766c559563a154">optimizeSuggestions</a> (std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp;evidenceCollection)=0</td></tr>
<tr class="memdesc:a16f4d28b36da3543a4766c559563a154 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes the queue of configurations to process.  <br /></td></tr>
<tr class="separator:a16f4d28b36da3543a4766c559563a154 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7334920b6ed59a03f6b42b1a73816d4b inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7334920b6ed59a03f6b42b1a73816d4b">reset</a> (size_t iteration, size_t tuningPhase, std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">autopas::EvidenceCollection</a> &amp;evidenceCollection)=0</td></tr>
<tr class="memdesc:a7334920b6ed59a03f6b42b1a73816d4b inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all internal parameters to the beginning of a new tuning phase.  <br /></td></tr>
<tr class="separator:a7334920b6ed59a03f6b42b1a73816d4b inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0bc535436e8aa6a8b25b6f1b50b5e2 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7c0bc535436e8aa6a8b25b6f1b50b5e2">needsLiveInfo</a> () const</td></tr>
<tr class="memdesc:a7c0bc535436e8aa6a8b25b6f1b50b5e2 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tuning strategy wants to get a <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object passed before a new tuning phase.  <br /></td></tr>
<tr class="separator:a7c0bc535436e8aa6a8b25b6f1b50b5e2 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb1ba7e258aa647bc0a442a1982f8f8 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a9cb1ba7e258aa647bc0a442a1982f8f8">receiveLiveInfo</a> (const <a class="el" href="classautopas_1_1LiveInfo.html">LiveInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a9cb1ba7e258aa647bc0a442a1982f8f8 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method that subclasses can override to receive the <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object before a tuning phase if they return true in <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7c0bc535436e8aa6a8b25b6f1b50b5e2" title="Returns whether this tuning strategy wants to get a LiveInfo object passed before a new tuning phase.">needsLiveInfo()</a>.  <br /></td></tr>
<tr class="separator:a9cb1ba7e258aa647bc0a442a1982f8f8 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc2e5b8444200e7429fd7dd457fc13f inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a3cc2e5b8444200e7429fd7dd457fc13f">rejectConfiguration</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;configuration, bool indefinitely)</td></tr>
<tr class="memdesc:a3cc2e5b8444200e7429fd7dd457fc13f inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the strategy about a configuration that is (currently) invalid and thus can potentially be dropped from some internal storage.  <br /></td></tr>
<tr class="separator:a3cc2e5b8444200e7429fd7dd457fc13f inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4113e4b9e6e136507cc81c11e07d3b8 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#ad4113e4b9e6e136507cc81c11e07d3b8">needsDomainSimilarityStatistics</a> () const</td></tr>
<tr class="memdesc:ad4113e4b9e6e136507cc81c11e07d3b8 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether the strategy needs domain similarity statistics.  <br /></td></tr>
<tr class="separator:ad4113e4b9e6e136507cc81c11e07d3b8 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f0a26dfbe989630aa8ec8354973e00 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a62f0a26dfbe989630aa8ec8354973e00">receiveDomainSimilarityStatistics</a> (double pdBinStdDevDensity, double pdBinMaxDensity)</td></tr>
<tr class="memdesc:a62f0a26dfbe989630aa8ec8354973e00 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to pass smoothed domain similarity statistics (particle-dependent bin standard deviation in density and max density) to the tuning strategy.  <br /></td></tr>
<tr class="separator:a62f0a26dfbe989630aa8ec8354973e00 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A tuning strategy that uses fuzzy logic to make predictions about the performance of configurations. </p>
<p>The goal of this tuning strategy is to allow expert users to encode their knowledge about the performance of different configurations in a rule file and use this knowledge to let a FuzzyControlSystem combine all this information to make predictions about the optimal configuration for the current simulation state.</p>
<p>Similar to the <a class="el" href="classautopas_1_1RuleBasedTuning.html" title="A tuning strategy that uses information collected live from the domain to exclude configurations that...">RuleBasedTuning</a> strategy, the "knowledge" is encoded in a rule file consisting of 4 parts:</p><ul>
<li><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceautopas_1_1FuzzyLogic.html#aa8d192a1eda130b06c55648068cd8f0d" title="The settings of a FuzzyControlSystem are a map of key-value pairs.">FuzzyControlSettings</a>: Defines the settings of all FuzzyControlSystems.</dd></dl>
</li>
<li><dl class="section see"><dt>See also</dt><dd>LinguisticVariable: Define the input and output variables of the fuzzy control system. Can be chosen mostly arbitrarily the only limitation is that currently all input variables of the Systems must be defined over components of the </dd>
<dd>
<a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> struct. All the currently implemented membership functions can be looked up at </dd>
<dd>
FuzzySetFactory.</dd></dl>
</li>
<li><dl class="section see"><dt>See also</dt><dd>OutputMapper: Maps the output of the fuzzy control systems to a configuration suitable for <a class="el" href="namespaceautopas.html" title="This is the main namespace of AutoPas.">autopas</a>. This is necessary because the fuzzy control systems are functions $f: R^n -&gt; R$ and we need to map the output value to a configuration. At the moment, this is done by specifying a bunch of possible </dd>
<dd>
<a class="el" href="classautopas_1_1Configuration.html" title="Class containing multiple options that form an algorithm configuration for the pairwise iteration.">Configuration</a> at specific output values. The FuzzyControlSystem will then choose the configuration lying closest to the predicted output value.</dd></dl>
</li>
<li><dl class="section see"><dt>See also</dt><dd>FuzzyRule: Define the rules that the fuzzy control system should follow.</dd></dl>
All those options are defined by the user in a domain specific language, formally described in FuzzyLanguage.g4, which is parsed with the help of antlr4. The rules are loaded once at the start of the simulation.</li>
</ul>
<p><b>Summary of the Fuzzy Language:</b></p>
<p>This is a small example of how a typical rule file could look like: </p><div class="fragment"><div class="line"><span class="preprocessor"># Define the settings of the fuzzy control system</span></div>
<div class="line">FuzzySystemSettings:</div>
<div class="line">     defuzzificationMethod: <span class="stringliteral">&quot;MeanOfMaximum&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Define all of the linguistic variables together with their linguistic terms</span></div>
<div class="line">FuzzyVariable: domain: <span class="stringliteral">&quot;homogeneity&quot;</span> range: (-0.009, 0.1486)</div>
<div class="line">     <span class="stringliteral">&quot;lower than 0.049&quot;</span>:     SigmoidFinite(0.0914, 0.049, 0.0065)</div>
<div class="line">     <span class="stringliteral">&quot;lower than 0.041&quot;</span>:     SigmoidFinite(0.0834, 0.041, -0.001)</div>
<div class="line">     <span class="stringliteral">&quot;higher than 0.049&quot;</span>:    SigmoidFinite(0.0065, 0.049, 0.0914)</div>
<div class="line">     <span class="stringliteral">&quot;higher than 0.041&quot;</span>:    SigmoidFinite(-0.001, 0.041, 0.0834)</div>
<div class="line"> </div>
<div class="line">FuzzyVariable: domain: <span class="stringliteral">&quot;threadCount&quot;</span> range: (-19.938, 48.938)</div>
<div class="line">     <span class="stringliteral">&quot;lower than 18.0&quot;</span>:      SigmoidFinite(38.938, 18.0,  -2.938)</div>
<div class="line">     <span class="stringliteral">&quot;lower than 26.0&quot;</span>:      SigmoidFinite(46.938, 26.0,   5.061)</div>
<div class="line">     <span class="stringliteral">&quot;lower than 8.0&quot;</span>:       SigmoidFinite(28.938,  8.0, -12.938)</div>
<div class="line">     <span class="stringliteral">&quot;higher than 18.0&quot;</span>:     SigmoidFinite(-2.938, 18.0,  38.938)</div>
<div class="line">     <span class="stringliteral">&quot;higher than 26.0&quot;</span>:     SigmoidFinite(5.0617, 26.0,  46.938)</div>
<div class="line">     <span class="stringliteral">&quot;higher than 8.0&quot;</span>:      SigmoidFinite(-12.93,  8.0,  28.938)</div>
<div class="line"> </div>
<div class="line">FuzzyVariable: domain: <span class="stringliteral">&quot;particlesPerCellStdDev&quot;</span> range: (-0.017, 0.072)</div>
<div class="line">     <span class="stringliteral">&quot;lower than 0.013&quot;</span>:     SigmoidFinite(0.0639, 0.038,  0.012)</div>
<div class="line">     <span class="stringliteral">&quot;lower than 0.014&quot;</span>:     SigmoidFinite(0.0399, 0.014, -0.011)</div>
<div class="line">     <span class="stringliteral">&quot;higher than 0.013&quot;</span>:    SigmoidFinite(0.012,  0.013,  0.0639)</div>
<div class="line">     <span class="stringliteral">&quot;higher than 0.014&quot;</span>:    SigmoidFinite(-0.011, 0.014,  0.0399)</div>
<div class="line"> </div>
<div class="line">FuzzyVariable: domain: <span class="stringliteral">&quot;Newton 3&quot;</span> range: (0, 1)</div>
<div class="line">      <span class="stringliteral">&quot;disabled, enabled&quot;</span>:   Gaussian(0.3333, 0.1667)</div>
<div class="line">      <span class="stringliteral">&quot;enabled&quot;</span>:             Gaussian(0.6667, 0.1667)</div>
<div class="line"> </div>
<div class="line"># Define how the result of the output variables should be interpreted in the context of <a class="code hl_namespace" href="namespaceautopas.html">autopas</a></div>
<div class="line">OutputMapping:</div>
<div class="line"> <span class="stringliteral">&quot;Newton 3&quot;</span>:</div>
<div class="line">     0.333 =&gt; [newton3=<span class="stringliteral">&quot;disabled&quot;</span>], [newton3=<span class="stringliteral">&quot;enabled&quot;</span>]</div>
<div class="line">     0.666 =&gt; [newton3=<span class="stringliteral">&quot;enabled&quot;</span>]</div>
<div class="line"> </div>
<div class="line"># Define a bunch of rules connecting the input variables to the output variables</div>
<div class="line">if (<span class="stringliteral">&quot;threadCount&quot;</span> == <span class="stringliteral">&quot;lower than 18.0&quot;</span>) &amp;&amp; (<span class="stringliteral">&quot;threadCount&quot;</span> == <span class="stringliteral">&quot;higher than 8.0&quot;</span>)</div>
<div class="line">    &amp;&amp; (<span class="stringliteral">&quot;homogeneity&quot;</span> == <span class="stringliteral">&quot;lower than 0.041&quot;</span>)</div>
<div class="line">  then (<span class="stringliteral">&quot;Newton 3&quot;</span> == <span class="stringliteral">&quot;enabled&quot;</span>)</div>
<div class="line">if (<span class="stringliteral">&quot;threadCount&quot;</span> == <span class="stringliteral">&quot;higher than 26.0&quot;</span>) &amp;&amp; (<span class="stringliteral">&quot;particlesPerCellStdDev&quot;</span> == <span class="stringliteral">&quot;lower than 0.013&quot;</span>)</div>
<div class="line">  then (<span class="stringliteral">&quot;Newton 3&quot;</span> == <span class="stringliteral">&quot;disabled, enabled&quot;</span>)</div>
<div class="line">...</div>
<div class="ttc" id="anamespaceautopas_html"><div class="ttname"><a href="namespaceautopas.html">autopas</a></div><div class="ttdoc">This is the main namespace of AutoPas.</div><div class="ttdef"><b>Definition:</b> AutoPasDecl.h:32</div></div>
</div><!-- fragment --><p>A larger example file is stored in /examples/md-flexible/input/fuzzyRules.frule.</p>
<p>Due to the compilation cost of ANTLR and issues with compiling the bundled dependency uuid on some machines, this tuning strategy can be disabled with the CMake option AUTOPAS_ENABLE_RULES_BASED_AND_FUZZY_TUNING=OFF. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acbba1d2eedb866c497f5c942ffbbdb10" name="acbba1d2eedb866c497f5c942ffbbdb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbba1d2eedb866c497f5c942ffbbdb10">&#9670;&#160;</a></span>FuzzyTuning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">autopas::FuzzyTuning::FuzzyTuning </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fuzzyRuleFileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="classautopas_1_1FuzzyTuning.html" title="A tuning strategy that uses fuzzy logic to make predictions about the performance of configurations.">FuzzyTuning</a> strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fuzzyRuleFileName</td><td>The path of the fuzzy rule file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2a5db94faadc7d492141edfdf3760b03" name="a2a5db94faadc7d492141edfdf3760b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5db94faadc7d492141edfdf3760b03">&#9670;&#160;</a></span>addEvidence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::FuzzyTuning::addEvidence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1Evidence.html">Evidence</a> &amp;&#160;</td>
          <td class="paramname"><em>evidence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the strategy about empirically collected information for the given configuration. </p>
<p>All evidence is stored centrally in the <a class="el" href="classautopas_1_1AutoTuner.html" title="This class manages all logic related to the auto tuning mechanic.">AutoTuner</a> and its <a class="el" href="classautopas_1_1EvidenceCollection.html" title="Class to manage all evidence.">EvidenceCollection</a> is passed to the tuning strategies during optimization.</p>
<p>Implementing this function is only necessary if the tuning strategy processes evidence differently than <a class="el" href="classautopas_1_1EvidenceCollection.html" title="Class to manage all evidence.">EvidenceCollection</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configuration</td><td><a class="el" href="classautopas_1_1Configuration.html" title="Class containing multiple options that form an algorithm configuration for the pairwise iteration.">Configuration</a> used to obtain the evidence. </td></tr>
    <tr><td class="paramname">evidence</td><td>Measurement and when it was taken. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a0e2e11a52988f7c4d67eccf353335b61">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="aaadd47542af3e33e3f9e70d033e3b41a" name="aaadd47542af3e33e3f9e70d033e3b41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadd47542af3e33e3f9e70d033e3b41a">&#9670;&#160;</a></span>getFuzzyControlSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="namespaceautopas_1_1FuzzyLogic.html#aa8d192a1eda130b06c55648068cd8f0d">FuzzyControlSettings</a> &gt; autopas::FuzzyTuning::getFuzzyControlSettings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the fuzzy control settings. </p>
<dl class="section return"><dt>Returns</dt><dd>The fuzzy control settings. </dd></dl>

</div>
</div>
<a id="a4363c426c8e6b68d6f53df6396f51bd3" name="a4363c426c8e6b68d6f53df6396f51bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4363c426c8e6b68d6f53df6396f51bd3">&#9670;&#160;</a></span>getFuzzyControlSystems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classautopas_1_1FuzzyLogic_1_1FuzzyControlSystem.html">FuzzyControlSystem</a> &gt; &gt; &amp; autopas::FuzzyTuning::getFuzzyControlSystems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the fuzzy control systems. </p>
<dl class="section return"><dt>Returns</dt><dd>The fuzzy control systems. </dd></dl>

</div>
</div>
<a id="a5a197b4b948180612698ec61489338d3" name="a5a197b4b948180612698ec61489338d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a197b4b948180612698ec61489338d3">&#9670;&#160;</a></span>getOptionType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TuningStrategyOption autopas::FuzzyTuning::getOptionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get this object's associated TuningStrategyOption type. </p>
<dl class="section return"><dt>Returns</dt><dd>TuningStrategyOption </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a02d304fb2f47fc32d2662803323fb8b9">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="a23e524c09fdcd6dbcdf777053108f8b0" name="a23e524c09fdcd6dbcdf777053108f8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e524c09fdcd6dbcdf777053108f8b0">&#9670;&#160;</a></span>getOutputMappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classautopas_1_1FuzzyLogic_1_1OutputMapper.html">OutputMapper</a> &gt; &gt; &amp; autopas::FuzzyTuning::getOutputMappings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the output mappings. </p>
<dl class="section return"><dt>Returns</dt><dd>The output mappings. </dd></dl>

</div>
</div>
<a id="a1855d5f629c894c6a775e99570cc553e" name="a1855d5f629c894c6a775e99570cc553e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1855d5f629c894c6a775e99570cc553e">&#9670;&#160;</a></span>needsLiveInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::FuzzyTuning::needsLiveInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this tuning strategy wants to get a <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object passed before a new tuning phase. </p>
<dl class="section return"><dt>Returns</dt><dd>True, if this tuning strategy wants a <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object passed before a new tuning phase via <a class="el" href="classautopas_1_1FuzzyTuning.html#ac93c34687f697d2cf373d9b2f6c1313d" title="Virtual method that subclasses can override to receive the LiveInfo object before a tuning phase if t...">receiveLiveInfo()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7c0bc535436e8aa6a8b25b6f1b50b5e2">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="a396d833a8b02b54651f008318972bbd6" name="a396d833a8b02b54651f008318972bbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396d833a8b02b54651f008318972bbd6">&#9670;&#160;</a></span>optimizeSuggestions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::FuzzyTuning::optimizeSuggestions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>evidenceCollection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimizes the queue of configurations to process. </p>
<p>This function is called once before each iteration in a tuning phase so all tuning strategies can give their input on which configuration to try next. This is done by reordering configQueue so that the next configuration to try is at the end (FIFO).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configQueue</td><td>Queue of configurations to be tested. The tuning strategy should edit this queue. </td></tr>
    <tr><td class="paramname">evidenceCollection</td><td>All collected evidence until now. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean value to signal if the tuning strategy has intentionally wiped the config queue </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a16f4d28b36da3543a4766c559563a154">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="ac93c34687f697d2cf373d9b2f6c1313d" name="ac93c34687f697d2cf373d9b2f6c1313d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93c34687f697d2cf373d9b2f6c1313d">&#9670;&#160;</a></span>receiveLiveInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::FuzzyTuning::receiveLiveInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1LiveInfo.html">LiveInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method that subclasses can override to receive the <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object before a tuning phase if they return true in <a class="el" href="classautopas_1_1FuzzyTuning.html#a1855d5f629c894c6a775e99570cc553e" title="Returns whether this tuning strategy wants to get a LiveInfo object passed before a new tuning phase.">needsLiveInfo()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A new <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object that has already gathered its information. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a9cb1ba7e258aa647bc0a442a1982f8f8">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="ac74678bc2c624e4687bb3cc7f9b65428" name="ac74678bc2c624e4687bb3cc7f9b65428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74678bc2c624e4687bb3cc7f9b65428">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::FuzzyTuning::reset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tuningPhase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1EvidenceCollection.html">autopas::EvidenceCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>evidenceCollection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all internal parameters to the beginning of a new tuning phase. </p>
<p>This can also mean to reorder the configQueue to some initially expected state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iteration</td><td>Gives the current iteration to the tuning strategy. </td></tr>
    <tr><td class="paramname">tuningPhase</td><td>Gives the current tuning phase to the tuning strategy. </td></tr>
    <tr><td class="paramname">configQueue</td><td>Queue of configurations to be tested. The tuning strategy should edit this queue. </td></tr>
    <tr><td class="paramname">evidenceCollection</td><td>All collected evidence until now. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean value to signal if the tuning strategy has intentionally wiped the config queue </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7334920b6ed59a03f6b42b1a73816d4b">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>autopas/tuning/tuningStrategy/fuzzyTuning/<a class="el" href="FuzzyTuning_8h_source.html">FuzzyTuning.h</a></li>
<li>autopas/tuning/tuningStrategy/fuzzyTuning/<a class="el" href="FuzzyTuning_8cpp.html">FuzzyTuning.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

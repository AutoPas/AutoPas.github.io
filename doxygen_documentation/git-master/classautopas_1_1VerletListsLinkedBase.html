<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html">VerletListsLinkedBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classautopas_1_1VerletListsLinkedBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::VerletListsLinkedBase&lt; Particle_T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class for Verlet lists which use an underlying linked cells container.  
 <a href="classautopas_1_1VerletListsLinkedBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VerletListsLinkedBase_8h_source.html">VerletListsLinkedBase.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::VerletListsLinkedBase&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1VerletListsLinkedBase__inherit__graph.png" border="0" usemap="#aautopas_1_1VerletListsLinkedBase_3_01Particle__T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1VerletListsLinkedBase_3_01Particle__T_01_4_inherit__map" id="aautopas_1_1VerletListsLinkedBase_3_01Particle__T_01_4_inherit__map">
<area shape="rect" title="Base class for Verlet lists which use an underlying linked cells container." alt="" coords="247,69,439,109"/>
<area shape="rect" href="classautopas_1_1VarVerletLists.html" title="Variable Verlet Lists container with different neighbor lists." alt="" coords="487,5,692,45"/>
<area shape="poly" title=" " alt="" coords="433,63,511,43,512,48,434,68"/>
<area shape="rect" href="classautopas_1_1VerletLists.html" title="Verlet Lists container." alt="" coords="514,69,665,109"/>
<area shape="poly" title=" " alt="" coords="452,87,514,87,514,92,452,92"/>
<area shape="rect" href="classautopas_1_1VerletListsCells.html" title="Linked Cells with Verlet Lists container." alt="" coords="487,133,692,173"/>
<area shape="poly" title=" " alt="" coords="434,110,512,131,511,136,433,115"/>
<area shape="rect" href="classautopas_1_1ParticleContainerInterface.html" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas." alt="" coords="5,69,199,109"/>
<area shape="poly" title=" " alt="" coords="212,87,247,87,247,92,212,92"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for autopas::VerletListsLinkedBase&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1VerletListsLinkedBase__coll__graph.png" border="0" usemap="#aautopas_1_1VerletListsLinkedBase_3_01Particle__T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aautopas_1_1VerletListsLinkedBase_3_01Particle__T_01_4_coll__map" id="aautopas_1_1VerletListsLinkedBase_3_01Particle__T_01_4_coll__map">
<area shape="rect" title="Base class for Verlet lists which use an underlying linked cells container." alt="" coords="6,93,198,133"/>
<area shape="rect" href="classautopas_1_1ParticleContainerInterface.html" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas." alt="" coords="5,5,199,45"/>
<area shape="poly" title=" " alt="" coords="105,59,105,93,99,93,99,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a238710c589e2afea91b4501180acf37c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a238710c589e2afea91b4501180acf37c">VerletListsLinkedBase</a> (const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax, const double cutoff, const double skin, const unsigned int rebuildFrequency, const std::set&lt; TraversalOption &gt; &amp;applicableTraversals, const double cellSizeFactor)</td></tr>
<tr class="memdesc:a238710c589e2afea91b4501180acf37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="classautopas_1_1VerletListsLinkedBase.html" title="Base class for Verlet lists which use an underlying linked cells container.">VerletListsLinkedBase</a> class.  <br /></td></tr>
<tr class="separator:a238710c589e2afea91b4501180acf37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974aab62504f7d59f377730e85abb9df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a974aab62504f7d59f377730e85abb9df">getParticleCellTypeEnum</a> () const override</td></tr>
<tr class="memdesc:a974aab62504f7d59f377730e85abb9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an Enum.    <br /></td></tr>
<tr class="separator:a974aab62504f7d59f377730e85abb9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438c1ea993ac393d3702d719ff9e5a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a438c1ea993ac393d3702d719ff9e5a57">setStepsSinceLastRebuild</a> (size_t stepsSinceLastRebuild) override</td></tr>
<tr class="memdesc:a438c1ea993ac393d3702d719ff9e5a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of time-steps since last neighbor list rebuild.  <br /></td></tr>
<tr class="separator:a438c1ea993ac393d3702d719ff9e5a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e51b15eb241ff31812f23a25a897c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a23e51b15eb241ff31812f23a25a897c8">reserve</a> (size_t numParticles, size_t numParticlesHaloEstimate) override</td></tr>
<tr class="memdesc:a23e51b15eb241ff31812f23a25a897c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for a given number of particles in the container and logic layers.    <br /></td></tr>
<tr class="separator:a23e51b15eb241ff31812f23a25a897c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11455d1e7ae1481c5156df4673e4d2a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a11455d1e7ae1481c5156df4673e4d2a5">addParticleImpl</a> (const Particle_T &amp;p) override</td></tr>
<tr class="memdesc:a11455d1e7ae1481c5156df4673e4d2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container.    <br /></td></tr>
<tr class="separator:a11455d1e7ae1481c5156df4673e4d2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92378034166971d86bd4f43b29dfcc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#af92378034166971d86bd4f43b29dfcc0">addHaloParticleImpl</a> (const Particle_T &amp;haloParticle) override</td></tr>
<tr class="memdesc:af92378034166971d86bd4f43b29dfcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container that lies in the halo region of the container.    <br /></td></tr>
<tr class="separator:af92378034166971d86bd4f43b29dfcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1c2b716ee825291cdac79e4392f08e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aff1c2b716ee825291cdac79e4392f08e">size</a> () const override</td></tr>
<tr class="memdesc:aff1c2b716ee825291cdac79e4392f08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of particles saved in the container (owned + halo + dummy).    <br /></td></tr>
<tr class="separator:aff1c2b716ee825291cdac79e4392f08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d3898b5f634391c4fd8b523ac556a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a74d3898b5f634391c4fd8b523ac556a9">getNumberOfParticles</a> (IteratorBehavior behavior) const override</td></tr>
<tr class="memdesc:a74d3898b5f634391c4fd8b523ac556a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.    <br /></td></tr>
<tr class="separator:a74d3898b5f634391c4fd8b523ac556a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc31f20163c4af0a3336e51e58caa5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aedc31f20163c4af0a3336e51e58caa5e">deleteHaloParticles</a> () override</td></tr>
<tr class="memdesc:aedc31f20163c4af0a3336e51e58caa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all halo particles.    <br /></td></tr>
<tr class="separator:aedc31f20163c4af0a3336e51e58caa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a141094f03b5d65c271d3d8ef3ad516"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a4a141094f03b5d65c271d3d8ef3ad516">deleteAllParticles</a> () override</td></tr>
<tr class="memdesc:a4a141094f03b5d65c271d3d8ef3ad516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles.    <br /></td></tr>
<tr class="separator:a4a141094f03b5d65c271d3d8ef3ad516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577e3ded3cb81632145482c25a348f27"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; const Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a577e3ded3cb81632145482c25a348f27">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax) const override</td></tr>
<tr class="memdesc:a577e3ded3cb81632145482c25a348f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.    <br /></td></tr>
<tr class="separator:a577e3ded3cb81632145482c25a348f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52ca7f7f8b33f321b2beb86aa1a314f"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; const Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aa52ca7f7f8b33f321b2beb86aa1a314f">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior) const override</td></tr>
<tr class="memdesc:aa52ca7f7f8b33f321b2beb86aa1a314f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.  <br /></td></tr>
<tr class="separator:aa52ca7f7f8b33f321b2beb86aa1a314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab194aaab36d7454d180299d00d70e7cb"><td class="memTemplParams" colspan="2">template&lt;bool regionIter&gt; </td></tr>
<tr class="memitem:ab194aaab36d7454d180299d00d70e7cb"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; const Particle_T *, size_t, size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#ab194aaab36d7454d180299d00d70e7cb">getParticleImpl</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax) const</td></tr>
<tr class="memdesc:ab194aaab36d7454d180299d00d70e7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container specific implementation for getParticle.  <br /></td></tr>
<tr class="separator:ab194aaab36d7454d180299d00d70e7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92984f356e0834768bff7349acea46d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a92984f356e0834768bff7349acea46d7">deleteParticle</a> (Particle_T &amp;particle) override</td></tr>
<tr class="memdesc:a92984f356e0834768bff7349acea46d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the given particle as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:a92984f356e0834768bff7349acea46d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee248cab15b26a33b9ae714bbd0a1674"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aee248cab15b26a33b9ae714bbd0a1674">deleteParticle</a> (size_t cellIndex, size_t particleIndex) override</td></tr>
<tr class="memdesc:aee248cab15b26a33b9ae714bbd0a1674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the particle at the given index positions as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:aee248cab15b26a33b9ae714bbd0a1674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f4a2bd710e07a891dbc6342b8fcd58"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Particle_T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a95f4a2bd710e07a891dbc6342b8fcd58">updateContainer</a> (bool keepNeighborListsValid) override</td></tr>
<tr class="memdesc:a95f4a2bd710e07a891dbc6342b8fcd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the container.    <br /></td></tr>
<tr class="separator:a95f4a2bd710e07a891dbc6342b8fcd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0353c0f0a44f84cc1cffffd507bbcb14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a0353c0f0a44f84cc1cffffd507bbcb14">updateHaloParticle</a> (const Particle_T &amp;haloParticle) override</td></tr>
<tr class="memdesc:a0353c0f0a44f84cc1cffffd507bbcb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the provided halo particle and updates the found particle.  <br /></td></tr>
<tr class="separator:a0353c0f0a44f84cc1cffffd507bbcb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420417c2a1b196422288d9f70f2de3a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a420417c2a1b196422288d9f70f2de3a2">begin</a> (IteratorBehavior behavior=IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, false &gt;::ParticleVecType *additionalVectors=nullptr) override</td></tr>
<tr class="memdesc:a420417c2a1b196422288d9f70f2de3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:a420417c2a1b196422288d9f70f2de3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fff9b096403519365ffa59173c34aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a41fff9b096403519365ffa59173c34aa">begin</a> (IteratorBehavior behavior=IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt;::ParticleVecType *additionalVectors=nullptr) const override</td></tr>
<tr class="memdesc:a41fff9b096403519365ffa59173c34aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:a41fff9b096403519365ffa59173c34aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45091e22d5c8b5063ff25d0e3c751d1b"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a45091e22d5c8b5063ff25d0e3c751d1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a45091e22d5c8b5063ff25d0e3c751d1b">forEach</a> (Lambda forEachLambda, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:a45091e22d5c8b5063ff25d0e3c751d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code on all particles in this container as defined by a lambda function.    <br /></td></tr>
<tr class="separator:a45091e22d5c8b5063ff25d0e3c751d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd357376f261d996d793f7b336a1dfb3"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:afd357376f261d996d793f7b336a1dfb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#afd357376f261d996d793f7b336a1dfb3">reduce</a> (Lambda reduceLambda, A &amp;result, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:afd357376f261d996d793f7b336a1dfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce properties of particles as defined by a lambda function.    <br /></td></tr>
<tr class="separator:afd357376f261d996d793f7b336a1dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64f597ee744514f6557d431e155569e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#ab64f597ee744514f6557d431e155569e">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, true &gt;::ParticleVecType *additionalVectors=nullptr) override</td></tr>
<tr class="memdesc:ab64f597ee744514f6557d431e155569e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .    <br /></td></tr>
<tr class="separator:ab64f597ee744514f6557d431e155569e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc54cd5f59d7f777070e10209201f9b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#adc54cd5f59d7f777070e10209201f9b4">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, true &gt;::ParticleVecType *additionalVectors=nullptr) const override</td></tr>
<tr class="memdesc:adc54cd5f59d7f777070e10209201f9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .    <br /></td></tr>
<tr class="separator:adc54cd5f59d7f777070e10209201f9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec9f0daae94def2ba051b1aa7063cb8"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:afec9f0daae94def2ba051b1aa7063cb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#afec9f0daae94def2ba051b1aa7063cb8">forEachInRegion</a> (Lambda forEachLambda, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:afec9f0daae94def2ba051b1aa7063cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code on all particles in this container in a certain region as defined by a lambda function.    <br /></td></tr>
<tr class="separator:afec9f0daae94def2ba051b1aa7063cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4da667424ec1eb61c650713fa8819c6"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:aa4da667424ec1eb61c650713fa8819c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aa4da667424ec1eb61c650713fa8819c6">reduceInRegion</a> (Lambda reduceLambda, A &amp;result, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:aa4da667424ec1eb61c650713fa8819c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code on all particles in this container in a certain region as defined by a lambda function.    <br /></td></tr>
<tr class="separator:aa4da667424ec1eb61c650713fa8819c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c265278a6e7d686d93d65ec4b007d1b"><td class="memItemLeft" align="right" valign="top">const std::array&lt; std::size_t, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a6c265278a6e7d686d93d65ec4b007d1b">getCellsPerDimension</a> () const</td></tr>
<tr class="memdesc:a6c265278a6e7d686d93d65ec4b007d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the used cellblock including the haloboxes.  <br /></td></tr>
<tr class="separator:a6c265278a6e7d686d93d65ec4b007d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae591a76b308677cffc4210c4dac00f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1TraversalSelectorInfo.html">TraversalSelectorInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#ae591a76b308677cffc4210c4dac00f54">getTraversalSelectorInfo</a> () const override</td></tr>
<tr class="memdesc:ae591a76b308677cffc4210c4dac00f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a traversal selector info for this container.  <br /></td></tr>
<tr class="separator:ae591a76b308677cffc4210c4dac00f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934ca3e02ecc49362309596f40b22b5c"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a934ca3e02ecc49362309596f40b22b5c">getBoxMax</a> () const final</td></tr>
<tr class="memdesc:a934ca3e02ecc49362309596f40b22b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the upper corner of the container without halo.    <br /></td></tr>
<tr class="separator:a934ca3e02ecc49362309596f40b22b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56146a17f3339468dda6bd578cf17dd3"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a56146a17f3339468dda6bd578cf17dd3">getBoxMin</a> () const final</td></tr>
<tr class="memdesc:a56146a17f3339468dda6bd578cf17dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lower corner of the container without halo.    <br /></td></tr>
<tr class="separator:a56146a17f3339468dda6bd578cf17dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb42a60779f2587821a50b9de83bc8c6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#afb42a60779f2587821a50b9de83bc8c6">getCutoff</a> () const final</td></tr>
<tr class="memdesc:afb42a60779f2587821a50b9de83bc8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cutoff of the container.    <br /></td></tr>
<tr class="separator:afb42a60779f2587821a50b9de83bc8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908f25f81431b27a0db7c35a89145c65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a908f25f81431b27a0db7c35a89145c65">setCutoff</a> (double cutoff) final</td></tr>
<tr class="memdesc:a908f25f81431b27a0db7c35a89145c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cutoff of the container.    <br /></td></tr>
<tr class="separator:a908f25f81431b27a0db7c35a89145c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e3185f365061ffd949d2af72a2739"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#a774e3185f365061ffd949d2af72a2739">getVerletSkin</a> () const final</td></tr>
<tr class="memdesc:a774e3185f365061ffd949d2af72a2739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the verletSkin of the container verletSkin.    <br /></td></tr>
<tr class="separator:a774e3185f365061ffd949d2af72a2739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4d1ae2a5ae96f88686b7868daa8583"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html#acf4d1ae2a5ae96f88686b7868daa8583">getInteractionLength</a> () const final</td></tr>
<tr class="memdesc:acf4d1ae2a5ae96f88686b7868daa8583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the interaction length (cutoff+skin) of the container.    <br /></td></tr>
<tr class="separator:acf4d1ae2a5ae96f88686b7868daa8583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1ParticleContainerInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1ParticleContainerInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a9f3264b2ea8bbd3b471faf77aca70511 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9f3264b2ea8bbd3b471faf77aca70511">getParticleCellTypeEnum</a> () const =0</td></tr>
<tr class="memdesc:a9f3264b2ea8bbd3b471faf77aca70511 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an Enum.  <br /></td></tr>
<tr class="separator:a9f3264b2ea8bbd3b471faf77aca70511 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a908bc9d3768eae4611816b65265f5 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ad9a908bc9d3768eae4611816b65265f5">ParticleContainerInterface</a> (double skin)</td></tr>
<tr class="memdesc:ad9a908bc9d3768eae4611816b65265f5 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:ad9a908bc9d3768eae4611816b65265f5 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc06b03e7a877579abba7e458f1142b4 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top"><a id="afc06b03e7a877579abba7e458f1142b4" name="afc06b03e7a877579abba7e458f1142b4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ParticleContainerInterface</b> ()=default</td></tr>
<tr class="memdesc:afc06b03e7a877579abba7e458f1142b4 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of <a class="el" href="classautopas_1_1ParticleContainerInterface.html" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas.">ParticleContainerInterface</a>. <br /></td></tr>
<tr class="separator:afc06b03e7a877579abba7e458f1142b4 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7de3c91ce2894734525cd7362ed0050 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ae7de3c91ce2894734525cd7362ed0050">ParticleContainerInterface</a> (const <a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp;obj)=delete</td></tr>
<tr class="memdesc:ae7de3c91ce2894734525cd7362ed0050 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the copy constructor to prevent unwanted copies.  <br /></td></tr>
<tr class="separator:ae7de3c91ce2894734525cd7362ed0050 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116a79a89fac9059da41e2ada2257a3c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a116a79a89fac9059da41e2ada2257a3c">operator=</a> (const <a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a116a79a89fac9059da41e2ada2257a3c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the copy assignment operator to prevent unwanted copies.  <br /></td></tr>
<tr class="separator:a116a79a89fac9059da41e2ada2257a3c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941f6d9f49ee4a45f0ba0ea6bf64fd3c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual ContainerOption&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a941f6d9f49ee4a45f0ba0ea6bf64fd3c">getContainerType</a> () const =0</td></tr>
<tr class="memdesc:a941f6d9f49ee4a45f0ba0ea6bf64fd3c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ContainerType.  <br /></td></tr>
<tr class="separator:a941f6d9f49ee4a45f0ba0ea6bf64fd3c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d65a563cfbdb1828379458db0dfadf inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a81d65a563cfbdb1828379458db0dfadf">reserve</a> (size_t numParticles, size_t numParticlesHaloEstimate)=0</td></tr>
<tr class="memdesc:a81d65a563cfbdb1828379458db0dfadf inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for a given number of particles in the container and logic layers.    <br /></td></tr>
<tr class="separator:a81d65a563cfbdb1828379458db0dfadf inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c350201102d10da0e549435e9b1d99 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memTemplParams" colspan="2">template&lt;bool checkInBox = true&gt; </td></tr>
<tr class="memitem:ab2c350201102d10da0e549435e9b1d99 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab2c350201102d10da0e549435e9b1d99">addParticle</a> (const Particle_T &amp;p)</td></tr>
<tr class="memdesc:ab2c350201102d10da0e549435e9b1d99 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container.  <br /></td></tr>
<tr class="separator:ab2c350201102d10da0e549435e9b1d99 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570ce9e1be3e46cd15135fa965a39bc7 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memTemplParams" colspan="2">template&lt;bool checkInBox = true&gt; </td></tr>
<tr class="memitem:a570ce9e1be3e46cd15135fa965a39bc7 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a570ce9e1be3e46cd15135fa965a39bc7">addHaloParticle</a> (const Particle_T &amp;haloParticle)</td></tr>
<tr class="memdesc:a570ce9e1be3e46cd15135fa965a39bc7 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container that lies in the halo region of the container.  <br /></td></tr>
<tr class="separator:a570ce9e1be3e46cd15135fa965a39bc7 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b43eec590054db74704b88d2d896937 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a7b43eec590054db74704b88d2d896937">updateHaloParticle</a> (const Particle_T &amp;haloParticle)=0</td></tr>
<tr class="memdesc:a7b43eec590054db74704b88d2d896937 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a halo particle of the container with the given haloParticle.  <br /></td></tr>
<tr class="separator:a7b43eec590054db74704b88d2d896937 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a3ffb69099a0917c456e0b844c222b inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a08a3ffb69099a0917c456e0b844c222b">rebuildNeighborLists</a> (<a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *traversal)=0</td></tr>
<tr class="memdesc:a08a3ffb69099a0917c456e0b844c222b inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuilds the neighbor lists for the next traversals.  <br /></td></tr>
<tr class="separator:a08a3ffb69099a0917c456e0b844c222b inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab430b1916311400b6b4108a5596ff8b9 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab430b1916311400b6b4108a5596ff8b9">deleteHaloParticles</a> ()=0</td></tr>
<tr class="memdesc:ab430b1916311400b6b4108a5596ff8b9 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all halo particles.  <br /></td></tr>
<tr class="separator:ab430b1916311400b6b4108a5596ff8b9 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740fc3a18464478bffd53abadcf9071d inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a740fc3a18464478bffd53abadcf9071d">deleteAllParticles</a> ()=0</td></tr>
<tr class="memdesc:a740fc3a18464478bffd53abadcf9071d inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles.  <br /></td></tr>
<tr class="separator:a740fc3a18464478bffd53abadcf9071d inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cffaa132a5ef9d1f8fc72845bfc81f inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a74cffaa132a5ef9d1f8fc72845bfc81f">getNumberOfParticles</a> (IteratorBehavior behavior=IteratorBehavior::owned) const =0</td></tr>
<tr class="memdesc:a74cffaa132a5ef9d1f8fc72845bfc81f inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.  <br /></td></tr>
<tr class="separator:a74cffaa132a5ef9d1f8fc72845bfc81f inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4c790d1bbf0d35988bea267a2e0f59 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aef4c790d1bbf0d35988bea267a2e0f59">size</a> () const =0</td></tr>
<tr class="memdesc:aef4c790d1bbf0d35988bea267a2e0f59 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of particles saved in the container (owned + halo + dummy).  <br /></td></tr>
<tr class="separator:aef4c790d1bbf0d35988bea267a2e0f59 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b151868acebea1f635f9ce9dd1a72e5 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, true, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a5b151868acebea1f635f9ce9dd1a72e5">begin</a> (IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, true, false &gt;::ParticleVecType *additionalVectors=nullptr)=0</td></tr>
<tr class="memdesc:a5b151868acebea1f635f9ce9dd1a72e5 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .  <br /></td></tr>
<tr class="separator:a5b151868acebea1f635f9ce9dd1a72e5 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb00a693b91c1052d3d919ce3acfa32a inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#acb00a693b91c1052d3d919ce3acfa32a">begin</a> (IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, false, false &gt;::ParticleVecType *additionalVectors=nullptr) const =0</td></tr>
<tr class="memdesc:acb00a693b91c1052d3d919ce3acfa32a inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:acb00a693b91c1052d3d919ce3acfa32a inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0444bcf5267c1c5840ac6a0a96a24bf inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa0444bcf5267c1c5840ac6a0a96a24bf">cbegin</a> (IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, false, false &gt;::ParticleVecType *additionalVectors=nullptr) const final</td></tr>
<tr class="memdesc:aa0444bcf5267c1c5840ac6a0a96a24bf inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:aa0444bcf5267c1c5840ac6a0a96a24bf inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b3b69b8a0398b6d58990fd42604920 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, true, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a35b3b69b8a0398b6d58990fd42604920">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, true, true &gt;::ParticleVecType *additionalVectors=nullptr)=0</td></tr>
<tr class="memdesc:a35b3b69b8a0398b6d58990fd42604920 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .  <br /></td></tr>
<tr class="separator:a35b3b69b8a0398b6d58990fd42604920 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e155f3982e47fe1dc39fcc2e04d661 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, false, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#af1e155f3982e47fe1dc39fcc2e04d661">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a>, false, true &gt;::ParticleVecType *additionalVectors=nullptr) const =0</td></tr>
<tr class="memdesc:af1e155f3982e47fe1dc39fcc2e04d661 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .    <br /></td></tr>
<tr class="separator:af1e155f3982e47fe1dc39fcc2e04d661 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3092c7f1c29e955d01faed348021ea6c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a3092c7f1c29e955d01faed348021ea6c">end</a> () const</td></tr>
<tr class="memdesc:a3092c7f1c29e955d01faed348021ea6c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy to make range-based for loops work.    <br /></td></tr>
<tr class="separator:a3092c7f1c29e955d01faed348021ea6c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab383284c81486ed2eeaf8af598c4a4cb inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab383284c81486ed2eeaf8af598c4a4cb">computeInteractions</a> (<a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *traversal)=0</td></tr>
<tr class="memdesc:ab383284c81486ed2eeaf8af598c4a4cb inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all particle multiples (e.g.  <br /></td></tr>
<tr class="separator:ab383284c81486ed2eeaf8af598c4a4cb inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1778749aee00722d67d0ac4067df602e inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a1778749aee00722d67d0ac4067df602e">getBoxMax</a> () const =0</td></tr>
<tr class="memdesc:a1778749aee00722d67d0ac4067df602e inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the upper corner of the container without halo.  <br /></td></tr>
<tr class="separator:a1778749aee00722d67d0ac4067df602e inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f55afacd6446eeea5fc34e6468c56f4 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a0f55afacd6446eeea5fc34e6468c56f4">getBoxMin</a> () const =0</td></tr>
<tr class="memdesc:a0f55afacd6446eeea5fc34e6468c56f4 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lower corner of the container without halo.  <br /></td></tr>
<tr class="separator:a0f55afacd6446eeea5fc34e6468c56f4 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c65dd1a6a3e98f016d3373b835e3a3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a15c65dd1a6a3e98f016d3373b835e3a3">getCutoff</a> () const =0</td></tr>
<tr class="memdesc:a15c65dd1a6a3e98f016d3373b835e3a3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cutoff of the container.  <br /></td></tr>
<tr class="separator:a15c65dd1a6a3e98f016d3373b835e3a3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6271bbef734203f7d902f61a1e7c9cc3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a6271bbef734203f7d902f61a1e7c9cc3">setCutoff</a> (double cutoff)=0</td></tr>
<tr class="memdesc:a6271bbef734203f7d902f61a1e7c9cc3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cutoff of the container.  <br /></td></tr>
<tr class="separator:a6271bbef734203f7d902f61a1e7c9cc3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ff749bcd4540af8bbdda48064dd6c4 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a31ff749bcd4540af8bbdda48064dd6c4">getVerletSkin</a> () const =0</td></tr>
<tr class="memdesc:a31ff749bcd4540af8bbdda48064dd6c4 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the verletSkin of the container verletSkin.  <br /></td></tr>
<tr class="separator:a31ff749bcd4540af8bbdda48064dd6c4 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade006f01a9966aeaee7ff6aff677a995 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ade006f01a9966aeaee7ff6aff677a995">getStepsSinceLastRebuild</a> () const</td></tr>
<tr class="memdesc:ade006f01a9966aeaee7ff6aff677a995 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of time-steps since last neighbor list rebuild.  <br /></td></tr>
<tr class="separator:ade006f01a9966aeaee7ff6aff677a995 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94447de936c48623cb7f5e71972dd5cb inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a94447de936c48623cb7f5e71972dd5cb">setStepsSinceLastRebuild</a> (size_t stepsSinceLastRebuild)</td></tr>
<tr class="memdesc:a94447de936c48623cb7f5e71972dd5cb inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of time-steps since last neighbor list rebuild.  <br /></td></tr>
<tr class="separator:a94447de936c48623cb7f5e71972dd5cb inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e30b5867e028a31976bbcb57b8275 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4a7e30b5867e028a31976bbcb57b8275">getInteractionLength</a> () const =0</td></tr>
<tr class="memdesc:a4a7e30b5867e028a31976bbcb57b8275 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the interaction length (cutoff+skin) of the container.  <br /></td></tr>
<tr class="separator:a4a7e30b5867e028a31976bbcb57b8275 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dda55358efa1968d2ac50b07b9ca1ad inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4f0695c5d46b1e1c8fce247204e82dee">ParticleType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a8dda55358efa1968d2ac50b07b9ca1ad">updateContainer</a> (bool keepNeighborListsValid)=0</td></tr>
<tr class="memdesc:a8dda55358efa1968d2ac50b07b9ca1ad inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the container.  <br /></td></tr>
<tr class="separator:a8dda55358efa1968d2ac50b07b9ca1ad inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e4db645c91162b8ce86c33436edd64 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1TraversalSelectorInfo.html">TraversalSelectorInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a28e4db645c91162b8ce86c33436edd64">getTraversalSelectorInfo</a> () const =0</td></tr>
<tr class="memdesc:a28e4db645c91162b8ce86c33436edd64 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a traversal selector info for this container.  <br /></td></tr>
<tr class="separator:a28e4db645c91162b8ce86c33436edd64 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0243c31f249174d3bec3dfadbceb4dc6 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">std::set&lt; TraversalOption &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a0243c31f249174d3bec3dfadbceb4dc6">getAllTraversals</a> (const InteractionTypeOption interactionType) const</td></tr>
<tr class="memdesc:a0243c31f249174d3bec3dfadbceb4dc6 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a list of all traversals that are theoretically applicable to this container.  <br /></td></tr>
<tr class="separator:a0243c31f249174d3bec3dfadbceb4dc6 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa909a2630ee1f75ad609d926ed3aef67 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual std::tuple&lt; const Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa909a2630ee1f75ad609d926ed3aef67">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior) const =0</td></tr>
<tr class="memdesc:aa909a2630ee1f75ad609d926ed3aef67 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.  <br /></td></tr>
<tr class="separator:aa909a2630ee1f75ad609d926ed3aef67 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb63771d84be8bb8c0e670aea36bb228 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual std::tuple&lt; const Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#adb63771d84be8bb8c0e670aea36bb228">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax) const =0</td></tr>
<tr class="memdesc:adb63771d84be8bb8c0e670aea36bb228 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.    <br /></td></tr>
<tr class="separator:adb63771d84be8bb8c0e670aea36bb228 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cda68ae216565832f6ed7de5254b046 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a0cda68ae216565832f6ed7de5254b046">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax)</td></tr>
<tr class="memdesc:a0cda68ae216565832f6ed7de5254b046 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.      <br /></td></tr>
<tr class="separator:a0cda68ae216565832f6ed7de5254b046 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0ba632522a88de24c8da072d9ebe0c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Particle_T *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a3e0ba632522a88de24c8da072d9ebe0c">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior)</td></tr>
<tr class="memdesc:a3e0ba632522a88de24c8da072d9ebe0c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.    <br /></td></tr>
<tr class="separator:a3e0ba632522a88de24c8da072d9ebe0c inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d1f4d9292b1f7759cd0764afcddcc3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ad8d1f4d9292b1f7759cd0764afcddcc3">deleteParticle</a> (Particle_T &amp;particle)=0</td></tr>
<tr class="memdesc:ad8d1f4d9292b1f7759cd0764afcddcc3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the given particle as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:ad8d1f4d9292b1f7759cd0764afcddcc3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0d45825b7200f790e120b17c480d32 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4b0d45825b7200f790e120b17c480d32">deleteParticle</a> (size_t cellIndex, size_t particleIndex)=0</td></tr>
<tr class="memdesc:a4b0d45825b7200f790e120b17c480d32 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the particle at the given index positions as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:a4b0d45825b7200f790e120b17c480d32 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae5844c1fda71e12f971a5aa761e582fa"><td class="memItemLeft" align="right" valign="top"><a id="ae5844c1fda71e12f971a5aa761e582fa" name="ae5844c1fda71e12f971a5aa761e582fa"></a>
<a class="el" href="classautopas_1_1LinkedCells.html">LinkedCells</a>&lt; Particle_T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_linkedCells</b></td></tr>
<tr class="memdesc:ae5844c1fda71e12f971a5aa761e582fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal linked cells storage, handles Particle storage and used to build verlet lists <br /></td></tr>
<tr class="separator:ae5844c1fda71e12f971a5aa761e582fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aa7a419bf995e23819731fbe3a27f5"><td class="memItemLeft" align="right" valign="top"><a id="ad8aa7a419bf995e23819731fbe3a27f5" name="ad8aa7a419bf995e23819731fbe3a27f5"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_neighborListIsValid</b> {false}</td></tr>
<tr class="memdesc:ad8aa7a419bf995e23819731fbe3a27f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">specifies if the neighbor list is currently valid <br /></td></tr>
<tr class="separator:ad8aa7a419bf995e23819731fbe3a27f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504f17b88731b17b45e5d6a4cfd8f057"><td class="memItemLeft" align="right" valign="top"><a id="a504f17b88731b17b45e5d6a4cfd8f057" name="a504f17b88731b17b45e5d6a4cfd8f057"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_verletBuiltNewton3</b> {false}</td></tr>
<tr class="memdesc:a504f17b88731b17b45e5d6a4cfd8f057"><td class="mdescLeft">&#160;</td><td class="mdescRight">specifies if the current verlet list was built for newton3 <br /></td></tr>
<tr class="separator:a504f17b88731b17b45e5d6a4cfd8f057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classautopas_1_1ParticleContainerInterface"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classautopas_1_1ParticleContainerInterface')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a6a5e4ad2c387e347a8c9dfc49bbbb946 inherit pro_attribs_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a6a5e4ad2c387e347a8c9dfc49bbbb946">_stepsSinceLastRebuild</a> {0}</td></tr>
<tr class="memdesc:a6a5e4ad2c387e347a8c9dfc49bbbb946 inherit pro_attribs_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the number of time-steps since last neighbor list rebuild.  <br /></td></tr>
<tr class="separator:a6a5e4ad2c387e347a8c9dfc49bbbb946 inherit pro_attribs_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c20cff49ca6e0ca6c31ae32c2639b55 inherit pro_attribs_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top"><a id="a9c20cff49ca6e0ca6c31ae32c2639b55" name="a9c20cff49ca6e0ca6c31ae32c2639b55"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_skin</b></td></tr>
<tr class="memdesc:a9c20cff49ca6e0ca6c31ae32c2639b55 inherit pro_attribs_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skin distance a particle is allowed to move in one time-step. <br /></td></tr>
<tr class="separator:a9c20cff49ca6e0ca6c31ae32c2639b55 inherit pro_attribs_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classautopas_1_1ParticleContainerInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classautopas_1_1ParticleContainerInterface')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a4f0695c5d46b1e1c8fce247204e82dee inherit pub_types_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top"><a id="a4f0695c5d46b1e1c8fce247204e82dee" name="a4f0695c5d46b1e1c8fce247204e82dee"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleType</b> = Particle_T</td></tr>
<tr class="memdesc:a4f0695c5d46b1e1c8fce247204e82dee inherit pub_types_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Particle. <br /></td></tr>
<tr class="separator:a4f0695c5d46b1e1c8fce247204e82dee inherit pub_types_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963269f22e648091366b4bcd4280532c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a963269f22e648091366b4bcd4280532c">addParticleImpl</a> (const Particle_T &amp;p)=0</td></tr>
<tr class="memdesc:a963269f22e648091366b4bcd4280532c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container.  <br /></td></tr>
<tr class="separator:a963269f22e648091366b4bcd4280532c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22a9cf2391cf726105e1a55c1cb03d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ae22a9cf2391cf726105e1a55c1cb03d6">addHaloParticleImpl</a> (const Particle_T &amp;haloParticle)=0</td></tr>
<tr class="memdesc:ae22a9cf2391cf726105e1a55c1cb03d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container that lies in the halo region of the container.  <br /></td></tr>
<tr class="separator:ae22a9cf2391cf726105e1a55c1cb03d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Particle_T&gt;<br />
class autopas::VerletListsLinkedBase&lt; Particle_T &gt;</div><p>Base class for Verlet lists which use an underlying linked cells container. </p>
<p>Implementation have to use a constant cutoff radius of the interaction. Cells are created using a cell size of at least cutoff + skin radius. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle_T</td><td></td></tr>
    <tr><td class="paramname">LinkedParticleCells</td><td>ParticleCells used by the linked cells container </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a238710c589e2afea91b4501180acf37c" name="a238710c589e2afea91b4501180acf37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238710c589e2afea91b4501180acf37c">&#9670;&#160;</a></span>VerletListsLinkedBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::VerletListsLinkedBase </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>skin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>rebuildFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; TraversalOption &gt; &amp;&#160;</td>
          <td class="paramname"><em>applicableTraversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cellSizeFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="classautopas_1_1VerletListsLinkedBase.html" title="Base class for Verlet lists which use an underlying linked cells container.">VerletListsLinkedBase</a> class. </p>
<p>The neighbor lists are build using a search radius of cutoff + skin.LinkedParticleCell::ParticleType *rebuildFrequency </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>the lower corner of the domain </td></tr>
    <tr><td class="paramname">boxMax</td><td>the upper corner of the domain </td></tr>
    <tr><td class="paramname">cutoff</td><td>the cutoff radius of the interaction </td></tr>
    <tr><td class="paramname">skin</td><td>the skin radius </td></tr>
    <tr><td class="paramname">rebuildFrequency</td><td>the rebuild frequency. </td></tr>
    <tr><td class="paramname">applicableTraversals</td><td>all applicable traversals </td></tr>
    <tr><td class="paramname">cellSizeFactor</td><td>cell size factor relative to cutoff. Verlet lists are only implemented for values &gt;= 1.0 (smaller values are set to 1.0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af92378034166971d86bd4f43b29dfcc0" name="af92378034166971d86bd4f43b29dfcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92378034166971d86bd4f43b29dfcc0">&#9670;&#160;</a></span>addHaloParticleImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::addHaloParticleImpl </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>haloParticle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a particle to the container that lies in the halo region of the container.   </p>
<p>This is an unsafe version of <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab2c350201102d10da0e549435e9b1d99" title="Adds a particle to the container.">addParticle()</a> and does not perform a boundary check. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haloParticle</td><td>Particle to be added. This particle is already checked to be outside of the bounding box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only call this function if the position of the particle is guaranteed to be outside of the bounding box!   </dd>
<dd>
This function invalidates the neighbor lists. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ae22a9cf2391cf726105e1a55c1cb03d6">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a11455d1e7ae1481c5156df4673e4d2a5" name="a11455d1e7ae1481c5156df4673e4d2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11455d1e7ae1481c5156df4673e4d2a5">&#9670;&#160;</a></span>addParticleImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::addParticleImpl </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a particle to the container.   </p>
<p>This is an unsafe version of <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab2c350201102d10da0e549435e9b1d99" title="Adds a particle to the container.">addParticle()</a> and does not perform a boundary check. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The particle to be added. This particle is already checked to be inside of the bounding box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only call this function if the position of the particle is guaranteed to be inside of the bounding box!   </dd>
<dd>
This function invalidates the neighbor lists. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a963269f22e648091366b4bcd4280532c">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a41fff9b096403519365ffa59173c34aa" name="a41fff9b096403519365ffa59173c34aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fff9b096403519365ffa59173c34aa">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>IteratorBehavior::ownedOrHalo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, false &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .   </p>
<dl class="section note"><dt>Note</dt><dd>The default argument for behavior is necessary to enable range based for loops. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first particle.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#acb00a693b91c1052d3d919ce3acfa32a">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a420417c2a1b196422288d9f70f2de3a2" name="a420417c2a1b196422288d9f70f2de3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420417c2a1b196422288d9f70f2de3a2">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, false &gt; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>IteratorBehavior::ownedOrHalo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, false &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .   </p>
<dl class="section note"><dt>Note</dt><dd>The default argument for behavior is necessary to enable range based for loops. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first particle.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a5b151868acebea1f635f9ce9dd1a72e5">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a4a141094f03b5d65c271d3d8ef3ad516" name="a4a141094f03b5d65c271d3d8ef3ad516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a141094f03b5d65c271d3d8ef3ad516">&#9670;&#160;</a></span>deleteAllParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::deleteAllParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all particles.   </p>
<dl class="section note"><dt>Note</dt><dd>This function invalidates the neighbor lists. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a740fc3a18464478bffd53abadcf9071d">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="aedc31f20163c4af0a3336e51e58caa5e" name="aedc31f20163c4af0a3336e51e58caa5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc31f20163c4af0a3336e51e58caa5e">&#9670;&#160;</a></span>deleteHaloParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::deleteHaloParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all halo particles.   </p>
<dl class="section note"><dt>Note</dt><dd>This function invalidates the neighbor lists. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab430b1916311400b6b4108a5596ff8b9">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a92984f356e0834768bff7349acea46d7" name="a92984f356e0834768bff7349acea46d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92984f356e0834768bff7349acea46d7">&#9670;&#160;</a></span>deleteParticle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype">Particle_T &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the given particle as long as this does not compromise the validity of the container. </p>
<p>If this is not possible the particle is just marked as deleted. </p><dl class="section note"><dt>Note</dt><dd>This function might be implemented via swap-delete and is thus not completely thread safe. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td>Reference to the particle that is to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given pointer still points to a new particle. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ad8d1f4d9292b1f7759cd0764afcddcc3">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="aee248cab15b26a33b9ae714bbd0a1674" name="aee248cab15b26a33b9ae714bbd0a1674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee248cab15b26a33b9ae714bbd0a1674">&#9670;&#160;</a></span>deleteParticle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the particle at the given index positions as long as this does not compromise the validity of the container. </p>
<p>If this is not possible the particle is just marked as deleted. If the positions do not exist the behavior is undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td></td></tr>
    <tr><td class="paramname">particleIndex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given indices still point to a new particle. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4b0d45825b7200f790e120b17c480d32">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a45091e22d5c8b5063ff25d0e3c751d1b" name="a45091e22d5c8b5063ff25d0e3c751d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45091e22d5c8b5063ff25d0e3c751d1b">&#9670;&#160;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute code on all particles in this container as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle_T &amp;p) -&gt; void </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>code to be executed on all particles </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior   </dd></dl>

</div>
</div>
<a id="afec9f0daae94def2ba051b1aa7063cb8" name="afec9f0daae94def2ba051b1aa7063cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec9f0daae94def2ba051b1aa7063cb8">&#9670;&#160;</a></span>forEachInRegion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::forEachInRegion </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute code on all particles in this container in a certain region as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle_T &amp;p) -&gt; void </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>code to be executed on all particles </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>lower corner of bounding box </td></tr>
    <tr><td class="paramname">higherCorner</td><td>higher corner of bounding box </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior   </dd></dl>

</div>
</div>
<a id="a934ca3e02ecc49362309596f40b22b5c" name="a934ca3e02ecc49362309596f40b22b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934ca3e02ecc49362309596f40b22b5c">&#9670;&#160;</a></span>getBoxMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getBoxMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the upper corner of the container without halo.   </p>
<dl class="section return"><dt>Returns</dt><dd>Upper corner of the container.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a1778749aee00722d67d0ac4067df602e">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a56146a17f3339468dda6bd578cf17dd3" name="a56146a17f3339468dda6bd578cf17dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56146a17f3339468dda6bd578cf17dd3">&#9670;&#160;</a></span>getBoxMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getBoxMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the lower corner of the container without halo.   </p>
<dl class="section return"><dt>Returns</dt><dd>Lower corner of the container.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a0f55afacd6446eeea5fc34e6468c56f4">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a6c265278a6e7d686d93d65ec4b007d1b" name="a6c265278a6e7d686d93d65ec4b007d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c265278a6e7d686d93d65ec4b007d1b">&#9670;&#160;</a></span>getCellsPerDimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; std::size_t, 3 &gt; &amp; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getCellsPerDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimension of the used cellblock including the haloboxes. </p>
<dl class="section return"><dt>Returns</dt><dd>the dimensions of the used cellblock </dd></dl>

</div>
</div>
<a id="afb42a60779f2587821a50b9de83bc8c6" name="afb42a60779f2587821a50b9de83bc8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb42a60779f2587821a50b9de83bc8c6">&#9670;&#160;</a></span>getCutoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getCutoff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cutoff of the container.   </p>
<dl class="section return"><dt>Returns</dt><dd>Cutoff radius.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a15c65dd1a6a3e98f016d3373b835e3a3">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="acf4d1ae2a5ae96f88686b7868daa8583" name="acf4d1ae2a5ae96f88686b7868daa8583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4d1ae2a5ae96f88686b7868daa8583">&#9670;&#160;</a></span>getInteractionLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getInteractionLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the interaction length (cutoff+skin) of the container.   </p>
<dl class="section return"><dt>Returns</dt><dd>interaction length   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4a7e30b5867e028a31976bbcb57b8275">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a74d3898b5f634391c4fd8b523ac556a9" name="a74d3898b5f634391c4fd8b523ac556a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d3898b5f634391c4fd8b523ac556a9">&#9670;&#160;</a></span>getNumberOfParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getNumberOfParticles </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of particles with respect to the specified IteratorBehavior.   </p>
<dl class="section warning"><dt>Warning</dt><dd>: Since this function counts the number of the respective particles in the internal particle storage, this is in O(n) + lock is required. Only use it when it is absolutely necessary to have the exact number of different particle types like owned or halo. If it is enough to have the whole number of particles (owned + halo + dummy), the function <a class="el" href="classautopas_1_1VerletListsLinkedBase.html#aff1c2b716ee825291cdac79e4392f08e" title="Get the total number of particles saved in the container (owned + halo + dummy).">size()</a> can be used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of particles with respect to the specified IteratorBehavior.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a74cffaa132a5ef9d1f8fc72845bfc81f">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="aa52ca7f7f8b33f321b2beb86aa1a314f" name="aa52ca7f7f8b33f321b2beb86aa1a314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52ca7f7f8b33f321b2beb86aa1a314f">&#9670;&#160;</a></span>getParticle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const Particle_T *, size_t, size_t &gt; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the pointer to a particle, identified via a cell and particle index. </p>
<p>These indices are only meaningful in the context of the current container at its current state. The same indices might (and probably will) yield different particles for different container types or might not even exist. The only guarantee is that the indices {0,0} yield the first particle in the container that satisfies the iterator requirements.</p>
<dl class="section note"><dt>Note</dt><dd>This function should handle any offsets if used in a parallel iterator.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td>Index of the cell the particle is located in. </td></tr>
    <tr><td class="paramname">particleIndex</td><td>Particle index within the cell. </td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td>Which ownership states should be considered for the next particle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the particle and its indices. tuple&lt;Particle_T*, cellIndex, particleIndex&gt; If a index pair is given that does not exist but is also not beyond the last cell, the next fitting particle shall be returned. Example: If [4,2] does not exist, [5,1] shall be returned (or whatever is the next particle that fulfills the iterator requirements). If there is no next fitting particle {nullptr, 0, 0} is returned. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa909a2630ee1f75ad609d926ed3aef67">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a577e3ded3cb81632145482c25a348f27" name="a577e3ded3cb81632145482c25a348f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577e3ded3cb81632145482c25a348f27">&#9670;&#160;</a></span>getParticle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const Particle_T *, size_t, size_t &gt; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the pointer to a particle, identified via a cell and particle index.   </p>
<p>These indices are only meaningful in the context of the current container at its current state. The same indices might (and probably will) yield different particles for different container types or might not even exist. The only guarantee is that the indices {0,0} yield the first particle in the container that satisfies the iterator requirements.</p>
<dl class="section note"><dt>Note</dt><dd>This function should handle any offsets if used in a parallel iterator.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td>Index of the cell the particle is located in. </td></tr>
    <tr><td class="paramname">particleIndex</td><td>Particle index within the cell. </td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td>Which ownership states should be considered for the next particle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the particle and its indices. tuple&lt;Particle_T*, cellIndex, particleIndex&gt; If a index pair is given that does not exist but is also not beyond the last cell, the next fitting particle shall be returned. Example: If [4,2] does not exist, [5,1] shall be returned (or whatever is the next particle that fulfills the iterator requirements). If there is no next fitting particle {nullptr, 0, 0} is returned.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>start of region in which the next particle should be. The coordinates are expected to be within the domain. </td></tr>
    <tr><td class="paramname">boxMax</td><td>end of region in which the next particle should be. The coordinates are expected to be within the domain. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#adb63771d84be8bb8c0e670aea36bb228">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a974aab62504f7d59f377730e85abb9df" name="a974aab62504f7d59f377730e85abb9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974aab62504f7d59f377730e85abb9df">&#9670;&#160;</a></span>getParticleCellTypeEnum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a> <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getParticleCellTypeEnum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an Enum.   </p>
<dl class="section return"><dt>Returns</dt><dd>The Cell type as an Enum   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9f3264b2ea8bbd3b471faf77aca70511">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ab194aaab36d7454d180299d00d70e7cb" name="ab194aaab36d7454d180299d00d70e7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab194aaab36d7454d180299d00d70e7cb">&#9670;&#160;</a></span>getParticleImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;bool regionIter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const Particle_T *, size_t, size_t &gt; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getParticleImpl </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container specific implementation for getParticle. </p>
<p>See <a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa909a2630ee1f75ad609d926ed3aef67" title="Fetch the pointer to a particle, identified via a cell and particle index.">ParticleContainerInterface::getParticle()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">regionIter</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td></td></tr>
    <tr><td class="paramname">particleIndex</td><td></td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td></td></tr>
    <tr><td class="paramname">boxMin</td><td></td></tr>
    <tr><td class="paramname">boxMax</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple&lt;ParticlePointer, CellIndex, ParticleIndex&gt; </dd></dl>

</div>
</div>
<a id="adc54cd5f59d7f777070e10209201f9b4" name="adc54cd5f59d7f777070e10209201f9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc54cd5f59d7f777070e10209201f9b4">&#9670;&#160;</a></span>getRegionIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, true &gt; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getRegionIterator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, false, true &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of the region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of the region </td></tr>
    <tr><td class="paramname">behavior</td><td>The behavior of the iterator (shall it iterate over halo particles as well?). </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to iterate over all particles in a specific region.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#af1e155f3982e47fe1dc39fcc2e04d661">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ab64f597ee744514f6557d431e155569e" name="ab64f597ee744514f6557d431e155569e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64f597ee744514f6557d431e155569e">&#9670;&#160;</a></span>getRegionIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, true &gt; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getRegionIterator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; Particle_T, true, true &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of the region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of the region </td></tr>
    <tr><td class="paramname">behavior</td><td>The behavior of the iterator (shall it iterate over halo particles as well?). </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to iterate over all particles in a specific region.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a35b3b69b8a0398b6d58990fd42604920">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ae591a76b308677cffc4210c4dac00f54" name="ae591a76b308677cffc4210c4dac00f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae591a76b308677cffc4210c4dac00f54">&#9670;&#160;</a></span>getTraversalSelectorInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1TraversalSelectorInfo.html">TraversalSelectorInfo</a> <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getTraversalSelectorInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a traversal selector info for this container. </p>
<dl class="section return"><dt>Returns</dt><dd>Traversal selector info for this container. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a28e4db645c91162b8ce86c33436edd64">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a774e3185f365061ffd949d2af72a2739" name="a774e3185f365061ffd949d2af72a2739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774e3185f365061ffd949d2af72a2739">&#9670;&#160;</a></span>getVerletSkin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::getVerletSkin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the verletSkin of the container verletSkin.   </p>
<dl class="section return"><dt>Returns</dt><dd>verletSkin   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a31ff749bcd4540af8bbdda48064dd6c4">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="afd357376f261d996d793f7b336a1dfb3" name="afd357376f261d996d793f7b336a1dfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd357376f261d996d793f7b336a1dfb3">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce properties of particles as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle_T p, A initialValue) -&gt; void </td></tr>
    <tr><td class="paramname">A</td><td>type of particle attribute to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>code to reduce properties of particles </td></tr>
    <tr><td class="paramname">result</td><td>reference to result of type A </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior default: </dd>
<dd>
IteratorBehavior::ownedOrHalo   </dd></dl>

</div>
</div>
<a id="aa4da667424ec1eb61c650713fa8819c6" name="aa4da667424ec1eb61c650713fa8819c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4da667424ec1eb61c650713fa8819c6">&#9670;&#160;</a></span>reduceInRegion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::reduceInRegion </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute code on all particles in this container in a certain region as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle_T &amp;p, A &amp;result) -&gt; void </td></tr>
    <tr><td class="paramname">A</td><td>type of reduction Value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>code to be executed on all particles </td></tr>
    <tr><td class="paramname">result</td><td>reference to starting and final value for reduction </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>lower corner of bounding box </td></tr>
    <tr><td class="paramname">higherCorner</td><td>higher corner of bounding box </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior   </dd></dl>

</div>
</div>
<a id="a23e51b15eb241ff31812f23a25a897c8" name="a23e51b15eb241ff31812f23a25a897c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e51b15eb241ff31812f23a25a897c8">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numParticlesHaloEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve memory for a given number of particles in the container and logic layers.   </p>
<p>This function assumes a uniform distribution of particles throughout the domain. For example, this means that in a <a class="el" href="classautopas_1_1LinkedCells.html" title="LinkedCells class.">LinkedCells</a> Container in each cell vector.reserve(numParticles/numCells) is called. </p><dl class="section note"><dt>Note</dt><dd>This functions will create an estimate for the number of halo particles. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numParticles</td><td>No buffer factor is applied. It is probably wise to slightly over-reserve to account for imbalance or particle movement.   </td></tr>
    <tr><td class="paramname">numParticlesHaloEstimate</td><td>Estimate for the number of halo particles. Reserves space in the container data structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a81d65a563cfbdb1828379458db0dfadf">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a908f25f81431b27a0db7c35a89145c65" name="a908f25f81431b27a0db7c35a89145c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908f25f81431b27a0db7c35a89145c65">&#9670;&#160;</a></span>setCutoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::setCutoff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cutoff of the container.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cutoff</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a6271bbef734203f7d902f61a1e7c9cc3">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a438c1ea993ac393d3702d719ff9e5a57" name="a438c1ea993ac393d3702d719ff9e5a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438c1ea993ac393d3702d719ff9e5a57">&#9670;&#160;</a></span>setStepsSinceLastRebuild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::setStepsSinceLastRebuild </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stepsSinceLastRebuild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of time-steps since last neighbor list rebuild. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stepsSinceLastRebuild</td><td>steps since last neighbor list rebuild </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a94447de936c48623cb7f5e71972dd5cb">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="aff1c2b716ee825291cdac79e4392f08e" name="aff1c2b716ee825291cdac79e4392f08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1c2b716ee825291cdac79e4392f08e">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of particles saved in the container (owned + halo + dummy).   </p>
<dl class="section return"><dt>Returns</dt><dd>Number of particles saved in the container (owned + halo + dummy).   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#aef4c790d1bbf0d35988bea267a2e0f59">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a95f4a2bd710e07a891dbc6342b8fcd58" name="a95f4a2bd710e07a891dbc6342b8fcd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f4a2bd710e07a891dbc6342b8fcd58">&#9670;&#160;</a></span>updateContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Particle_T &gt; <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::updateContainer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepNeighborListsValid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the container.   </p>
<p>This deletes halo particles, resorts particles into appropriate cells and might remove particles from the container, if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepNeighborListsValid</td><td>Defines whether the neighbor lists have to be kept valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of invalid particles that do not belong into the container.   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function invalidates the neighbor lists. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a8dda55358efa1968d2ac50b07b9ca1ad">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a0353c0f0a44f84cc1cffffd507bbcb14" name="a0353c0f0a44f84cc1cffffd507bbcb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0353c0f0a44f84cc1cffffd507bbcb14">&#9670;&#160;</a></span>updateHaloParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1VerletListsLinkedBase.html">autopas::VerletListsLinkedBase</a>&lt; Particle_T &gt;::updateHaloParticle </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>haloParticle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the provided halo particle and updates the found particle. </p>
<p>Searches for the provided particle within the halo cells of the container and overwrites the found particle with the provided particle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haloParticle</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a particle was found and updated, false if it was not found. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a7b43eec590054db74704b88d2d896937">autopas::ParticleContainerInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autopas/containers/verletListsCellBased/<a class="el" href="VerletListsLinkedBase_8h_source.html">VerletListsLinkedBase.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

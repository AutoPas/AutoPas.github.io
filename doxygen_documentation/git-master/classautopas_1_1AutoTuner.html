<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1AutoTuner.html">AutoTuner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classautopas_1_1AutoTuner-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::AutoTuner Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class manages all logic related to the auto tuning mechanic.  
 <a href="classautopas_1_1AutoTuner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AutoTuner_8h_source.html">AutoTuner.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a87659e501b6d6c57bfe282b204e23efb"><td class="memItemLeft" align="right" valign="top"><a id="a87659e501b6d6c57bfe282b204e23efb" name="a87659e501b6d6c57bfe282b204e23efb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TuningStrategiesListType</b> = std::vector&lt; std::unique_ptr&lt; <a class="el" href="classautopas_1_1TuningStrategyInterface.html">TuningStrategyInterface</a> &gt; &gt;</td></tr>
<tr class="memdesc:a87659e501b6d6c57bfe282b204e23efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for the member holding all tuning strategies. <br /></td></tr>
<tr class="separator:a87659e501b6d6c57bfe282b204e23efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc20dc92bb8731859dab10d26faddac"><td class="memItemLeft" align="right" valign="top"><a id="a4fc20dc92bb8731859dab10d26faddac" name="a4fc20dc92bb8731859dab10d26faddac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SearchSpaceType</b> = std::set&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt;</td></tr>
<tr class="memdesc:a4fc20dc92bb8731859dab10d26faddac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for the search space holding all possible configurations. <br /></td></tr>
<tr class="separator:a4fc20dc92bb8731859dab10d26faddac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab7c2cbc5351ace6d99e0ce0021e85ebe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ab7c2cbc5351ace6d99e0ce0021e85ebe">AutoTuner</a> (<a class="el" href="classautopas_1_1AutoTuner.html#a87659e501b6d6c57bfe282b204e23efb">TuningStrategiesListType</a> &amp;tuningStrategies, const <a class="el" href="classautopas_1_1AutoTuner.html#a4fc20dc92bb8731859dab10d26faddac">SearchSpaceType</a> &amp;searchSpace, const <a class="el" href="structautopas_1_1AutoTunerInfo.html">AutoTunerInfo</a> &amp;autoTunerInfo, unsigned int rebuildFrequency, const std::string &amp;outputSuffix)</td></tr>
<tr class="memdesc:ab7c2cbc5351ace6d99e0ce0021e85ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="classautopas_1_1AutoTuner.html" title="This class manages all logic related to the auto tuning mechanic.">AutoTuner</a> that generates all configurations from the given options.  <br /></td></tr>
<tr class="separator:ab7c2cbc5351ace6d99e0ce0021e85ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27de7b1ab9f73c877eb316b79a4e63db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1AutoTuner.html">AutoTuner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a27de7b1ab9f73c877eb316b79a4e63db">operator=</a> (<a class="el" href="classautopas_1_1AutoTuner.html">AutoTuner</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a27de7b1ab9f73c877eb316b79a4e63db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:a27de7b1ab9f73c877eb316b79a4e63db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4b05aace993e15acdf69b4f0946ccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#aed4b05aace993e15acdf69b4f0946ccc">forceRetune</a> ()</td></tr>
<tr class="memdesc:aed4b05aace993e15acdf69b4f0946ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the internal tuner to enter a new tuning phase upon the next call to computeInteractions().    <br /></td></tr>
<tr class="separator:aed4b05aace993e15acdf69b4f0946ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae067e7ec72d47901218da725b136f58b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classautopas_1_1TuningMetricOption.html">TuningMetricOption</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ae067e7ec72d47901218da725b136f58b">getTuningMetric</a> () const</td></tr>
<tr class="memdesc:ae067e7ec72d47901218da725b136f58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the primary metric for tuning.  <br /></td></tr>
<tr class="separator:ae067e7ec72d47901218da725b136f58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32706623a5717a5564d01b4694cbcb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ad32706623a5717a5564d01b4694cbcb5">receiveLiveInfo</a> (const <a class="el" href="classautopas_1_1LiveInfo.html">LiveInfo</a> &amp;liveInfo)</td></tr>
<tr class="memdesc:ad32706623a5717a5564d01b4694cbcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass live info on to all tuning strategies.  <br /></td></tr>
<tr class="separator:ad32706623a5717a5564d01b4694cbcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd71cda0cc2c6f07b2108aaca118f609"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#acd71cda0cc2c6f07b2108aaca118f609">needsHomogeneityAndMaxDensityBeforePrepare</a> () const</td></tr>
<tr class="memdesc:acd71cda0cc2c6f07b2108aaca118f609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator whether tuner needs homogeneity and max density information before the next call to <a class="el" href="classautopas_1_1AutoTuner.html#ae50e16a3864ee82c7e6b9525aa43a16b" title="Determines what live infos are needed and passes collected live info to the tuning strategies.">prepareIteration()</a>.  <br /></td></tr>
<tr class="separator:acd71cda0cc2c6f07b2108aaca118f609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50e16a3864ee82c7e6b9525aa43a16b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ae50e16a3864ee82c7e6b9525aa43a16b">prepareIteration</a> ()</td></tr>
<tr class="memdesc:ae50e16a3864ee82c7e6b9525aa43a16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines what live infos are needed and passes collected live info to the tuning strategies.  <br /></td></tr>
<tr class="separator:ae50e16a3864ee82c7e6b9525aa43a16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3efd0da6d143a2a333d524553bc84a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a2b3efd0da6d143a2a333d524553bc84a">bumpIterationCounters</a> (bool needToWait=false)</td></tr>
<tr class="memdesc:a2b3efd0da6d143a2a333d524553bc84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase internal iteration counters by one.  <br /></td></tr>
<tr class="separator:a2b3efd0da6d143a2a333d524553bc84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796da93e86a1678f995acd6819e34e9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a796da93e86a1678f995acd6819e34e9e">willRebuildNeighborLists</a> () const</td></tr>
<tr class="memdesc:a796da93e86a1678f995acd6819e34e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether rebuildNeighborLists() should be triggered in the next iteration.  <br /></td></tr>
<tr class="separator:a796da93e86a1678f995acd6819e34e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c778b2db88b8c7cfcbd4417b33ed5f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ad8c778b2db88b8c7cfcbd4417b33ed5f">getCurrentConfig</a> () const</td></tr>
<tr class="memdesc:ad8c778b2db88b8c7cfcbd4417b33ed5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently selected configuration.  <br /></td></tr>
<tr class="separator:ad8c778b2db88b8c7cfcbd4417b33ed5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a705e04679b24fbd0de7def40e38d1"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a38a705e04679b24fbd0de7def40e38d1">getNextConfig</a> ()</td></tr>
<tr class="memdesc:a38a705e04679b24fbd0de7def40e38d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the tuner for the next configuration to use.  <br /></td></tr>
<tr class="separator:a38a705e04679b24fbd0de7def40e38d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f05fb22f0b00eaea592e4fa89ecf85"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#aa8f05fb22f0b00eaea592e4fa89ecf85">rejectConfig</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;rejectedConfig, bool indefinitely)</td></tr>
<tr class="memdesc:aa8f05fb22f0b00eaea592e4fa89ecf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the tuner that the given config is not applicable.  <br /></td></tr>
<tr class="separator:aa8f05fb22f0b00eaea592e4fa89ecf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae200ca1f23fb9ca4f9f798cd5e443af6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ae200ca1f23fb9ca4f9f798cd5e443af6">searchSpaceIsTrivial</a> () const</td></tr>
<tr class="memdesc:ae200ca1f23fb9ca4f9f798cd5e443af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator function whether the search space consists of exactly one configuration.  <br /></td></tr>
<tr class="separator:ae200ca1f23fb9ca4f9f798cd5e443af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08333ac15c1db2f1ebd2820cc2d56d54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a08333ac15c1db2f1ebd2820cc2d56d54">searchSpaceIsEmpty</a> () const</td></tr>
<tr class="memdesc:a08333ac15c1db2f1ebd2820cc2d56d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator function whether the search space has no configurations in it.  <br /></td></tr>
<tr class="separator:a08333ac15c1db2f1ebd2820cc2d56d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4869c59c2bc70ac244e27840a1f716c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a4869c59c2bc70ac244e27840a1f716c1">logTuningResult</a> (bool tuningIteration, long tuningTime) const</td></tr>
<tr class="memdesc:a4869c59c2bc70ac244e27840a1f716c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">After a tuning phase has finished, write the result to a file.  <br /></td></tr>
<tr class="separator:a4869c59c2bc70ac244e27840a1f716c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10dcc9eac0aa2ffa243577bc12447cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ac10dcc9eac0aa2ffa243577bc12447cf">initEnergy</a> ()</td></tr>
<tr class="memdesc:ac10dcc9eac0aa2ffa243577bc12447cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize pmt sensor.  <br /></td></tr>
<tr class="separator:ac10dcc9eac0aa2ffa243577bc12447cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0c30c81b4a96e2783c84a2d51c384d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a7c0c30c81b4a96e2783c84a2d51c384d">resetEnergy</a> ()</td></tr>
<tr class="memdesc:a7c0c30c81b4a96e2783c84a2d51c384d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the rapl meter to prepare for a new measurement.  <br /></td></tr>
<tr class="separator:a7c0c30c81b4a96e2783c84a2d51c384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071591bc54c4a76ae1bd6a08bd6de8b7"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; double, double, double, long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a071591bc54c4a76ae1bd6a08bd6de8b7">sampleEnergy</a> ()</td></tr>
<tr class="memdesc:a071591bc54c4a76ae1bd6a08bd6de8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an energy measurement.  <br /></td></tr>
<tr class="separator:a071591bc54c4a76ae1bd6a08bd6de8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa33a8e72dd043a9872ff9f51415fcf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#aaa33a8e72dd043a9872ff9f51415fcf0">addMeasurement</a> (long sample, bool neighborListRebuilt)</td></tr>
<tr class="memdesc:aaa33a8e72dd043a9872ff9f51415fcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the runtime of a given traversal.  <br /></td></tr>
<tr class="separator:aaa33a8e72dd043a9872ff9f51415fcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411e32258a3a23b30787e5a636fc523a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a411e32258a3a23b30787e5a636fc523a">addHomogeneityAndMaxDensity</a> (double homogeneity, double maxDensity, long time)</td></tr>
<tr class="memdesc:a411e32258a3a23b30787e5a636fc523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds measurements of homogeneity and maximal density to the vector of measurements.  <br /></td></tr>
<tr class="separator:a411e32258a3a23b30787e5a636fc523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad340bf7e91f7b47c951ff70c38c7a30"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#aad340bf7e91f7b47c951ff70c38c7a30">getConfigQueue</a> () const</td></tr>
<tr class="memdesc:aad340bf7e91f7b47c951ff70c38c7a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the current queue of configurations.  <br /></td></tr>
<tr class="separator:aad340bf7e91f7b47c951ff70c38c7a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc9c3399b98e20b23c642753ded91e5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classautopas_1_1TuningStrategyInterface.html">TuningStrategyInterface</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a7dc9c3399b98e20b23c642753ded91e5">getTuningStrategies</a> () const</td></tr>
<tr class="memdesc:a7dc9c3399b98e20b23c642753ded91e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of tuning strategies that are used.  <br /></td></tr>
<tr class="separator:a7dc9c3399b98e20b23c642753ded91e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5383029952ce900fd2cf745aabaa634"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ac5383029952ce900fd2cf745aabaa634">inTuningPhase</a> () const</td></tr>
<tr class="memdesc:ac5383029952ce900fd2cf745aabaa634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the tuner considers itself currently in a tuning phase according to its internal counters.  <br /></td></tr>
<tr class="separator:ac5383029952ce900fd2cf745aabaa634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad450fa545a43e3b80924aabc5abbba29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ad450fa545a43e3b80924aabc5abbba29">inFirstTuningIteration</a> () const</td></tr>
<tr class="memdesc:ad450fa545a43e3b80924aabc5abbba29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the tuner is in the first iteration of a tuning phase.  <br /></td></tr>
<tr class="separator:ad450fa545a43e3b80924aabc5abbba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5eb51d45b6653060f0e3347b015aba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#a9c5eb51d45b6653060f0e3347b015aba">inLastTuningIteration</a> () const</td></tr>
<tr class="memdesc:a9c5eb51d45b6653060f0e3347b015aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the tuner is in the last iteration of the tuning phase.  <br /></td></tr>
<tr class="separator:a9c5eb51d45b6653060f0e3347b015aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc45ebb44212a4438832c007918de4a8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#adc45ebb44212a4438832c007918de4a8">getEvidenceCollection</a> () const</td></tr>
<tr class="memdesc:adc45ebb44212a4438832c007918de4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the internal evidence collection.  <br /></td></tr>
<tr class="separator:adc45ebb44212a4438832c007918de4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac150a44caf878d980d963a5761768442"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#ac150a44caf878d980d963a5761768442">canMeasureEnergy</a> () const</td></tr>
<tr class="memdesc:ac150a44caf878d980d963a5761768442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the <a class="el" href="classautopas_1_1AutoTuner.html" title="This class manages all logic related to the auto tuning mechanic.">AutoTuner</a> can take energy measurements.  <br /></td></tr>
<tr class="separator:ac150a44caf878d980d963a5761768442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f9c5fcb939e80d209a6a41721c3d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#af4f9c5fcb939e80d209a6a41721c3d16">setRebuildFrequency</a> (double rebuildFrequency)</td></tr>
<tr class="memdesc:af4f9c5fcb939e80d209a6a41721c3d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the _rebuildFrequency.  <br /></td></tr>
<tr class="separator:af4f9c5fcb939e80d209a6a41721c3d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb2e7ebee62c9775fc18193427e26c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1AutoTuner.html#afbb2e7ebee62c9775fc18193427e26c5">checkEarlyStoppingCondition</a> ()</td></tr>
<tr class="memdesc:afbb2e7ebee62c9775fc18193427e26c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the current configuration performs so poorly that it shouldn't be resampled further within this tuning phase.  <br /></td></tr>
<tr class="separator:afbb2e7ebee62c9775fc18193427e26c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class manages all logic related to the auto tuning mechanic. </p>
<p>This involves:</p><ul>
<li>Managing the search space and configQueue.</li>
<li>Managing and triggering all active tuning strategies.</li>
<li>Managing all collected evidence and passing it to the strategies.</li>
</ul>
<p>The tuner can be in one of two states. If it currently should look for a new optimum, it is in the so-called tuning phase. During a tuning phase, for each <a class="el" href="classautopas_1_1Configuration.html" title="Class containing multiple options that form an algorithm configuration for the pairwise iteration.">Configuration</a>, multiple measurements can be taken, which are called samples. To reduce noise, the samples for one configuration are then condensed to one value for the current tuning phase, called evidence. The evidences are handed on to a tuningStrategy, which selects a) what <a class="el" href="classautopas_1_1Configuration.html" title="Class containing multiple options that form an algorithm configuration for the pairwise iteration.">Configuration</a> to test next and b) which configuration is the best in this tuning phase. If it should not look for a new optimum it is not in a tuning phase. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab7c2cbc5351ace6d99e0ce0021e85ebe" name="ab7c2cbc5351ace6d99e0ce0021e85ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c2cbc5351ace6d99e0ce0021e85ebe">&#9670;&#160;</a></span>AutoTuner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">autopas::AutoTuner::AutoTuner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1AutoTuner.html#a87659e501b6d6c57bfe282b204e23efb">TuningStrategiesListType</a> &amp;&#160;</td>
          <td class="paramname"><em>tuningStrategies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1AutoTuner.html#a4fc20dc92bb8731859dab10d26faddac">SearchSpaceType</a> &amp;&#160;</td>
          <td class="paramname"><em>searchSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structautopas_1_1AutoTunerInfo.html">AutoTunerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>autoTunerInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rebuildFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outputSuffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="classautopas_1_1AutoTuner.html" title="This class manages all logic related to the auto tuning mechanic.">AutoTuner</a> that generates all configurations from the given options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuningStrategies</td><td>Vector of object implementing the modelling and exploration of a search space. Will be moved into the tuner. </td></tr>
    <tr><td class="paramname">searchSpace</td><td>All possible configurations. </td></tr>
    <tr><td class="paramname">autoTunerInfo</td><td>Struct containing more configuration information. </td></tr>
    <tr><td class="paramname">rebuildFrequency</td><td>The number of iterations after which the neighbor lists are rebuilt. </td></tr>
    <tr><td class="paramname">outputSuffix</td><td>Suffix for all output files produced by this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a411e32258a3a23b30787e5a636fc523a" name="a411e32258a3a23b30787e5a636fc523a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411e32258a3a23b30787e5a636fc523a">&#9670;&#160;</a></span>addHomogeneityAndMaxDensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::AutoTuner::addHomogeneityAndMaxDensity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>homogeneity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDensity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds measurements of homogeneity and maximal density to the vector of measurements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">homogeneity</td><td></td></tr>
    <tr><td class="paramname">maxDensity</td><td></td></tr>
    <tr><td class="paramname">time</td><td>Time it took to obtain these measurements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa33a8e72dd043a9872ff9f51415fcf0" name="aaa33a8e72dd043a9872ff9f51415fcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa33a8e72dd043a9872ff9f51415fcf0">&#9670;&#160;</a></span>addMeasurement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::AutoTuner::addMeasurement </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>neighborListRebuilt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the runtime of a given traversal. </p>
<p>Samples are collected and reduced to one single value according to _selectorStrategy. Only then the value is passed on to the tuning strategy. This function expects that samples of the same configuration are taken consecutively. The sample argument is a long because std::chrono::duration::count returns a long.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td></td></tr>
    <tr><td class="paramname">neighborListRebuilt</td><td>If the neighbor list as been rebuilt during the given time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b3efd0da6d143a2a333d524553bc84a" name="a2b3efd0da6d143a2a333d524553bc84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3efd0da6d143a2a333d524553bc84a">&#9670;&#160;</a></span>bumpIterationCounters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::AutoTuner::bumpIterationCounters </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>needToWait</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase internal iteration counters by one. </p>
<p>Should be called at the end of an iteration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needToWait</td><td>If tuner should wait for other tuners. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac150a44caf878d980d963a5761768442" name="ac150a44caf878d980d963a5761768442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac150a44caf878d980d963a5761768442">&#9670;&#160;</a></span>canMeasureEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::canMeasureEnergy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the <a class="el" href="classautopas_1_1AutoTuner.html" title="This class manages all logic related to the auto tuning mechanic.">AutoTuner</a> can take energy measurements. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="afbb2e7ebee62c9775fc18193427e26c5" name="afbb2e7ebee62c9775fc18193427e26c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb2e7ebee62c9775fc18193427e26c5">&#9670;&#160;</a></span>checkEarlyStoppingCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::AutoTuner::checkEarlyStoppingCondition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the current configuration performs so poorly that it shouldn't be resampled further within this tuning phase. </p>
<p>If the currently sampled configuration is worse than the current best configuration by more than the earlyStoppingFactor factor, it will not be sampled again this tuning phase. Uses the _estimateRuntimeFromSamples() function to estimate the runtimes. </p>

</div>
</div>
<a id="aed4b05aace993e15acdf69b4f0946ccc" name="aed4b05aace993e15acdf69b4f0946ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4b05aace993e15acdf69b4f0946ccc">&#9670;&#160;</a></span>forceRetune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::AutoTuner::forceRetune </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the internal tuner to enter a new tuning phase upon the next call to computeInteractions().   </p>

</div>
</div>
<a id="aad340bf7e91f7b47c951ff70c38c7a30" name="aad340bf7e91f7b47c951ff70c38c7a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad340bf7e91f7b47c951ff70c38c7a30">&#9670;&#160;</a></span>getConfigQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp; autopas::AutoTuner::getConfigQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the current queue of configurations. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad8c778b2db88b8c7cfcbd4417b33ed5f" name="ad8c778b2db88b8c7cfcbd4417b33ed5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c778b2db88b8c7cfcbd4417b33ed5f">&#9670;&#160;</a></span>getCurrentConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp; autopas::AutoTuner::getCurrentConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently selected configuration. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="adc45ebb44212a4438832c007918de4a8" name="adc45ebb44212a4438832c007918de4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc45ebb44212a4438832c007918de4a8">&#9670;&#160;</a></span>getEvidenceCollection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp; autopas::AutoTuner::getEvidenceCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the internal evidence collection. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a38a705e04679b24fbd0de7def40e38d1" name="a38a705e04679b24fbd0de7def40e38d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a705e04679b24fbd0de7def40e38d1">&#9670;&#160;</a></span>getNextConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a>, bool &gt; autopas::AutoTuner::getNextConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the tuner for the next configuration to use. </p>
<p>This either returns the already selected config or triggers a step of the tuning process. </p><dl class="section return"><dt>Returns</dt><dd>Tuple&lt;Next configuration to use, still tuning&gt;. </dd></dl>

</div>
</div>
<a id="ae067e7ec72d47901218da725b136f58b" name="ae067e7ec72d47901218da725b136f58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae067e7ec72d47901218da725b136f58b">&#9670;&#160;</a></span>getTuningMetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classautopas_1_1TuningMetricOption.html">TuningMetricOption</a> &amp; autopas::AutoTuner::getTuningMetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the primary metric for tuning. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7dc9c3399b98e20b23c642753ded91e5" name="a7dc9c3399b98e20b23c642753ded91e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc9c3399b98e20b23c642753ded91e5">&#9670;&#160;</a></span>getTuningStrategies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classautopas_1_1TuningStrategyInterface.html">TuningStrategyInterface</a> &gt; &gt; &amp; autopas::AutoTuner::getTuningStrategies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of tuning strategies that are used. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad450fa545a43e3b80924aabc5abbba29" name="ad450fa545a43e3b80924aabc5abbba29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad450fa545a43e3b80924aabc5abbba29">&#9670;&#160;</a></span>inFirstTuningIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::inFirstTuningIteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate if the tuner is in the first iteration of a tuning phase. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac10dcc9eac0aa2ffa243577bc12447cf" name="ac10dcc9eac0aa2ffa243577bc12447cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10dcc9eac0aa2ffa243577bc12447cf">&#9670;&#160;</a></span>initEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::initEnergy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize pmt sensor. </p>
<dl class="section return"><dt>Returns</dt><dd>True if energy measurements are enabled and possible. </dd></dl>

</div>
</div>
<a id="a9c5eb51d45b6653060f0e3347b015aba" name="a9c5eb51d45b6653060f0e3347b015aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5eb51d45b6653060f0e3347b015aba">&#9670;&#160;</a></span>inLastTuningIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::inLastTuningIteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate if the tuner is in the last iteration of the tuning phase. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac5383029952ce900fd2cf745aabaa634" name="ac5383029952ce900fd2cf745aabaa634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5383029952ce900fd2cf745aabaa634">&#9670;&#160;</a></span>inTuningPhase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::inTuningPhase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate if the tuner considers itself currently in a tuning phase according to its internal counters. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4869c59c2bc70ac244e27840a1f716c1" name="a4869c59c2bc70ac244e27840a1f716c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4869c59c2bc70ac244e27840a1f716c1">&#9670;&#160;</a></span>logTuningResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::AutoTuner::logTuningResult </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tuningIteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>tuningTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After a tuning phase has finished, write the result to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuningIteration</td><td></td></tr>
    <tr><td class="paramname">tuningTime</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd71cda0cc2c6f07b2108aaca118f609" name="acd71cda0cc2c6f07b2108aaca118f609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd71cda0cc2c6f07b2108aaca118f609">&#9670;&#160;</a></span>needsHomogeneityAndMaxDensityBeforePrepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::needsHomogeneityAndMaxDensityBeforePrepare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicator whether tuner needs homogeneity and max density information before the next call to <a class="el" href="classautopas_1_1AutoTuner.html#ae50e16a3864ee82c7e6b9525aa43a16b" title="Determines what live infos are needed and passes collected live info to the tuning strategies.">prepareIteration()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a27de7b1ab9f73c877eb316b79a4e63db" name="a27de7b1ab9f73c877eb316b79a4e63db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27de7b1ab9f73c877eb316b79a4e63db">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1AutoTuner.html">AutoTuner</a> &amp; autopas::AutoTuner::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1AutoTuner.html">AutoTuner</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae50e16a3864ee82c7e6b9525aa43a16b" name="ae50e16a3864ee82c7e6b9525aa43a16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50e16a3864ee82c7e6b9525aa43a16b">&#9670;&#160;</a></span>prepareIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::prepareIteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines what live infos are needed and passes collected live info to the tuning strategies. </p>
<dl class="section note"><dt>Note</dt><dd>The live info is not gathered here because then we would need the container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Bool indicating if live Infos are needed before the next call to tune </dd></dl>

</div>
</div>
<a id="ad32706623a5717a5564d01b4694cbcb5" name="ad32706623a5717a5564d01b4694cbcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32706623a5717a5564d01b4694cbcb5">&#9670;&#160;</a></span>receiveLiveInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::AutoTuner::receiveLiveInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1LiveInfo.html">LiveInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>liveInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass live info on to all tuning strategies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">liveInfo</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8f05fb22f0b00eaea592e4fa89ecf85" name="aa8f05fb22f0b00eaea592e4fa89ecf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f05fb22f0b00eaea592e4fa89ecf85">&#9670;&#160;</a></span>rejectConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a>, bool &gt; autopas::AutoTuner::rejectConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>rejectedConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>indefinitely</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the tuner that the given config is not applicable. </p>
<p>Since this operation might change the suggestion what configuration to try next, this next suggestion is returned.</p>
<dl class="section note"><dt>Note</dt><dd>The applicability checking logic was moved out of the tuner because it needed the container, thus raising the compile complexity.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rejectedConfig</td><td></td></tr>
    <tr><td class="paramname">indefinitely</td><td>Whether the given config should be completely removed from the search space (aka rejected indefinitely). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple&lt;Next configuration to use, still tuning&gt;. </dd></dl>

</div>
</div>
<a id="a7c0c30c81b4a96e2783c84a2d51c384d" name="a7c0c30c81b4a96e2783c84a2d51c384d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0c30c81b4a96e2783c84a2d51c384d">&#9670;&#160;</a></span>resetEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::resetEnergy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the rapl meter to prepare for a new measurement. </p>
<dl class="section return"><dt>Returns</dt><dd>True if energy measurements are possible on this system. </dd></dl>

</div>
</div>
<a id="a071591bc54c4a76ae1bd6a08bd6de8b7" name="a071591bc54c4a76ae1bd6a08bd6de8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071591bc54c4a76ae1bd6a08bd6de8b7">&#9670;&#160;</a></span>sampleEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; double, double, double, long &gt; autopas::AutoTuner::sampleEnergy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an energy measurement. </p>
<dl class="section return"><dt>Returns</dt><dd>Tuple&lt;PsysEnergy, PkgEnergy, RamEnergy, TotalEnergy&gt; </dd></dl>

</div>
</div>
<a id="a08333ac15c1db2f1ebd2820cc2d56d54" name="a08333ac15c1db2f1ebd2820cc2d56d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08333ac15c1db2f1ebd2820cc2d56d54">&#9670;&#160;</a></span>searchSpaceIsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::searchSpaceIsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicator function whether the search space has no configurations in it. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae200ca1f23fb9ca4f9f798cd5e443af6" name="ae200ca1f23fb9ca4f9f798cd5e443af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae200ca1f23fb9ca4f9f798cd5e443af6">&#9670;&#160;</a></span>searchSpaceIsTrivial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::searchSpaceIsTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicator function whether the search space consists of exactly one configuration. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af4f9c5fcb939e80d209a6a41721c3d16" name="af4f9c5fcb939e80d209a6a41721c3d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f9c5fcb939e80d209a6a41721c3d16">&#9670;&#160;</a></span>setRebuildFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::AutoTuner::setRebuildFrequency </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rebuildFrequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the _rebuildFrequency. </p>
<p>This is the average number of iterations per rebuild. This is used to dynamically change the _rebuildFrequency based on estimate in case of dynamic containers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rebuildFrequency</td><td>Current rebuild frequency in this instance of autopas, used by autopas for weighing rebuild and non-rebuild iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a796da93e86a1678f995acd6819e34e9e" name="a796da93e86a1678f995acd6819e34e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796da93e86a1678f995acd6819e34e9e">&#9670;&#160;</a></span>willRebuildNeighborLists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::AutoTuner::willRebuildNeighborLists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether rebuildNeighborLists() should be triggered in the next iteration. </p>
<p>This indicates a configuration change. In the non-tuning phase, the rebuildNeighborLists() is triggered in <a class="el" href="classautopas_1_1LogicHandler.html" title="The LogicHandler takes care of the containers s.t.">LogicHandler</a>. </p><dl class="section return"><dt>Returns</dt><dd>True if the current iteration counters indicate a rebuild in the next iteration due to a configuration change. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>autopas/tuning/<a class="el" href="AutoTuner_8h_source.html">AutoTuner.h</a></li>
<li>autopas/tuning/<a class="el" href="AutoTuner_8cpp.html">AutoTuner.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1VerletClusterLists.html">VerletClusterLists</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classautopas_1_1VerletClusterLists-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::VerletClusterLists&lt; Particle &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Particles are divided into clusters.  
 <a href="classautopas_1_1VerletClusterLists.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VerletClusterLists_8h_source.html">VerletClusterLists.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::VerletClusterLists&lt; Particle &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1VerletClusterLists__inherit__graph.png" border="0" usemap="#aautopas_1_1VerletClusterLists_3_01Particle_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1VerletClusterLists_3_01Particle_01_4_inherit__map" id="aautopas_1_1VerletClusterLists_3_01Particle_01_4_inherit__map">
<area shape="rect" title="Particles are divided into clusters." alt="" coords="248,37,444,77"/>
<area shape="rect" href="classautopas_1_1VerletClusterLists.html" title=" " alt="" coords="667,37,863,77"/>
<area shape="poly" title=" " alt="" coords="458,55,667,55,667,60,458,60"/>
<area shape="rect" href="classautopas_1_1ParticleContainerInterface.html" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas." alt="" coords="5,5,199,45"/>
<area shape="poly" title=" " alt="" coords="212,37,248,42,247,47,212,42"/>
<area shape="rect" href="classautopas_1_1internal_1_1ParticleDeletedObserver.html" title="Class that is notified when a particle is deleted." alt="" coords="12,69,192,109"/>
<area shape="poly" title=" " alt="" coords="205,73,248,68,248,73,206,78"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for autopas::VerletClusterLists&lt; Particle &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1VerletClusterLists__coll__graph.png" border="0" usemap="#aautopas_1_1VerletClusterLists_3_01Particle_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aautopas_1_1VerletClusterLists_3_01Particle_01_4_coll__map" id="aautopas_1_1VerletClusterLists_3_01Particle_01_4_coll__map">
<area shape="rect" title="Particles are divided into clusters." alt="" coords="247,37,443,77"/>
<area shape="rect" href="classautopas_1_1ParticleContainerInterface.html" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas." alt="" coords="5,5,199,45"/>
<area shape="poly" title=" " alt="" coords="213,37,247,42,246,47,212,42"/>
<area shape="rect" href="classautopas_1_1internal_1_1ParticleDeletedObserver.html" title="Class that is notified when a particle is deleted." alt="" coords="12,69,192,109"/>
<area shape="poly" title=" " alt="" coords="205,73,246,68,247,73,206,78"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structautopas_1_1VerletClusterLists_1_1ClusterRange.html">ClusterRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a cluster range used in the static cluster-thread-partition.  <a href="structautopas_1_1VerletClusterLists_1_1ClusterRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aada063ace3b9f8ac9d36d490983cbb83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#aada063ace3b9f8ac9d36d490983cbb83">VerletClusterLists</a> (const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax, double cutoff, double skinPerTimestep, unsigned int rebuildFrequency, size_t clusterSize, <a class="el" href="classautopas_1_1LoadEstimatorOption.html">LoadEstimatorOption</a> loadEstimator=<a class="el" href="classautopas_1_1LoadEstimatorOption.html#a0acdad94f9dac7d5704a9ca612a20c8ca9041bea590e9f47eafd12e04150895c8">LoadEstimatorOption::none</a>)</td></tr>
<tr class="memdesc:aada063ace3b9f8ac9d36d490983cbb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="classautopas_1_1VerletClusterLists.html" title="Particles are divided into clusters.">VerletClusterLists</a> class.  <br /></td></tr>
<tr class="separator:aada063ace3b9f8ac9d36d490983cbb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af802a5c9926c822ce6393d59473f754b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#af802a5c9926c822ce6393d59473f754b">getParticleCellTypeEnum</a> () const override</td></tr>
<tr class="memdesc:af802a5c9926c822ce6393d59473f754b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an Enum.  <br /></td></tr>
<tr class="separator:af802a5c9926c822ce6393d59473f754b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8887080a9bc1687dad671e68e9ef721f"><td class="memItemLeft" align="right" valign="top">ContainerOption&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a8887080a9bc1687dad671e68e9ef721f">getContainerType</a> () const override</td></tr>
<tr class="memdesc:a8887080a9bc1687dad671e68e9ef721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ContainerType.  <br /></td></tr>
<tr class="separator:a8887080a9bc1687dad671e68e9ef721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9ec2f59023aec7c3332bfaf495f0a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1BalancedTraversal.html#a1dd521e32c372a11307f670409f3efe8">BalancedTraversal::EstimatorFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a3f9ec2f59023aec7c3332bfaf495f0a5">getLoadEstimatorFunction</a> ()</td></tr>
<tr class="memdesc:a3f9ec2f59023aec7c3332bfaf495f0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the load estimation function depending on _loadEstimator.  <br /></td></tr>
<tr class="separator:a3f9ec2f59023aec7c3332bfaf495f0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6200cb4240d6e6d59d02b94fd197dfdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a6200cb4240d6e6d59d02b94fd197dfdf">iteratePairwise</a> (<a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *traversal) override</td></tr>
<tr class="memdesc:a6200cb4240d6e6d59d02b94fd197dfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all particle pairs in the container.  <br /></td></tr>
<tr class="separator:a6200cb4240d6e6d59d02b94fd197dfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bae77f2b03a8cbe140be410d4a159e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a68bae77f2b03a8cbe140be410d4a159e">reserve</a> (size_t numParticles, size_t numParticlesHaloEstimate) override</td></tr>
<tr class="memdesc:a68bae77f2b03a8cbe140be410d4a159e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for a given number of particles in the container and logic layers.    <br /></td></tr>
<tr class="separator:a68bae77f2b03a8cbe140be410d4a159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1288e9fb3e19d4264bacc99b92136315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a1288e9fb3e19d4264bacc99b92136315">addParticleImpl</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;p) override</td></tr>
<tr class="memdesc:a1288e9fb3e19d4264bacc99b92136315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given particle to the container.  <br /></td></tr>
<tr class="separator:a1288e9fb3e19d4264bacc99b92136315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad345d0180a903436328fb97c5f64e52a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#ad345d0180a903436328fb97c5f64e52a">addHaloParticleImpl</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;haloParticle) override</td></tr>
<tr class="memdesc:ad345d0180a903436328fb97c5f64e52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container that lies in the halo region of the container.  <br /></td></tr>
<tr class="separator:ad345d0180a903436328fb97c5f64e52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedbee3ccdba8ed38a9616ae42dd0fb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#abedbee3ccdba8ed38a9616ae42dd0fb5">updateHaloParticle</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;haloParticle) override</td></tr>
<tr class="memdesc:abedbee3ccdba8ed38a9616ae42dd0fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a halo particle of the container with the given haloParticle.  <br /></td></tr>
<tr class="separator:abedbee3ccdba8ed38a9616ae42dd0fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eda0dded57207d2e89dd100914f39f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a2eda0dded57207d2e89dd100914f39f4">deleteHaloParticles</a> () override</td></tr>
<tr class="memdesc:a2eda0dded57207d2e89dd100914f39f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all halo particles.  <br /></td></tr>
<tr class="separator:a2eda0dded57207d2e89dd100914f39f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d7354afa9ae2cb444eadc920be1cb0"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a92d7354afa9ae2cb444eadc920be1cb0">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax) const override</td></tr>
<tr class="memdesc:a92d7354afa9ae2cb444eadc920be1cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.    <br /></td></tr>
<tr class="separator:a92d7354afa9ae2cb444eadc920be1cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aa194c82bcadcd752701c0b583beb1"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a05aa194c82bcadcd752701c0b583beb1">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior) const override</td></tr>
<tr class="memdesc:a05aa194c82bcadcd752701c0b583beb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.  <br /></td></tr>
<tr class="separator:a05aa194c82bcadcd752701c0b583beb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29141171aa9e78ae7d1042b98a4d884a"><td class="memTemplParams" colspan="2">template&lt;bool regionIter&gt; </td></tr>
<tr class="memitem:a29141171aa9e78ae7d1042b98a4d884a"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a29141171aa9e78ae7d1042b98a4d884a">getParticleImpl</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax) const</td></tr>
<tr class="memdesc:a29141171aa9e78ae7d1042b98a4d884a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container specific implementation for getParticle.  <br /></td></tr>
<tr class="separator:a29141171aa9e78ae7d1042b98a4d884a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0f97d5ddfdc092db09b0fd796d3aca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a9b0f97d5ddfdc092db09b0fd796d3aca">deleteParticle</a> (<a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;particle) override</td></tr>
<tr class="memdesc:a9b0f97d5ddfdc092db09b0fd796d3aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the given particle as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:a9b0f97d5ddfdc092db09b0fd796d3aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6cf0b5f59d7cd93b6caeaacda943f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a2e6cf0b5f59d7cd93b6caeaacda943f8">deleteParticle</a> (size_t cellIndex, size_t particleIndex) override</td></tr>
<tr class="memdesc:a2e6cf0b5f59d7cd93b6caeaacda943f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the particle at the given index positions as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:a2e6cf0b5f59d7cd93b6caeaacda943f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53dbd08e3ac36cfc78d39e6e1b65b5d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#ab53dbd08e3ac36cfc78d39e6e1b65b5d">updateContainer</a> (bool keepNeighborListsValid) override</td></tr>
<tr class="memdesc:ab53dbd08e3ac36cfc78d39e6e1b65b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the container.  <br /></td></tr>
<tr class="separator:ab53dbd08e3ac36cfc78d39e6e1b65b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01918ad43ab0768b187d11ebefe82de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1TraversalSelectorInfo.html">TraversalSelectorInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#aa01918ad43ab0768b187d11ebefe82de">getTraversalSelectorInfo</a> () const override</td></tr>
<tr class="memdesc:aa01918ad43ab0768b187d11ebefe82de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a traversal selector info for this container.  <br /></td></tr>
<tr class="separator:aa01918ad43ab0768b187d11ebefe82de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec3eb7ab9f2b0afbcb1de85cef31b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a4ec3eb7ab9f2b0afbcb1de85cef31b9a">begin</a> (IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, false &gt;::ParticleVecType *additionalVectors=nullptr) override</td></tr>
<tr class="memdesc:a4ec3eb7ab9f2b0afbcb1de85cef31b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:a4ec3eb7ab9f2b0afbcb1de85cef31b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96ebddcbdfe0ecd8fd8dd250b1d24ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#af96ebddcbdfe0ecd8fd8dd250b1d24ec">begin</a> (IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, false &gt;::ParticleVecType *additionalVectors=nullptr) const override</td></tr>
<tr class="memdesc:af96ebddcbdfe0ecd8fd8dd250b1d24ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:af96ebddcbdfe0ecd8fd8dd250b1d24ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a351898213cf28aa148ff51a677dd4"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a97a351898213cf28aa148ff51a677dd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a97a351898213cf28aa148ff51a677dd4">forEach</a> (Lambda forEachLambda, IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo)</td></tr>
<tr class="memdesc:a97a351898213cf28aa148ff51a677dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code on all particles in this container as defined by a lambda function.    <br /></td></tr>
<tr class="separator:a97a351898213cf28aa148ff51a677dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b9ba28380493f2027b05a0eecd9b10"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:af4b9ba28380493f2027b05a0eecd9b10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#af4b9ba28380493f2027b05a0eecd9b10">forEach</a> (Lambda forEachLambda, IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo) const</td></tr>
<tr class="memdesc:af4b9ba28380493f2027b05a0eecd9b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code on all particles in this container as defined by a lambda function.    <br /></td></tr>
<tr class="separator:af4b9ba28380493f2027b05a0eecd9b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9560d06bd81216c7f060455a40621c27"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:a9560d06bd81216c7f060455a40621c27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a9560d06bd81216c7f060455a40621c27">reduce</a> (Lambda reduceLambda, A &amp;result, IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo)</td></tr>
<tr class="memdesc:a9560d06bd81216c7f060455a40621c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce properties of particles as defined by a lambda function.    <br /></td></tr>
<tr class="separator:a9560d06bd81216c7f060455a40621c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62afa4c87b516012a31381ac4cc4561a"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:a62afa4c87b516012a31381ac4cc4561a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a62afa4c87b516012a31381ac4cc4561a">reduce</a> (Lambda reduceLambda, A &amp;result, IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo) const</td></tr>
<tr class="memdesc:a62afa4c87b516012a31381ac4cc4561a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce properties of particles as defined by a lambda function.    <br /></td></tr>
<tr class="separator:a62afa4c87b516012a31381ac4cc4561a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5616f0f10c9d62147da14905be919f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a5616f0f10c9d62147da14905be919f70">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, true &gt;::ParticleVecType *additionalVectors) override</td></tr>
<tr class="memdesc:a5616f0f10c9d62147da14905be919f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .    <br /></td></tr>
<tr class="separator:a5616f0f10c9d62147da14905be919f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763a3b7b6aaaef39e78c8cd0f838d290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a763a3b7b6aaaef39e78c8cd0f838d290">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, true &gt;::ParticleVecType *additionalVectors) const override</td></tr>
<tr class="memdesc:a763a3b7b6aaaef39e78c8cd0f838d290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .    <br /></td></tr>
<tr class="separator:a763a3b7b6aaaef39e78c8cd0f838d290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da6ad26f69e03d99265f4d97ce47074"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a5da6ad26f69e03d99265f4d97ce47074"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a5da6ad26f69e03d99265f4d97ce47074">forEachInRegion</a> (Lambda forEachLambda, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo)</td></tr>
<tr class="memdesc:a5da6ad26f69e03d99265f4d97ce47074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code on all particles in this container in a certain region as defined by a lambda function.    <br /></td></tr>
<tr class="separator:a5da6ad26f69e03d99265f4d97ce47074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336bc211cfecdf1cad4d471f7b1f1ad7"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a336bc211cfecdf1cad4d471f7b1f1ad7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a336bc211cfecdf1cad4d471f7b1f1ad7">forEachInRegion</a> (Lambda forEachLambda, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo) const</td></tr>
<tr class="memdesc:a336bc211cfecdf1cad4d471f7b1f1ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code on all particles in this container in a certain region as defined by a lambda function.    <br /></td></tr>
<tr class="separator:a336bc211cfecdf1cad4d471f7b1f1ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52426d4f6bfcf859d0e000894f3dc93"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:ae52426d4f6bfcf859d0e000894f3dc93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#ae52426d4f6bfcf859d0e000894f3dc93">reduceInRegion</a> (Lambda reduceLambda, A &amp;result, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo)</td></tr>
<tr class="memdesc:ae52426d4f6bfcf859d0e000894f3dc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code on all particles in this container in a certain region as defined by a lambda function.    <br /></td></tr>
<tr class="separator:ae52426d4f6bfcf859d0e000894f3dc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abf4075f7386c326d46ef05474fe60b"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:a2abf4075f7386c326d46ef05474fe60b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a2abf4075f7386c326d46ef05474fe60b">reduceInRegion</a> (Lambda reduceLambda, A &amp;result, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo) const</td></tr>
<tr class="memdesc:a2abf4075f7386c326d46ef05474fe60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute code on all particles in this container in a certain region as defined by a lambda function.    <br /></td></tr>
<tr class="separator:a2abf4075f7386c326d46ef05474fe60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99122f3d6111eb888b00874173b622e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a99122f3d6111eb888b00874173b622e9">rebuildNeighborLists</a> (<a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *traversal) override</td></tr>
<tr class="memdesc:a99122f3d6111eb888b00874173b622e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuilds the neighbor lists.  <br /></td></tr>
<tr class="separator:a99122f3d6111eb888b00874173b622e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdeffcf911e21cebe8f1e7e5923dfb89"><td class="memTemplParams" colspan="2">template&lt;bool inParallel, class LoopBody &gt; </td></tr>
<tr class="memitem:acdeffcf911e21cebe8f1e7e5923dfb89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#acdeffcf911e21cebe8f1e7e5923dfb89">traverseClusters</a> (LoopBody &amp;&amp;loopBody)</td></tr>
<tr class="memdesc:acdeffcf911e21cebe8f1e7e5923dfb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to iterate over all clusters.  <br /></td></tr>
<tr class="separator:acdeffcf911e21cebe8f1e7e5923dfb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1705589f4380d49066f64fc354602549"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a1705589f4380d49066f64fc354602549">size</a> () const override</td></tr>
<tr class="memdesc:a1705589f4380d49066f64fc354602549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of all particles stored in this container (owned + halo + dummy).  <br /></td></tr>
<tr class="separator:a1705589f4380d49066f64fc354602549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b2334361d346fc174bb322a1dd4b6a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a74b2334361d346fc174bb322a1dd4b6a">getNumberOfParticles</a> (IteratorBehavior behavior) const override</td></tr>
<tr class="memdesc:a74b2334361d346fc174bb322a1dd4b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.    <br /></td></tr>
<tr class="separator:a74b2334361d346fc174bb322a1dd4b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866794669cfb47663d369b27efb7e172"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a866794669cfb47663d369b27efb7e172">getClusterThreadPartition</a> () const</td></tr>
<tr class="memdesc:a866794669cfb47663d369b27efb7e172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cluster-thread-partition.  <br /></td></tr>
<tr class="separator:a866794669cfb47663d369b27efb7e172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a517f813e0ee789841aeea4c1c538db"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a9a517f813e0ee789841aeea4c1c538db">getNumClusters</a> () const</td></tr>
<tr class="memdesc:a9a517f813e0ee789841aeea4c1c538db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of clusters in this container.  <br /></td></tr>
<tr class="separator:a9a517f813e0ee789841aeea4c1c538db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5344aa9cf0d83556aa828de8464ad8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a8a5344aa9cf0d83556aa828de8464ad8">getTowerSideLength</a> () const</td></tr>
<tr class="memdesc:a8a5344aa9cf0d83556aa828de8464ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the grid side length of the grids in the container.  <br /></td></tr>
<tr class="separator:a8a5344aa9cf0d83556aa828de8464ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb4a13221cfc65a9b9fc45c867fd5a4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a1fb4a13221cfc65a9b9fc45c867fd5a4">getTowersPerDimension</a> () const</td></tr>
<tr class="memdesc:a1fb4a13221cfc65a9b9fc45c867fd5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of grids per dimension on the container.  <br /></td></tr>
<tr class="separator:a1fb4a13221cfc65a9b9fc45c867fd5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb76ce5c97f54425b6cdf975be1b2a8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a9cb76ce5c97f54425b6cdf975be1b2a8">getClusterSize</a> () const</td></tr>
<tr class="memdesc:a9cb76ce5c97f54425b6cdf975be1b2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of particles in each cluster.  <br /></td></tr>
<tr class="separator:a9cb76ce5c97f54425b6cdf975be1b2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fc96d891c9f9cd5f9340511e6465a3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a13fc96d891c9f9cd5f9340511e6465a3">getNumTowersPerInteractionLength</a> () const</td></tr>
<tr class="memdesc:a13fc96d891c9f9cd5f9340511e6465a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the towers per interaction length.  <br /></td></tr>
<tr class="separator:a13fc96d891c9f9cd5f9340511e6465a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7e55d086b6fc7e109007cf5e8def69"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classautopas_1_1Functor.html">Functor</a> &gt; </td></tr>
<tr class="memitem:a3c7e55d086b6fc7e109007cf5e8def69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a3c7e55d086b6fc7e109007cf5e8def69">loadParticlesIntoSoAs</a> (<a class="el" href="classautopas_1_1Functor.html">Functor</a> *functor)</td></tr>
<tr class="memdesc:a3c7e55d086b6fc7e109007cf5e8def69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads all particles of the container in their correct <a class="el" href="classautopas_1_1SoA.html" title="Structur of the array class.">SoA</a> and generates the SoAViews for the clusters.  <br /></td></tr>
<tr class="separator:a3c7e55d086b6fc7e109007cf5e8def69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80817ed04af108f6c439ccef0f994d4"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classautopas_1_1Functor.html">Functor</a> &gt; </td></tr>
<tr class="memitem:af80817ed04af108f6c439ccef0f994d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#af80817ed04af108f6c439ccef0f994d4">extractParticlesFromSoAs</a> (<a class="el" href="classautopas_1_1Functor.html">Functor</a> *functor)</td></tr>
<tr class="memdesc:af80817ed04af108f6c439ccef0f994d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts all SoAs of the container into the particles.  <br /></td></tr>
<tr class="separator:af80817ed04af108f6c439ccef0f994d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7070472c03bfb3f68a79a42121f7dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1internal_1_1ClusterTower.html">internal::ClusterTower</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a0a7070472c03bfb3f68a79a42121f7dc">getTowerByIndex</a> (size_t x, size_t y)</td></tr>
<tr class="memdesc:a0a7070472c03bfb3f68a79a42121f7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the tower for the given tower grid coordinates.  <br /></td></tr>
<tr class="separator:a0a7070472c03bfb3f68a79a42121f7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99739ec1220754cfd1a83c805b71abe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1internal_1_1ClusterTowerBlock2D.html">internal::ClusterTowerBlock2D</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a99739ec1220754cfd1a83c805b71abe0">getTowerBlock</a> ()</td></tr>
<tr class="memdesc:a99739ec1220754cfd1a83c805b71abe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the cell block.  <br /></td></tr>
<tr class="separator:a99739ec1220754cfd1a83c805b71abe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffae603e4343353b5ebe0d7d285e8c2"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#acffae603e4343353b5ebe0d7d285e8c2">getBoxMax</a> () const override</td></tr>
<tr class="memdesc:acffae603e4343353b5ebe0d7d285e8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the upper corner of the container without halo.  <br /></td></tr>
<tr class="separator:acffae603e4343353b5ebe0d7d285e8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dc5f12150bf630249f26d3c62972f0"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#aa7dc5f12150bf630249f26d3c62972f0">getHaloBoxMax</a> () const</td></tr>
<tr class="memdesc:aa7dc5f12150bf630249f26d3c62972f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the upper corner of the halo box.  <br /></td></tr>
<tr class="separator:aa7dc5f12150bf630249f26d3c62972f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277ba0868463e13f96dbf747b961d3a6"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a277ba0868463e13f96dbf747b961d3a6">getBoxMin</a> () const override</td></tr>
<tr class="memdesc:a277ba0868463e13f96dbf747b961d3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lower corner of the container without halo.  <br /></td></tr>
<tr class="separator:a277ba0868463e13f96dbf747b961d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d449d21cec027a29b921aee3e6dec3a"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a0d449d21cec027a29b921aee3e6dec3a">getHaloBoxMin</a> () const</td></tr>
<tr class="memdesc:a0d449d21cec027a29b921aee3e6dec3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lower corner of the halo box.  <br /></td></tr>
<tr class="separator:a0d449d21cec027a29b921aee3e6dec3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab086ec424ccf1ce4fdd949ca66639d64"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#ab086ec424ccf1ce4fdd949ca66639d64">getCutoff</a> () const override</td></tr>
<tr class="memdesc:ab086ec424ccf1ce4fdd949ca66639d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cutoff of the container.  <br /></td></tr>
<tr class="separator:ab086ec424ccf1ce4fdd949ca66639d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914e963b6177a3f557c69ee3d9f241e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a914e963b6177a3f557c69ee3d9f241e1">setCutoff</a> (double cutoff) override</td></tr>
<tr class="memdesc:a914e963b6177a3f557c69ee3d9f241e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cutoff of the container.  <br /></td></tr>
<tr class="separator:a914e963b6177a3f557c69ee3d9f241e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1524bdd7b6db15ecb490bf2515d31863"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a1524bdd7b6db15ecb490bf2515d31863">getVerletSkin</a> () const override</td></tr>
<tr class="memdesc:a1524bdd7b6db15ecb490bf2515d31863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the verletSkin of the container verletSkinPerTimestep*rebuildFrequency.  <br /></td></tr>
<tr class="separator:a1524bdd7b6db15ecb490bf2515d31863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3152d51db17d72575026ee6774165388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a3152d51db17d72575026ee6774165388">setSkinPerTimestep</a> (double skinPerTimestep)</td></tr>
<tr class="memdesc:a3152d51db17d72575026ee6774165388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the verlet skin length per timestep for the container.  <br /></td></tr>
<tr class="separator:a3152d51db17d72575026ee6774165388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b46f8d5d321d85ac45aa6a1f050ff8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a05b46f8d5d321d85ac45aa6a1f050ff8">getRebuildFrequency</a> ()</td></tr>
<tr class="memdesc:a05b46f8d5d321d85ac45aa6a1f050ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rebuild Frequency value for the container.  <br /></td></tr>
<tr class="separator:a05b46f8d5d321d85ac45aa6a1f050ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d0dc79ba35a126f559e6e1271c388f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#aa2d0dc79ba35a126f559e6e1271c388f">setRebuildFrequency</a> (unsigned int rebuildFrequency)</td></tr>
<tr class="memdesc:aa2d0dc79ba35a126f559e6e1271c388f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rebuild Frequency value for the container.  <br /></td></tr>
<tr class="separator:aa2d0dc79ba35a126f559e6e1271c388f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b313d604c233b44eb7b23b15884bea9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a6b313d604c233b44eb7b23b15884bea9">getInteractionLength</a> () const override</td></tr>
<tr class="memdesc:a6b313d604c233b44eb7b23b15884bea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the interaction length (cutoff+skin) of the container.  <br /></td></tr>
<tr class="separator:a6b313d604c233b44eb7b23b15884bea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb72d9c6414223bc69de1f420e5b3c80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#adb72d9c6414223bc69de1f420e5b3c80">deleteAllParticles</a> () override</td></tr>
<tr class="memdesc:adb72d9c6414223bc69de1f420e5b3c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles.  <br /></td></tr>
<tr class="separator:adb72d9c6414223bc69de1f420e5b3c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2f6a366ddbd9d150df05fdfd953023"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">internal::VerletClusterListsRebuilder</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::NeighborListsBuffer_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a2e2f6a366ddbd9d150df05fdfd953023">getNeighborLists</a> () const</td></tr>
<tr class="memdesc:a2e2f6a366ddbd9d150df05fdfd953023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the neighbor lists buffer object.  <br /></td></tr>
<tr class="separator:a2e2f6a366ddbd9d150df05fdfd953023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656625734a4e3344e3c894f765468662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a656625734a4e3344e3c894f765468662">rebuildTowersAndClusters</a> (bool newton3)</td></tr>
<tr class="memdesc:a656625734a4e3344e3c894f765468662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new VerletClusterListsRebuilder and uses it to rebuild the towers and the clusters.  <br /></td></tr>
<tr class="separator:a656625734a4e3344e3c894f765468662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a82439e3e1dea8533fa5dcf4047c4f"><td class="memTemplParams" colspan="2">template&lt;class LoopBody &gt; </td></tr>
<tr class="memitem:a09a82439e3e1dea8533fa5dcf4047c4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a09a82439e3e1dea8533fa5dcf4047c4f">traverseClustersSequential</a> (LoopBody &amp;&amp;loopBody)</td></tr>
<tr class="memdesc:a09a82439e3e1dea8533fa5dcf4047c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to sequentially iterate over all owned clusters.  <br /></td></tr>
<tr class="separator:a09a82439e3e1dea8533fa5dcf4047c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9d645ae260dfc7714d67fa360b2247"><td class="memTemplParams" colspan="2">template&lt;class LoopBody &gt; </td></tr>
<tr class="memitem:a1b9d645ae260dfc7714d67fa360b2247"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a1b9d645ae260dfc7714d67fa360b2247">traverseClustersParallel</a> (LoopBody &amp;&amp;loopBody)</td></tr>
<tr class="memdesc:a1b9d645ae260dfc7714d67fa360b2247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to iterate over all clusters in parallel.  <br /></td></tr>
<tr class="separator:a1b9d645ae260dfc7714d67fa360b2247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1ParticleContainerInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1ParticleContainerInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface&lt; Particle &gt;</a></td></tr>
<tr class="memitem:aa0d021848386b655665099f6536d38f3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa0d021848386b655665099f6536d38f3">getParticleCellTypeEnum</a> () const =0</td></tr>
<tr class="memdesc:aa0d021848386b655665099f6536d38f3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an Enum.  <br /></td></tr>
<tr class="separator:aa0d021848386b655665099f6536d38f3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39724ab6b2de64346806d583d4551057 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top"><a id="a39724ab6b2de64346806d583d4551057" name="a39724ab6b2de64346806d583d4551057"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleContainerInterface</b> ()=default</td></tr>
<tr class="memdesc:a39724ab6b2de64346806d583d4551057 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a39724ab6b2de64346806d583d4551057 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c2c64bd4786635537cbdb17ba1b416 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top"><a id="af3c2c64bd4786635537cbdb17ba1b416" name="af3c2c64bd4786635537cbdb17ba1b416"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~ParticleContainerInterface</b> ()=default</td></tr>
<tr class="memdesc:af3c2c64bd4786635537cbdb17ba1b416 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of <a class="el" href="classautopas_1_1ParticleContainerInterface.html" title="The ParticleContainerInterface class provides a basic interface for all Containers within AutoPas.">ParticleContainerInterface</a>. <br /></td></tr>
<tr class="separator:af3c2c64bd4786635537cbdb17ba1b416 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8082e38c0d26fe92ae93779035b6d7 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a7d8082e38c0d26fe92ae93779035b6d7">ParticleContainerInterface</a> (const <a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp;obj)=delete</td></tr>
<tr class="memdesc:a7d8082e38c0d26fe92ae93779035b6d7 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the copy constructor to prevent unwanted copies.  <br /></td></tr>
<tr class="separator:a7d8082e38c0d26fe92ae93779035b6d7 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca910b81c9161c79418fbc5062b62ef inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a6ca910b81c9161c79418fbc5062b62ef">operator=</a> (const <a class="el" href="classautopas_1_1ParticleContainerInterface.html">ParticleContainerInterface</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a6ca910b81c9161c79418fbc5062b62ef inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the copy assignment operator to prevent unwanted copies.  <br /></td></tr>
<tr class="separator:a6ca910b81c9161c79418fbc5062b62ef inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c5851f31e16a544c291b03a3081762 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual ContainerOption&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a78c5851f31e16a544c291b03a3081762">getContainerType</a> () const =0</td></tr>
<tr class="memdesc:a78c5851f31e16a544c291b03a3081762 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ContainerType.  <br /></td></tr>
<tr class="separator:a78c5851f31e16a544c291b03a3081762 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee129c51f1fe9a688a0a4f923c0020a inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#afee129c51f1fe9a688a0a4f923c0020a">reserve</a> (size_t numParticles, size_t numParticlesHaloEstimate)=0</td></tr>
<tr class="memdesc:afee129c51f1fe9a688a0a4f923c0020a inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve memory for a given number of particles in the container and logic layers.    <br /></td></tr>
<tr class="separator:afee129c51f1fe9a688a0a4f923c0020a inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c923772f539b5c3f6b8e4a7f6cc426 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memTemplParams" colspan="2">template&lt;bool checkInBox = true&gt; </td></tr>
<tr class="memitem:ae7c923772f539b5c3f6b8e4a7f6cc426 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ae7c923772f539b5c3f6b8e4a7f6cc426">addParticle</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;p)</td></tr>
<tr class="memdesc:ae7c923772f539b5c3f6b8e4a7f6cc426 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container.  <br /></td></tr>
<tr class="separator:ae7c923772f539b5c3f6b8e4a7f6cc426 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a6197fc11a19d594bebce507cc6625 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memTemplParams" colspan="2">template&lt;bool checkInBox = true&gt; </td></tr>
<tr class="memitem:aa3a6197fc11a19d594bebce507cc6625 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa3a6197fc11a19d594bebce507cc6625">addHaloParticle</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;haloParticle)</td></tr>
<tr class="memdesc:aa3a6197fc11a19d594bebce507cc6625 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container that lies in the halo region of the container.  <br /></td></tr>
<tr class="separator:aa3a6197fc11a19d594bebce507cc6625 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dbde7d49563a7b88e2b2c5f0de9b07 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a08dbde7d49563a7b88e2b2c5f0de9b07">updateHaloParticle</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;haloParticle)=0</td></tr>
<tr class="memdesc:a08dbde7d49563a7b88e2b2c5f0de9b07 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a halo particle of the container with the given haloParticle.  <br /></td></tr>
<tr class="separator:a08dbde7d49563a7b88e2b2c5f0de9b07 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfccbe1d9d20fb331152c427b6dd9a3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#afdfccbe1d9d20fb331152c427b6dd9a3">rebuildNeighborLists</a> (<a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *traversal)=0</td></tr>
<tr class="memdesc:afdfccbe1d9d20fb331152c427b6dd9a3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuilds the neighbor lists.  <br /></td></tr>
<tr class="separator:afdfccbe1d9d20fb331152c427b6dd9a3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c21f6471b6b201fd02bed146182cbfa inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4c21f6471b6b201fd02bed146182cbfa">deleteHaloParticles</a> ()=0</td></tr>
<tr class="memdesc:a4c21f6471b6b201fd02bed146182cbfa inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all halo particles.  <br /></td></tr>
<tr class="separator:a4c21f6471b6b201fd02bed146182cbfa inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72611bd7d393897565b99b1e9d3f1d50 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a72611bd7d393897565b99b1e9d3f1d50">deleteAllParticles</a> ()=0</td></tr>
<tr class="memdesc:a72611bd7d393897565b99b1e9d3f1d50 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles.  <br /></td></tr>
<tr class="separator:a72611bd7d393897565b99b1e9d3f1d50 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4643b9f9629050b3731ec5326247692 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ad4643b9f9629050b3731ec5326247692">getNumberOfParticles</a> (IteratorBehavior behavior=IteratorBehavior::owned) const =0</td></tr>
<tr class="memdesc:ad4643b9f9629050b3731ec5326247692 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.  <br /></td></tr>
<tr class="separator:ad4643b9f9629050b3731ec5326247692 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e6a361098c54b400b75365d2ce32a9 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab5e6a361098c54b400b75365d2ce32a9">size</a> () const =0</td></tr>
<tr class="memdesc:ab5e6a361098c54b400b75365d2ce32a9 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of particles saved in the container (owned + halo + dummy).  <br /></td></tr>
<tr class="separator:ab5e6a361098c54b400b75365d2ce32a9 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01662c901808511a2785ecad6f536c32 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, true, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a01662c901808511a2785ecad6f536c32">begin</a> (IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, true, false &gt;::ParticleVecType *additionalVectors=nullptr)=0</td></tr>
<tr class="memdesc:a01662c901808511a2785ecad6f536c32 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .  <br /></td></tr>
<tr class="separator:a01662c901808511a2785ecad6f536c32 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d789b9ff0340a621d6d868937be162 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa3d789b9ff0340a621d6d868937be162">begin</a> (IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, false, false &gt;::ParticleVecType *additionalVectors=nullptr) const =0</td></tr>
<tr class="memdesc:aa3d789b9ff0340a621d6d868937be162 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:aa3d789b9ff0340a621d6d868937be162 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8718a933cb5e777e2f5096091daa1b45 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a8718a933cb5e777e2f5096091daa1b45">cbegin</a> (IteratorBehavior behavior=autopas::IteratorBehavior::ownedOrHalo, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, false, false &gt;::ParticleVecType *additionalVectors=nullptr) const final</td></tr>
<tr class="memdesc:a8718a933cb5e777e2f5096091daa1b45 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .    <br /></td></tr>
<tr class="separator:a8718a933cb5e777e2f5096091daa1b45 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9089e195a798b946b7a5424f80cd296 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, true, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ae9089e195a798b946b7a5424f80cd296">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, true, true &gt;::ParticleVecType *additionalVectors=nullptr)=0</td></tr>
<tr class="memdesc:ae9089e195a798b946b7a5424f80cd296 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .  <br /></td></tr>
<tr class="separator:ae9089e195a798b946b7a5424f80cd296 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad205a0ca53c65e2a5fdfca929d424bf3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, false, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ad205a0ca53c65e2a5fdfca929d424bf3">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior, typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a>, false, true &gt;::ParticleVecType *additionalVectors=nullptr) const =0</td></tr>
<tr class="memdesc:ad205a0ca53c65e2a5fdfca929d424bf3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .    <br /></td></tr>
<tr class="separator:ad205a0ca53c65e2a5fdfca929d424bf3 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791c5f88b0a78b5d9fb5e993dd949def inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a791c5f88b0a78b5d9fb5e993dd949def">end</a> () const</td></tr>
<tr class="memdesc:a791c5f88b0a78b5d9fb5e993dd949def inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">End expression for all containers, this simply returns false.  <br /></td></tr>
<tr class="separator:a791c5f88b0a78b5d9fb5e993dd949def inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a28b26596e40f2c517edb57ba5383d inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ac9a28b26596e40f2c517edb57ba5383d">iteratePairwise</a> (<a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *traversal)=0</td></tr>
<tr class="memdesc:ac9a28b26596e40f2c517edb57ba5383d inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all particle pairs in the container.  <br /></td></tr>
<tr class="separator:ac9a28b26596e40f2c517edb57ba5383d inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe78d425e123737e61a77a218ece7031 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#afe78d425e123737e61a77a218ece7031">getBoxMax</a> () const =0</td></tr>
<tr class="memdesc:afe78d425e123737e61a77a218ece7031 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the upper corner of the container without halo.  <br /></td></tr>
<tr class="separator:afe78d425e123737e61a77a218ece7031 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9b73ca3fbd7a346c7ceccc9f2a2b66 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#afc9b73ca3fbd7a346c7ceccc9f2a2b66">getBoxMin</a> () const =0</td></tr>
<tr class="memdesc:afc9b73ca3fbd7a346c7ceccc9f2a2b66 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lower corner of the container without halo.  <br /></td></tr>
<tr class="separator:afc9b73ca3fbd7a346c7ceccc9f2a2b66 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cde802a2682931d2c8fbea7188742ff inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4cde802a2682931d2c8fbea7188742ff">getCutoff</a> () const =0</td></tr>
<tr class="memdesc:a4cde802a2682931d2c8fbea7188742ff inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cutoff of the container.  <br /></td></tr>
<tr class="separator:a4cde802a2682931d2c8fbea7188742ff inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a8be37e00420b0006bf145fe731cb9 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a65a8be37e00420b0006bf145fe731cb9">setCutoff</a> (double cutoff)=0</td></tr>
<tr class="memdesc:a65a8be37e00420b0006bf145fe731cb9 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cutoff of the container.  <br /></td></tr>
<tr class="separator:a65a8be37e00420b0006bf145fe731cb9 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff79b9a83a997b3c2fe9371557459a44 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aff79b9a83a997b3c2fe9371557459a44">getVerletSkin</a> () const =0</td></tr>
<tr class="memdesc:aff79b9a83a997b3c2fe9371557459a44 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the verletSkin of the container verletSkinPerTimestep*rebuildFrequency.  <br /></td></tr>
<tr class="separator:aff79b9a83a997b3c2fe9371557459a44 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2191ad8b6814478b7ccca24081468f99 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a2191ad8b6814478b7ccca24081468f99">getInteractionLength</a> () const =0</td></tr>
<tr class="memdesc:a2191ad8b6814478b7ccca24081468f99 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the interaction length (cutoff+skin) of the container.  <br /></td></tr>
<tr class="separator:a2191ad8b6814478b7ccca24081468f99 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5895f71653f46875dbb4c1a987b995d inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a9eb1026f766e31bf170af8634f180d1d">ParticleType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#af5895f71653f46875dbb4c1a987b995d">updateContainer</a> (bool keepNeighborListsValid)=0</td></tr>
<tr class="memdesc:af5895f71653f46875dbb4c1a987b995d inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the container.  <br /></td></tr>
<tr class="separator:af5895f71653f46875dbb4c1a987b995d inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0792166b79e13d3f310ba67bc7531432 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1TraversalSelectorInfo.html">TraversalSelectorInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a0792166b79e13d3f310ba67bc7531432">getTraversalSelectorInfo</a> () const =0</td></tr>
<tr class="memdesc:a0792166b79e13d3f310ba67bc7531432 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a traversal selector info for this container.  <br /></td></tr>
<tr class="separator:a0792166b79e13d3f310ba67bc7531432 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3733affc7fb253c28f8dac03713d1252 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">std::set&lt; TraversalOption &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a3733affc7fb253c28f8dac03713d1252">getAllTraversals</a> () const</td></tr>
<tr class="memdesc:a3733affc7fb253c28f8dac03713d1252 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a list of all traversals that are theoretically applicable to this container.  <br /></td></tr>
<tr class="separator:a3733affc7fb253c28f8dac03713d1252 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787869df00344fe67ce760549b3c3647 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual std::tuple&lt; const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a787869df00344fe67ce760549b3c3647">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior) const =0</td></tr>
<tr class="memdesc:a787869df00344fe67ce760549b3c3647 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.  <br /></td></tr>
<tr class="separator:a787869df00344fe67ce760549b3c3647 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e00528190c8092a77b18c7acc9d4e6 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual std::tuple&lt; const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa1e00528190c8092a77b18c7acc9d4e6">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax) const =0</td></tr>
<tr class="memdesc:aa1e00528190c8092a77b18c7acc9d4e6 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.    <br /></td></tr>
<tr class="separator:aa1e00528190c8092a77b18c7acc9d4e6 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d626a98a9cb8c5fcc13659ebc77143 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab9d626a98a9cb8c5fcc13659ebc77143">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior, const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax)</td></tr>
<tr class="memdesc:ab9d626a98a9cb8c5fcc13659ebc77143 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.      <br /></td></tr>
<tr class="separator:ab9d626a98a9cb8c5fcc13659ebc77143 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af470e17aeccdf4bf66ec7dea9761b19b inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#af470e17aeccdf4bf66ec7dea9761b19b">getParticle</a> (size_t cellIndex, size_t particleIndex, IteratorBehavior iteratorBehavior)</td></tr>
<tr class="memdesc:af470e17aeccdf4bf66ec7dea9761b19b inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the pointer to a particle, identified via a cell and particle index.    <br /></td></tr>
<tr class="separator:af470e17aeccdf4bf66ec7dea9761b19b inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8640b3773e750e28703a686fba89aa11 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a8640b3773e750e28703a686fba89aa11">deleteParticle</a> (<a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;particle)=0</td></tr>
<tr class="memdesc:a8640b3773e750e28703a686fba89aa11 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the given particle as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:a8640b3773e750e28703a686fba89aa11 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa2105a7a4189c3d0f3a8b519d635b8 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a5fa2105a7a4189c3d0f3a8b519d635b8">deleteParticle</a> (size_t cellIndex, size_t particleIndex)=0</td></tr>
<tr class="memdesc:a5fa2105a7a4189c3d0f3a8b519d635b8 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the particle at the given index positions as long as this does not compromise the validity of the container.  <br /></td></tr>
<tr class="separator:a5fa2105a7a4189c3d0f3a8b519d635b8 inherit pub_methods_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd75ec5fafa5160a64360c7306f8f05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1internal_1_1ParticleDeletedObserver.html#a2cd75ec5fafa5160a64360c7306f8f05">notifyParticleDeleted</a> ()=0</td></tr>
<tr class="memdesc:a2cd75ec5fafa5160a64360c7306f8f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called when a particle is deleted.  <br /></td></tr>
<tr class="separator:a2cd75ec5fafa5160a64360c7306f8f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adb5bf4b402f94dc2328e6a557d319cbd"><td class="memItemLeft" align="right" valign="top"><a id="adb5bf4b402f94dc2328e6a557d319cbd" name="adb5bf4b402f94dc2328e6a557d319cbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateClusterThreadPartition</b> ()</td></tr>
<tr class="memdesc:adb5bf4b402f94dc2328e6a557d319cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a cluster thread partition that aims to give each thread about the same amount of cluster pair interactions, if each thread handles the neighbors of all clusters it gets assigned. <br /></td></tr>
<tr class="separator:adb5bf4b402f94dc2328e6a557d319cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaac7d63b41bb23e9de3ae5c9bd78aed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#aeaac7d63b41bb23e9de3ae5c9bd78aed">fillClusterRanges</a> (size_t numClusterPairsPerThread, int numThreads)</td></tr>
<tr class="memdesc:aeaac7d63b41bb23e9de3ae5c9bd78aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills in the cluster ranges of the cluster thread partition.  <br /></td></tr>
<tr class="separator:aeaac7d63b41bb23e9de3ae5c9bd78aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3425cec3760e602ad2a880e6c8be8945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1VerletClusterLists.html#a3425cec3760e602ad2a880e6c8be8945">notifyParticleDeleted</a> () override</td></tr>
<tr class="memdesc:a3425cec3760e602ad2a880e6c8be8945"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a particle is deleted, we want _isValid to be set to invalid, as the tower structure is invalidated.  <br /></td></tr>
<tr class="separator:a3425cec3760e602ad2a880e6c8be8945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100b349232598152913d4c2ecfffc3c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a100b349232598152913d4c2ecfffc3c1">addParticleImpl</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;p)=0</td></tr>
<tr class="memdesc:a100b349232598152913d4c2ecfffc3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container.  <br /></td></tr>
<tr class="separator:a100b349232598152913d4c2ecfffc3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92952e5972fb6b30154a30012795f1a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1ParticleContainerInterface.html#a92952e5972fb6b30154a30012795f1a7">addHaloParticleImpl</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;haloParticle)=0</td></tr>
<tr class="memdesc:a92952e5972fb6b30154a30012795f1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container that lies in the halo region of the container.  <br /></td></tr>
<tr class="separator:a92952e5972fb6b30154a30012795f1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classautopas_1_1ParticleContainerInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classautopas_1_1ParticleContainerInterface')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface&lt; Particle &gt;</a></td></tr>
<tr class="memitem:a9eb1026f766e31bf170af8634f180d1d inherit pub_types_classautopas_1_1ParticleContainerInterface"><td class="memItemLeft" align="right" valign="top"><a id="a9eb1026f766e31bf170af8634f180d1d" name="a9eb1026f766e31bf170af8634f180d1d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParticleType</b> = <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a></td></tr>
<tr class="memdesc:a9eb1026f766e31bf170af8634f180d1d inherit pub_types_classautopas_1_1ParticleContainerInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Particle. <br /></td></tr>
<tr class="separator:a9eb1026f766e31bf170af8634f180d1d inherit pub_types_classautopas_1_1ParticleContainerInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>&gt;<br />
class autopas::VerletClusterLists&lt; Particle &gt;</div><p>Particles are divided into clusters. </p>
<p>The <a class="el" href="classautopas_1_1VerletClusterLists.html" title="Particles are divided into clusters.">VerletClusterLists</a> class uses neighborhood lists for each cluster to calculate pairwise interactions of particles. It is optimized for a constant, i.e. particle independent, cutoff radius of the interaction.</p>
<p>This Container does (currently?) not make use of the cellSizeFactor.</p>
<p>The _particlesToAdd buffer structure is (currently) still necessary, even if the <a class="el" href="classautopas_1_1LogicHandler.html" title="The LogicHandler takes care of the containers s.t.">LogicHandler</a> basically holds the same buffer structure. In principle, moving the particles directly into one of the towers would be possible, since particles are moved from <a class="el" href="classautopas_1_1LogicHandler.html" title="The LogicHandler takes care of the containers s.t.">LogicHandler</a> to VCL only in a rebuild iteration. However, storing the particles in a tower (e.g. tower0) is only possible very inefficiently, since several threads would write to this buffer at the same time. Even if we could add the particles to tower0 efficiently, there are still problems in <a class="el" href="classautopas_1_1VerletClusterLists.html#a5616f0f10c9d62147da14905be919f70" title="Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorne...">getRegionIterator()</a>, because this function is executed between the addition of particles and the actual rebuild. <a class="el" href="classautopas_1_1VerletClusterLists.html#a5616f0f10c9d62147da14905be919f70" title="Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorne...">getRegionIterator()</a> expects that all particles are already sorted correctly into the towers (if we do not use _particlesToAdd).</p>
<dl class="section note"><dt>Note</dt><dd>See VerletClusterListsRebuilder for the layout of the towers and clusters.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle</td><td></td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aada063ace3b9f8ac9d36d490983cbb83" name="aada063ace3b9f8ac9d36d490983cbb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada063ace3b9f8ac9d36d490983cbb83">&#9670;&#160;</a></span>VerletClusterLists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::VerletClusterLists </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>skinPerTimestep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rebuildFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>clusterSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classautopas_1_1LoadEstimatorOption.html">LoadEstimatorOption</a>&#160;</td>
          <td class="paramname"><em>loadEstimator</em> = <code><a class="el" href="classautopas_1_1LoadEstimatorOption.html#a0acdad94f9dac7d5704a9ca612a20c8ca9041bea590e9f47eafd12e04150895c8">LoadEstimatorOption::none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="classautopas_1_1VerletClusterLists.html" title="Particles are divided into clusters.">VerletClusterLists</a> class. </p>
<p>The neighbor lists are build using a estimated density. The box is divided into cuboids with roughly the same side length. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>The lower corner of the domain. </td></tr>
    <tr><td class="paramname">boxMax</td><td>The upper corner of the domain. </td></tr>
    <tr><td class="paramname">cutoff</td><td>The cutoff radius of the interaction. </td></tr>
    <tr><td class="paramname">skinPerTimestep</td><td>The skin radius per Timestep. </td></tr>
    <tr><td class="paramname">rebuildFrequency</td><td>The rebuild Frequency. </td></tr>
    <tr><td class="paramname">clusterSize</td><td>Number of particles per cluster. </td></tr>
    <tr><td class="paramname">loadEstimator</td><td>load estimation algorithm for balanced traversals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad345d0180a903436328fb97c5f64e52a" name="ad345d0180a903436328fb97c5f64e52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad345d0180a903436328fb97c5f64e52a">&#9670;&#160;</a></span>addHaloParticleImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::addHaloParticleImpl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;&#160;</td>
          <td class="paramname"><em>haloParticle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a particle to the container that lies in the halo region of the container. </p>
<p>This is an unsafe version of <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ae7c923772f539b5c3f6b8e4a7f6cc426" title="Adds a particle to the container.">addParticle()</a> and does not perform a boundary check. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haloParticle</td><td>Particle to be added. This particle is already checked to be outside of the bounding box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only call this function if the position of the particle is guaranteed to be outside of the bounding box! </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a92952e5972fb6b30154a30012795f1a7">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a1288e9fb3e19d4264bacc99b92136315" name="a1288e9fb3e19d4264bacc99b92136315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1288e9fb3e19d4264bacc99b92136315">&#9670;&#160;</a></span>addParticleImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::addParticleImpl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given particle to the container. </p>
<p><a class="el" href="classautopas_1_1VerletClusterLists.html#a656625734a4e3344e3c894f765468662" title="Initializes a new VerletClusterListsRebuilder and uses it to rebuild the towers and the clusters.">rebuildTowersAndClusters()</a> has to be called to have it actually sorted in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The particle to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a100b349232598152913d4c2ecfffc3c1">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="af96ebddcbdfe0ecd8fd8dd250b1d24ec" name="af96ebddcbdfe0ecd8fd8dd250b1d24ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96ebddcbdfe0ecd8fd8dd250b1d24ec">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, false &gt; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, false &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .   </p>
<dl class="section note"><dt>Note</dt><dd>The default argument for behavior is necessary to enable range based for loops. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first particle.   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa3d789b9ff0340a621d6d868937be162">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a4ec3eb7ab9f2b0afbcb1de85cef31b9a" name="a4ec3eb7ab9f2b0afbcb1de85cef31b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec3eb7ab9f2b0afbcb1de85cef31b9a">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, false &gt; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, false &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles using for(auto iter = container.begin(); iter.isValid(); ++iter) .   </p>
<dl class="section note"><dt>Note</dt><dd>The default argument for behavior is necessary to enable range based for loops. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first particle.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a01662c901808511a2785ecad6f536c32">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="adb72d9c6414223bc69de1f420e5b3c80" name="adb72d9c6414223bc69de1f420e5b3c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb72d9c6414223bc69de1f420e5b3c80">&#9670;&#160;</a></span>deleteAllParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::deleteAllParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all particles. </p>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a72611bd7d393897565b99b1e9d3f1d50">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a2eda0dded57207d2e89dd100914f39f4" name="a2eda0dded57207d2e89dd100914f39f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eda0dded57207d2e89dd100914f39f4">&#9670;&#160;</a></span>deleteHaloParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::deleteHaloParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all halo particles. </p>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4c21f6471b6b201fd02bed146182cbfa">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a9b0f97d5ddfdc092db09b0fd796d3aca" name="a9b0f97d5ddfdc092db09b0fd796d3aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0f97d5ddfdc092db09b0fd796d3aca">&#9670;&#160;</a></span>deleteParticle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the given particle as long as this does not compromise the validity of the container. </p>
<p>If this is not possible the particle is just marked as deleted. </p><dl class="section note"><dt>Note</dt><dd>This function might be implemented via swap-delete and is thus not completely thread safe. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td>Reference to the particle that is to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given pointer still points to a new particle. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a8640b3773e750e28703a686fba89aa11">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a2e6cf0b5f59d7cd93b6caeaacda943f8" name="a2e6cf0b5f59d7cd93b6caeaacda943f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6cf0b5f59d7cd93b6caeaacda943f8">&#9670;&#160;</a></span>deleteParticle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the particle at the given index positions as long as this does not compromise the validity of the container. </p>
<p>If this is not possible the particle is just marked as deleted. If the positions do not exist the behavior is undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td></td></tr>
    <tr><td class="paramname">particleIndex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given indices still point to a new particle. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a5fa2105a7a4189c3d0f3a8b519d635b8">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="af80817ed04af108f6c439ccef0f994d4" name="af80817ed04af108f6c439ccef0f994d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80817ed04af108f6c439ccef0f994d4">&#9670;&#160;</a></span>extractParticlesFromSoAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="classautopas_1_1Functor.html">Functor</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::extractParticlesFromSoAs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1Functor.html">Functor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts all SoAs of the container into the particles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classautopas_1_1Functor.html" title="Functor class.">Functor</a></td><td>The type of the functor to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>The functor to use for extracting the SoAs into the particles.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaac7d63b41bb23e9de3ae5c9bd78aed" name="aeaac7d63b41bb23e9de3ae5c9bd78aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaac7d63b41bb23e9de3ae5c9bd78aed">&#9670;&#160;</a></span>fillClusterRanges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::fillClusterRanges </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numClusterPairsPerThread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills in the cluster ranges of the cluster thread partition. </p>
<p>It aims to assign each thread appropriately the same number of cluster pairs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numClusterPairsPerThread</td><td>The approximate number of cluster pairs per thread. </td></tr>
    <tr><td class="paramname">numThreads</td><td>The number of threads to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97a351898213cf28aa148ff51a677dd4" name="a97a351898213cf28aa148ff51a677dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a351898213cf28aa148ff51a677dd4">&#9670;&#160;</a></span>forEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute code on all particles in this container as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle &amp;p) -&gt; void </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>code to be executed on all particles </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior   </dd></dl>

</div>
</div>
<a id="af4b9ba28380493f2027b05a0eecd9b10" name="af4b9ba28380493f2027b05a0eecd9b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b9ba28380493f2027b05a0eecd9b10">&#9670;&#160;</a></span>forEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute code on all particles in this container as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle &amp;p) -&gt; void </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>code to be executed on all particles </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version. </dd>
<dd>
This function additionally iterates over the _particlesToAdd vector if the tower-structure isn't valid. </dd></dl>

</div>
</div>
<a id="a5da6ad26f69e03d99265f4d97ce47074" name="a5da6ad26f69e03d99265f4d97ce47074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da6ad26f69e03d99265f4d97ce47074">&#9670;&#160;</a></span>forEachInRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::forEachInRegion </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute code on all particles in this container in a certain region as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle &amp;p) -&gt; void </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>code to be executed on all particles </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>lower corner of bounding box </td></tr>
    <tr><td class="paramname">higherCorner</td><td>higher corner of bounding box </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior   </dd></dl>

</div>
</div>
<a id="a336bc211cfecdf1cad4d471f7b1f1ad7" name="a336bc211cfecdf1cad4d471f7b1f1ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336bc211cfecdf1cad4d471f7b1f1ad7">&#9670;&#160;</a></span>forEachInRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::forEachInRegion </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute code on all particles in this container in a certain region as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle &amp;p) -&gt; void </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>code to be executed on all particles </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>lower corner of bounding box </td></tr>
    <tr><td class="paramname">higherCorner</td><td>higher corner of bounding box </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version. </dd>
<dd>
This function additionally iterates over the _particlesToAdd vector if the tower-structure isn't valid. </dd></dl>

</div>
</div>
<a id="acffae603e4343353b5ebe0d7d285e8c2" name="acffae603e4343353b5ebe0d7d285e8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffae603e4343353b5ebe0d7d285e8c2">&#9670;&#160;</a></span>getBoxMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getBoxMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the upper corner of the container without halo. </p>
<dl class="section return"><dt>Returns</dt><dd>Upper corner of the container. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#afe78d425e123737e61a77a218ece7031">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a277ba0868463e13f96dbf747b961d3a6" name="a277ba0868463e13f96dbf747b961d3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277ba0868463e13f96dbf747b961d3a6">&#9670;&#160;</a></span>getBoxMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getBoxMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the lower corner of the container without halo. </p>
<dl class="section return"><dt>Returns</dt><dd>Lower corner of the container. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#afc9b73ca3fbd7a346c7ceccc9f2a2b66">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a9cb76ce5c97f54425b6cdf975be1b2a8" name="a9cb76ce5c97f54425b6cdf975be1b2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb76ce5c97f54425b6cdf975be1b2a8">&#9670;&#160;</a></span>getClusterSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getClusterSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of particles in each cluster. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of particles in each cluster. </dd></dl>

</div>
</div>
<a id="a866794669cfb47663d369b27efb7e172" name="a866794669cfb47663d369b27efb7e172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866794669cfb47663d369b27efb7e172">&#9670;&#160;</a></span>getClusterThreadPartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getClusterThreadPartition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the cluster-thread-partition. </p>
<dl class="section return"><dt>Returns</dt><dd>The cluster-thread-partition. </dd></dl>

</div>
</div>
<a id="a8887080a9bc1687dad671e68e9ef721f" name="a8887080a9bc1687dad671e68e9ef721f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8887080a9bc1687dad671e68e9ef721f">&#9670;&#160;</a></span>getContainerType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContainerOption <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getContainerType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ContainerType. </p>
<dl class="section return"><dt>Returns</dt><dd>ContainerOption of the type of this container. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a78c5851f31e16a544c291b03a3081762">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="ab086ec424ccf1ce4fdd949ca66639d64" name="ab086ec424ccf1ce4fdd949ca66639d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab086ec424ccf1ce4fdd949ca66639d64">&#9670;&#160;</a></span>getCutoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getCutoff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cutoff of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>Cutoff radius. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a4cde802a2682931d2c8fbea7188742ff">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="aa7dc5f12150bf630249f26d3c62972f0" name="aa7dc5f12150bf630249f26d3c62972f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc5f12150bf630249f26d3c62972f0">&#9670;&#160;</a></span>getHaloBoxMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getHaloBoxMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the upper corner of the halo box. </p>
<dl class="section return"><dt>Returns</dt><dd>the upper corner of the halo box. </dd></dl>

</div>
</div>
<a id="a0d449d21cec027a29b921aee3e6dec3a" name="a0d449d21cec027a29b921aee3e6dec3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d449d21cec027a29b921aee3e6dec3a">&#9670;&#160;</a></span>getHaloBoxMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getHaloBoxMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the lower corner of the halo box. </p>
<dl class="section return"><dt>Returns</dt><dd>the lower corner of the halo box. </dd></dl>

</div>
</div>
<a id="a6b313d604c233b44eb7b23b15884bea9" name="a6b313d604c233b44eb7b23b15884bea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b313d604c233b44eb7b23b15884bea9">&#9670;&#160;</a></span>getInteractionLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getInteractionLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the interaction length (cutoff+skin) of the container. </p>
<dl class="section return"><dt>Returns</dt><dd>interaction length </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a2191ad8b6814478b7ccca24081468f99">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a3f9ec2f59023aec7c3332bfaf495f0a5" name="a3f9ec2f59023aec7c3332bfaf495f0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9ec2f59023aec7c3332bfaf495f0a5">&#9670;&#160;</a></span>getLoadEstimatorFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1BalancedTraversal.html#a1dd521e32c372a11307f670409f3efe8">BalancedTraversal::EstimatorFunction</a> <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getLoadEstimatorFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the load estimation function depending on _loadEstimator. </p>
<dl class="section return"><dt>Returns</dt><dd>load estimator function object. </dd></dl>

</div>
</div>
<a id="a2e2f6a366ddbd9d150df05fdfd953023" name="a2e2f6a366ddbd9d150df05fdfd953023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2f6a366ddbd9d150df05fdfd953023">&#9670;&#160;</a></span>getNeighborLists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classautopas_1_1internal_1_1VerletClusterListsRebuilder.html">internal::VerletClusterListsRebuilder</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::NeighborListsBuffer_T &amp; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getNeighborLists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the neighbor lists buffer object. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a74b2334361d346fc174bb322a1dd4b6a" name="a74b2334361d346fc174bb322a1dd4b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b2334361d346fc174bb322a1dd4b6a">&#9670;&#160;</a></span>getNumberOfParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getNumberOfParticles </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of particles with respect to the specified IteratorBehavior.   </p>
<dl class="section warning"><dt>Warning</dt><dd>: Since this function counts the number of the respective particles in the internal particle storage, this is in O(n) + lock is required. Only use it when it is absolutely necessary to have the exact number of different particle types like owned or halo. If it is enough to have the whole number of particles (owned + halo + dummy), the function <a class="el" href="classautopas_1_1VerletClusterLists.html#a1705589f4380d49066f64fc354602549" title="Get the number of all particles stored in this container (owned + halo + dummy).">size()</a> can be used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of particles with respect to the specified IteratorBehavior.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ad4643b9f9629050b3731ec5326247692">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a9a517f813e0ee789841aeea4c1c538db" name="a9a517f813e0ee789841aeea4c1c538db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a517f813e0ee789841aeea4c1c538db">&#9670;&#160;</a></span>getNumClusters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getNumClusters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of clusters in this container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of clusters in this container. </dd></dl>

</div>
</div>
<a id="a13fc96d891c9f9cd5f9340511e6465a3" name="a13fc96d891c9f9cd5f9340511e6465a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fc96d891c9f9cd5f9340511e6465a3">&#9670;&#160;</a></span>getNumTowersPerInteractionLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getNumTowersPerInteractionLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the towers per interaction length. </p>
<p>That is how many towers fit into one interaction length rounded up. </p><dl class="section return"><dt>Returns</dt><dd>the number of towers per interaction length. </dd></dl>

</div>
</div>
<a id="a05aa194c82bcadcd752701c0b583beb1" name="a05aa194c82bcadcd752701c0b583beb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05aa194c82bcadcd752701c0b583beb1">&#9670;&#160;</a></span>getParticle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the pointer to a particle, identified via a cell and particle index. </p>
<p>These indices are only meaningful in the context of the current container at its current state. The same indices might (and probably will) yield different particles for different container types or might not even exist. The only guarantee is that the indices {0,0} yield the first particle in the container that satisfies the iterator requirements.</p>
<dl class="section note"><dt>Note</dt><dd>This function should handle any offsets if used in a parallel iterator.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td>Index of the cell the particle is located in. </td></tr>
    <tr><td class="paramname">particleIndex</td><td>Particle index within the cell. </td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td>Which ownership states should be considered for the next particle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the particle and its indices. If a index pair is given that does not exist but is also not beyond the last cell, the next fitting particle shall be returned. Example: If [4,2] does not exist, [5,1] shall be returned (or whatever is the next particle that fulfills the iterator requirements). If there is no next fitting particle {nullptr, 0, 0} is returned. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a787869df00344fe67ce760549b3c3647">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a92d7354afa9ae2cb444eadc920be1cb0" name="a92d7354afa9ae2cb444eadc920be1cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d7354afa9ae2cb444eadc920be1cb0">&#9670;&#160;</a></span>getParticle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getParticle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the pointer to a particle, identified via a cell and particle index.   </p>
<p>These indices are only meaningful in the context of the current container at its current state. The same indices might (and probably will) yield different particles for different container types or might not even exist. The only guarantee is that the indices {0,0} yield the first particle in the container that satisfies the iterator requirements.</p>
<dl class="section note"><dt>Note</dt><dd>This function should handle any offsets if used in a parallel iterator.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td>Index of the cell the particle is located in. </td></tr>
    <tr><td class="paramname">particleIndex</td><td>Particle index within the cell. </td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td>Which ownership states should be considered for the next particle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the particle and its indices. If a index pair is given that does not exist but is also not beyond the last cell, the next fitting particle shall be returned. Example: If [4,2] does not exist, [5,1] shall be returned (or whatever is the next particle that fulfills the iterator requirements). If there is no next fitting particle {nullptr, 0, 0} is returned.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>start of region in which the next particle should be. The coordinates are expected to be within the domain. </td></tr>
    <tr><td class="paramname">boxMax</td><td>end of region in which the next particle should be. The coordinates are expected to be within the domain. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa1e00528190c8092a77b18c7acc9d4e6">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="af802a5c9926c822ce6393d59473f754b" name="af802a5c9926c822ce6393d59473f754b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af802a5c9926c822ce6393d59473f754b">&#9670;&#160;</a></span>getParticleCellTypeEnum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceautopas.html#a0503ca3cdb1ed5bdd6844883536ca3f8">CellType</a> <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getParticleCellTypeEnum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classautopas_1_1ParticleCell.html" title="Class for Cells of Particles.">ParticleCell</a> type as an Enum. </p>
<dl class="section return"><dt>Returns</dt><dd>The Cell type as an Enum </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#aa0d021848386b655665099f6536d38f3">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a29141171aa9e78ae7d1042b98a4d884a" name="a29141171aa9e78ae7d1042b98a4d884a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29141171aa9e78ae7d1042b98a4d884a">&#9670;&#160;</a></span>getParticleImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;bool regionIter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> *, size_t, size_t &gt; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getParticleImpl </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cellIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>particleIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>iteratorBehavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container specific implementation for getParticle. </p>
<p>See <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a787869df00344fe67ce760549b3c3647" title="Fetch the pointer to a particle, identified via a cell and particle index.">ParticleContainerInterface::getParticle()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">regionIter</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellIndex</td><td></td></tr>
    <tr><td class="paramname">particleIndex</td><td></td></tr>
    <tr><td class="paramname">iteratorBehavior</td><td></td></tr>
    <tr><td class="paramname">boxMin</td><td></td></tr>
    <tr><td class="paramname">boxMax</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple&lt;ParticlePointer, CellIndex, ParticleIndex&gt; </dd></dl>

</div>
</div>
<a id="a05b46f8d5d321d85ac45aa6a1f050ff8" name="a05b46f8d5d321d85ac45aa6a1f050ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b46f8d5d321d85ac45aa6a1f050ff8">&#9670;&#160;</a></span>getRebuildFrequency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getRebuildFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rebuild Frequency value for the container. </p>
<dl class="section return"><dt>Returns</dt><dd>rebuildFrequency </dd></dl>

</div>
</div>
<a id="a763a3b7b6aaaef39e78c8cd0f838d290" name="a763a3b7b6aaaef39e78c8cd0f838d290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763a3b7b6aaaef39e78c8cd0f838d290">&#9670;&#160;</a></span>getRegionIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, true &gt; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getRegionIterator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, true &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of the region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of the region </td></tr>
    <tr><td class="paramname">behavior</td><td>The behavior of the iterator (shall it iterate over halo particles as well?). </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to iterate over all particles in a specific region.   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ad205a0ca53c65e2a5fdfca929d424bf3">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a5616f0f10c9d62147da14905be919f70" name="a5616f0f10c9d62147da14905be919f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5616f0f10c9d62147da14905be919f70">&#9670;&#160;</a></span>getRegionIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, true &gt; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getRegionIterator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classautopas_1_1ContainerIterator.html">ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, true &gt;::ParticleVecType *&#160;</td>
          <td class="paramname"><em>additionalVectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles in a specified region for(auto iter = container.getRegionIterator(lowCorner, highCorner);iter.isValid();++iter) .   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of the region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of the region </td></tr>
    <tr><td class="paramname">behavior</td><td>The behavior of the iterator (shall it iterate over halo particles as well?). </td></tr>
    <tr><td class="paramname">additionalVectors</td><td>Vectors that should be included besides the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to iterate over all particles in a specific region.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ae9089e195a798b946b7a5424f80cd296">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a99739ec1220754cfd1a83c805b71abe0" name="a99739ec1220754cfd1a83c805b71abe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99739ec1220754cfd1a83c805b71abe0">&#9670;&#160;</a></span>getTowerBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1internal_1_1ClusterTowerBlock2D.html">internal::ClusterTowerBlock2D</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &amp; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getTowerBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the cell block. </p>
<dl class="section note"><dt>Note</dt><dd>This is only used for testing.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0a7070472c03bfb3f68a79a42121f7dc" name="a0a7070472c03bfb3f68a79a42121f7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7070472c03bfb3f68a79a42121f7dc">&#9670;&#160;</a></span>getTowerByIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1internal_1_1ClusterTower.html">internal::ClusterTower</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &amp; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getTowerByIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the tower for the given tower grid coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-th tower in x direction. </td></tr>
    <tr><td class="paramname">y</td><td>The y-th tower in y direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the tower for the given tower grid coordinates. </dd></dl>

</div>
</div>
<a id="a8a5344aa9cf0d83556aa828de8464ad8" name="a8a5344aa9cf0d83556aa828de8464ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5344aa9cf0d83556aa828de8464ad8">&#9670;&#160;</a></span>getTowerSideLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getTowerSideLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the grid side length of the grids in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>the grid side length of the grids in the container. </dd></dl>

</div>
</div>
<a id="a1fb4a13221cfc65a9b9fc45c867fd5a4" name="a1fb4a13221cfc65a9b9fc45c867fd5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb4a13221cfc65a9b9fc45c867fd5a4">&#9670;&#160;</a></span>getTowersPerDimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getTowersPerDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of grids per dimension on the container. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of grids per dimension on the container. </dd></dl>

</div>
</div>
<a id="aa01918ad43ab0768b187d11ebefe82de" name="aa01918ad43ab0768b187d11ebefe82de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01918ad43ab0768b187d11ebefe82de">&#9670;&#160;</a></span>getTraversalSelectorInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1TraversalSelectorInfo.html">TraversalSelectorInfo</a> <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getTraversalSelectorInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a traversal selector info for this container. </p>
<dl class="section return"><dt>Returns</dt><dd>Traversal selector info for this container. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a0792166b79e13d3f310ba67bc7531432">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a1524bdd7b6db15ecb490bf2515d31863" name="a1524bdd7b6db15ecb490bf2515d31863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1524bdd7b6db15ecb490bf2515d31863">&#9670;&#160;</a></span>getVerletSkin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getVerletSkin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the verletSkin of the container verletSkinPerTimestep*rebuildFrequency. </p>
<dl class="section return"><dt>Returns</dt><dd>verletSkin </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#aff79b9a83a997b3c2fe9371557459a44">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a6200cb4240d6e6d59d02b94fd197dfdf" name="a6200cb4240d6e6d59d02b94fd197dfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6200cb4240d6e6d59d02b94fd197dfdf">&#9670;&#160;</a></span>iteratePairwise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::iteratePairwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterates over all particle pairs in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traversal</td><td>The traversal to use for the iteration. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ac9a28b26596e40f2c517edb57ba5383d">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a3c7e55d086b6fc7e109007cf5e8def69" name="a3c7e55d086b6fc7e109007cf5e8def69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7e55d086b6fc7e109007cf5e8def69">&#9670;&#160;</a></span>loadParticlesIntoSoAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="classautopas_1_1Functor.html">Functor</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::loadParticlesIntoSoAs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1Functor.html">Functor</a> *&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads all particles of the container in their correct <a class="el" href="classautopas_1_1SoA.html" title="Structur of the array class.">SoA</a> and generates the SoAViews for the clusters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classautopas_1_1Functor.html" title="Functor class.">Functor</a></td><td>The type of the functor to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>The functor to use for loading the particles into the <a class="el" href="classautopas_1_1SoA.html" title="Structur of the array class.">SoA</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3425cec3760e602ad2a880e6c8be8945" name="a3425cec3760e602ad2a880e6c8be8945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3425cec3760e602ad2a880e6c8be8945">&#9670;&#160;</a></span>notifyParticleDeleted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::notifyParticleDeleted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a particle is deleted, we want _isValid to be set to invalid, as the tower structure is invalidated. </p>
<p>This function is not called, if a particle from the _particlesToAdd vector is deleted! </p>

<p>Implements <a class="el" href="classautopas_1_1internal_1_1ParticleDeletedObserver.html#a2cd75ec5fafa5160a64360c7306f8f05">autopas::internal::ParticleDeletedObserver</a>.</p>

</div>
</div>
<a id="a99122f3d6111eb888b00874173b622e9" name="a99122f3d6111eb888b00874173b622e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99122f3d6111eb888b00874173b622e9">&#9670;&#160;</a></span>rebuildNeighborLists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::rebuildNeighborLists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> *&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rebuilds the neighbor lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traversal</td><td>The used traversal. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#afdfccbe1d9d20fb331152c427b6dd9a3">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a656625734a4e3344e3c894f765468662" name="a656625734a4e3344e3c894f765468662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656625734a4e3344e3c894f765468662">&#9670;&#160;</a></span>rebuildTowersAndClusters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::rebuildTowersAndClusters </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newton3</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new VerletClusterListsRebuilder and uses it to rebuild the towers and the clusters. </p>
<p>This function sets the container structure to valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newton3</td><td>Indicate whether the VerletClusterRebuilder should consider newton3 or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9560d06bd81216c7f060455a40621c27" name="a9560d06bd81216c7f060455a40621c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9560d06bd81216c7f060455a40621c27">&#9670;&#160;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce properties of particles as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle p, A initialValue) -&gt; void </td></tr>
    <tr><td class="paramname">A</td><td>type of particle attribute to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>code to reduce properties of particles </td></tr>
    <tr><td class="paramname">result</td><td>reference to result of type A </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior default: </dd>
<dd>
IteratorBehavior::ownedOrHalo   </dd></dl>

</div>
</div>
<a id="a62afa4c87b516012a31381ac4cc4561a" name="a62afa4c87b516012a31381ac4cc4561a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62afa4c87b516012a31381ac4cc4561a">&#9670;&#160;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce properties of particles as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle p, A initialValue) -&gt; void </td></tr>
    <tr><td class="paramname">A</td><td>type of particle attribute to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>code to reduce properties of particles </td></tr>
    <tr><td class="paramname">result</td><td>reference to result of type A </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior default: </dd>
<dd>
IteratorBehavior::ownedOrHalo   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version. </dd>
<dd>
This function additionally iterates over the _particlesToAdd vector if the tower-structure isn't valid. </dd></dl>

</div>
</div>
<a id="ae52426d4f6bfcf859d0e000894f3dc93" name="ae52426d4f6bfcf859d0e000894f3dc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52426d4f6bfcf859d0e000894f3dc93">&#9670;&#160;</a></span>reduceInRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::reduceInRegion </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute code on all particles in this container in a certain region as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle &amp;p, A &amp;result) -&gt; void </td></tr>
    <tr><td class="paramname">A</td><td>type of reduction Value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>code to be executed on all particles </td></tr>
    <tr><td class="paramname">result</td><td>reference to starting and final value for reduction </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>lower corner of bounding box </td></tr>
    <tr><td class="paramname">higherCorner</td><td>higher corner of bounding box </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior   </dd></dl>

</div>
</div>
<a id="a2abf4075f7386c326d46ef05474fe60b" name="a2abf4075f7386c326d46ef05474fe60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abf4075f7386c326d46ef05474fe60b">&#9670;&#160;</a></span>reduceInRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::reduceInRegion </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>autopas::IteratorBehavior::ownedOrHalo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute code on all particles in this container in a certain region as defined by a lambda function.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>(Particle &amp;p, A &amp;result) -&gt; void </td></tr>
    <tr><td class="paramname">A</td><td>type of reduction Value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>code to be executed on all particles </td></tr>
    <tr><td class="paramname">result</td><td>reference to starting and final value for reduction </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>lower corner of bounding box </td></tr>
    <tr><td class="paramname">higherCorner</td><td>higher corner of bounding box </td></tr>
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IteratorBehavior   </dd></dl>
<dl class="section note"><dt>Note</dt><dd>const version. </dd>
<dd>
This function additionally iterates over the _particlesToAdd vector if the tower-structure isn't valid. </dd></dl>

</div>
</div>
<a id="a68bae77f2b03a8cbe140be410d4a159e" name="a68bae77f2b03a8cbe140be410d4a159e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bae77f2b03a8cbe140be410d4a159e">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numParticlesHaloEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve memory for a given number of particles in the container and logic layers.   </p>
<p>This function assumes a uniform distribution of particles throughout the domain. For example, this means that in a <a class="el" href="classautopas_1_1LinkedCells.html" title="LinkedCells class.">LinkedCells</a> Container in each cell vector.reserve(numParticles/numCells) is called. </p><dl class="section note"><dt>Note</dt><dd>This functions will create an estimate for the number of halo particles. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numParticles</td><td>No buffer factor is applied. It is probably wise to slighly over-reserve to account for imbalance or particle movement.   </td></tr>
    <tr><td class="paramname">numParticlesHaloEstimate</td><td>Estimate for the number of halo particles. Reserves space in the container data structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#afee129c51f1fe9a688a0a4f923c0020a">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="a914e963b6177a3f557c69ee3d9f241e1" name="a914e963b6177a3f557c69ee3d9f241e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914e963b6177a3f557c69ee3d9f241e1">&#9670;&#160;</a></span>setCutoff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::setCutoff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cutoff of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cutoff</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a65a8be37e00420b0006bf145fe731cb9">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="aa2d0dc79ba35a126f559e6e1271c388f" name="aa2d0dc79ba35a126f559e6e1271c388f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d0dc79ba35a126f559e6e1271c388f">&#9670;&#160;</a></span>setRebuildFrequency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::setRebuildFrequency </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rebuildFrequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the rebuild Frequency value for the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rebuildFrequency</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3152d51db17d72575026ee6774165388" name="a3152d51db17d72575026ee6774165388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3152d51db17d72575026ee6774165388">&#9670;&#160;</a></span>setSkinPerTimestep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::setSkinPerTimestep </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>skinPerTimestep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the verlet skin length per timestep for the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skinPerTimestep</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1705589f4380d49066f64fc354602549" name="a1705589f4380d49066f64fc354602549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1705589f4380d49066f64fc354602549">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of all particles stored in this container (owned + halo + dummy). </p>
<dl class="section return"><dt>Returns</dt><dd>number of particles stored in this container (owned + halo + dummy). </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#ab5e6a361098c54b400b75365d2ce32a9">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="acdeffcf911e21cebe8f1e7e5923dfb89" name="acdeffcf911e21cebe8f1e7e5923dfb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdeffcf911e21cebe8f1e7e5923dfb89">&#9670;&#160;</a></span>traverseClusters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;bool inParallel, class LoopBody &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::traverseClusters </td>
          <td>(</td>
          <td class="paramtype">LoopBody &amp;&amp;&#160;</td>
          <td class="paramname"><em>loopBody</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to iterate over all clusters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LoopBody</td><td>The type of the lambda to execute for all clusters. </td></tr>
    <tr><td class="paramname">inParallel</td><td>If the iteration should be executed in parallel or sequential. See <a class="el" href="classautopas_1_1VerletClusterLists.html#a1b9d645ae260dfc7714d67fa360b2247" title="Helper method to iterate over all clusters in parallel.">traverseClustersParallel()</a> for thread safety. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loopBody</td><td>The lambda to execute for all clusters. Parameters given is <a class="el" href="classautopas_1_1internal_1_1Cluster.html" title="This class represents a cluster in the VerletClusterLists container.">internal::Cluster</a>&amp; cluster. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b9d645ae260dfc7714d67fa360b2247" name="a1b9d645ae260dfc7714d67fa360b2247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9d645ae260dfc7714d67fa360b2247">&#9670;&#160;</a></span>traverseClustersParallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;class LoopBody &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::traverseClustersParallel </td>
          <td>(</td>
          <td class="paramtype">LoopBody &amp;&amp;&#160;</td>
          <td class="paramname"><em>loopBody</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to iterate over all clusters in parallel. </p>
<p>It is always safe to modify the particles in the cluster that is passed to the given loop body. However, when modifying particles from other clusters, the caller has to make sure that no data races occur. Particles must not be added or removed during the traversal. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LoopBody</td><td>The type of the lambda to execute for all clusters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loopBody</td><td>The lambda to execute for all clusters. Parameters given is <a class="el" href="classautopas_1_1internal_1_1Cluster.html" title="This class represents a cluster in the VerletClusterLists container.">internal::Cluster</a>&amp; cluster. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09a82439e3e1dea8533fa5dcf4047c4f" name="a09a82439e3e1dea8533fa5dcf4047c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a82439e3e1dea8533fa5dcf4047c4f">&#9670;&#160;</a></span>traverseClustersSequential()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;class LoopBody &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::traverseClustersSequential </td>
          <td>(</td>
          <td class="paramtype">LoopBody &amp;&amp;&#160;</td>
          <td class="paramname"><em>loopBody</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to sequentially iterate over all owned clusters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LoopBody</td><td>The type of the lambda to execute for all clusters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loopBody</td><td>The lambda to execute for all clusters. Parameters given is <a class="el" href="classautopas_1_1internal_1_1Cluster.html" title="This class represents a cluster in the VerletClusterLists container.">internal::Cluster</a>&amp; cluster. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab53dbd08e3ac36cfc78d39e6e1b65b5d" name="ab53dbd08e3ac36cfc78d39e6e1b65b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53dbd08e3ac36cfc78d39e6e1b65b5d">&#9670;&#160;</a></span>updateContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::updateContainer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepNeighborListsValid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the container. </p>
<p>This deletes halo particles, resorts particles into appropriate cells and might remove particles from the container, if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepNeighborListsValid</td><td>Defines whether the neighbor lists have to be kept valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of invalid particles that do not belong into the container. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#af5895f71653f46875dbb4c1a987b995d">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<a id="abedbee3ccdba8ed38a9616ae42dd0fb5" name="abedbee3ccdba8ed38a9616ae42dd0fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedbee3ccdba8ed38a9616ae42dd0fb5">&#9670;&#160;</a></span>updateHaloParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1VerletClusterLists.html">autopas::VerletClusterLists</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::updateHaloParticle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;&#160;</td>
          <td class="paramname"><em>haloParticle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a halo particle of the container with the given haloParticle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haloParticle</td><td>Particle to be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the particle was updated, false if no particle could be found. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1ParticleContainerInterface.html#a08dbde7d49563a7b88e2b2c5f0de9b07">autopas::ParticleContainerInterface&lt; Particle &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>autopas/containers/verletClusterLists/traversals/<a class="el" href="VCLTraversalInterface_8h_source.html">VCLTraversalInterface.h</a></li>
<li>autopas/containers/verletClusterLists/<a class="el" href="VerletClusterLists_8h_source.html">VerletClusterLists.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html">MPIParallelizedStrategy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classautopas_1_1MPIParallelizedStrategy-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::MPIParallelizedStrategy Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This strategy spreads the configuration queue in a round robin fashion over all ranks (with similar domain).  
 <a href="classautopas_1_1MPIParallelizedStrategy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MPIParallelizedStrategy_8h_source.html">MPIParallelizedStrategy.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::MPIParallelizedStrategy:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1MPIParallelizedStrategy__inherit__graph.png" border="0" usemap="#aautopas_1_1MPIParallelizedStrategy_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1MPIParallelizedStrategy_inherit__map" id="aautopas_1_1MPIParallelizedStrategy_inherit__map">
<area shape="rect" title="This strategy spreads the configuration queue in a round robin fashion over all ranks (with similar d..." alt="" coords="33,79,215,119"/>
<area shape="rect" href="classautopas_1_1TuningStrategyInterface.html" title="Interface for tuning strategies for the auto tuner." alt="" coords="5,5,243,31"/>
<area shape="poly" title=" " alt="" coords="127,44,127,79,121,79,121,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for autopas::MPIParallelizedStrategy:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1MPIParallelizedStrategy__coll__graph.png" border="0" usemap="#aautopas_1_1MPIParallelizedStrategy_coll__map" alt="Collaboration graph"/></div>
<map name="aautopas_1_1MPIParallelizedStrategy_coll__map" id="aautopas_1_1MPIParallelizedStrategy_coll__map">
<area shape="rect" title="This strategy spreads the configuration queue in a round robin fashion over all ranks (with similar d..." alt="" coords="33,79,215,119"/>
<area shape="rect" href="classautopas_1_1TuningStrategyInterface.html" title="Interface for tuning strategies for the auto tuner." alt="" coords="5,5,243,31"/>
<area shape="poly" title=" " alt="" coords="127,44,127,79,121,79,121,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b8693082b4cdb66eecda1014379a760"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#a4b8693082b4cdb66eecda1014379a760">MPIParallelizedStrategy</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;fallbackConfiguration, const <a class="el" href="namespaceautopas.html#ab7d7e9a630b960c5bb1d4622504c7b1a">AutoPas_MPI_Comm</a> &amp;comm, double mpiTuningMaxDifferenceForBucket, double mpiTuningWeightForMaxDensity)</td></tr>
<tr class="memdesc:a4b8693082b4cdb66eecda1014379a760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a4b8693082b4cdb66eecda1014379a760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac112ad9c352f28cb15a3bbbe19f17a97"><td class="memItemLeft" align="right" valign="top">TuningStrategyOption&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#ac112ad9c352f28cb15a3bbbe19f17a97">getOptionType</a> () override</td></tr>
<tr class="memdesc:ac112ad9c352f28cb15a3bbbe19f17a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this object's associated TuningStrategyOption type.  <br /></td></tr>
<tr class="separator:ac112ad9c352f28cb15a3bbbe19f17a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e9c5cb464646ab4129d48ad26c46c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#af6e9c5cb464646ab4129d48ad26c46c9">optimizeSuggestions</a> (std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp;evidenceCollection) override</td></tr>
<tr class="memdesc:af6e9c5cb464646ab4129d48ad26c46c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes the queue of configurations to process.  <br /></td></tr>
<tr class="separator:af6e9c5cb464646ab4129d48ad26c46c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fb42dab3f4d7a0193c98a7053bae4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#a11fb42dab3f4d7a0193c98a7053bae4e">receiveSmoothedHomogeneityAndMaxDensity</a> (double homogeneity, double maxDensity) override</td></tr>
<tr class="memdesc:a11fb42dab3f4d7a0193c98a7053bae4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to pass smoothed homogeneity and the maximal density to the tuning strategy.  <br /></td></tr>
<tr class="separator:a11fb42dab3f4d7a0193c98a7053bae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaed418a45c28014c345e5ee1b92ec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#afeaed418a45c28014c345e5ee1b92ec3">reset</a> (size_t iteration, size_t tuningPhase, std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">autopas::EvidenceCollection</a> &amp;evidenceCollection) override</td></tr>
<tr class="memdesc:afeaed418a45c28014c345e5ee1b92ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all internal parameters to the beginning of a new tuning phase.  <br /></td></tr>
<tr class="separator:afeaed418a45c28014c345e5ee1b92ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83434c982e6f2d4a501e9ee01258b8d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#a83434c982e6f2d4a501e9ee01258b8d9">needsSmoothedHomogeneityAndMaxDensity</a> () const override</td></tr>
<tr class="memdesc:a83434c982e6f2d4a501e9ee01258b8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether the strategy needs smoothed values of homogeneity and max density.  <br /></td></tr>
<tr class="separator:a83434c982e6f2d4a501e9ee01258b8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cadb79788c1b72ff159ecd8dac9b76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#ab5cadb79788c1b72ff159ecd8dac9b76">rejectConfiguration</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;configuration, bool indefinitely) override</td></tr>
<tr class="memdesc:ab5cadb79788c1b72ff159ecd8dac9b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the strategy about a configuration that is (currently) invalid and thus can potentially be dropped from some internal storage.  <br /></td></tr>
<tr class="separator:ab5cadb79788c1b72ff159ecd8dac9b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8316a81496117fa3d7f41fa434f0d8d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceautopas.html#ab7d7e9a630b960c5bb1d4622504c7b1a">AutoPas_MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#a8316a81496117fa3d7f41fa434f0d8d3">getBucket</a> () const</td></tr>
<tr class="memdesc:a8316a81496117fa3d7f41fa434f0d8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MPI communicator for this rank's bucket.  <br /></td></tr>
<tr class="separator:a8316a81496117fa3d7f41fa434f0d8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1TuningStrategyInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1TuningStrategyInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1TuningStrategyInterface.html">autopas::TuningStrategyInterface</a></td></tr>
<tr class="memitem:adf71fe578648ddf3bdec60dd9a016def inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual TuningStrategyOption&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#adf71fe578648ddf3bdec60dd9a016def">getOptionType</a> ()=0</td></tr>
<tr class="memdesc:adf71fe578648ddf3bdec60dd9a016def inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this object's associated TuningStrategyOption type.  <br /></td></tr>
<tr class="separator:adf71fe578648ddf3bdec60dd9a016def inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2e11a52988f7c4d67eccf353335b61 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a0e2e11a52988f7c4d67eccf353335b61">addEvidence</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;configuration, const <a class="el" href="classautopas_1_1Evidence.html">Evidence</a> &amp;evidence)</td></tr>
<tr class="memdesc:a0e2e11a52988f7c4d67eccf353335b61 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the strategy about empirically collected information for the given configuration.  <br /></td></tr>
<tr class="separator:a0e2e11a52988f7c4d67eccf353335b61 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e766b635dea87edc8e81fa85af0f41 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a45e766b635dea87edc8e81fa85af0f41">optimizeSuggestions</a> (std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp;evidenceCollection)=0</td></tr>
<tr class="memdesc:a45e766b635dea87edc8e81fa85af0f41 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes the queue of configurations to process.  <br /></td></tr>
<tr class="separator:a45e766b635dea87edc8e81fa85af0f41 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9b4f910967a9a9251939ceaec3e755 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7e9b4f910967a9a9251939ceaec3e755">reset</a> (size_t iteration, size_t tuningPhase, std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;configQueue, const <a class="el" href="classautopas_1_1EvidenceCollection.html">autopas::EvidenceCollection</a> &amp;evidenceCollection)=0</td></tr>
<tr class="memdesc:a7e9b4f910967a9a9251939ceaec3e755 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all internal parameters to the beginning of a new tuning phase.  <br /></td></tr>
<tr class="separator:a7e9b4f910967a9a9251939ceaec3e755 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0bc535436e8aa6a8b25b6f1b50b5e2 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7c0bc535436e8aa6a8b25b6f1b50b5e2">needsLiveInfo</a> () const</td></tr>
<tr class="memdesc:a7c0bc535436e8aa6a8b25b6f1b50b5e2 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tuning strategy wants to get a <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object passed before a new tuning phase.  <br /></td></tr>
<tr class="separator:a7c0bc535436e8aa6a8b25b6f1b50b5e2 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb1ba7e258aa647bc0a442a1982f8f8 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a9cb1ba7e258aa647bc0a442a1982f8f8">receiveLiveInfo</a> (const <a class="el" href="classautopas_1_1LiveInfo.html">LiveInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a9cb1ba7e258aa647bc0a442a1982f8f8 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method that subclasses can override to receive the <a class="el" href="classautopas_1_1LiveInfo.html" title="This class is able to gather and store important information for a tuning phase from a container and ...">LiveInfo</a> object before a tuning phase if they return true in <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7c0bc535436e8aa6a8b25b6f1b50b5e2" title="Returns whether this tuning strategy wants to get a LiveInfo object passed before a new tuning phase.">needsLiveInfo()</a>.  <br /></td></tr>
<tr class="separator:a9cb1ba7e258aa647bc0a442a1982f8f8 inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc2e5b8444200e7429fd7dd457fc13f inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a3cc2e5b8444200e7429fd7dd457fc13f">rejectConfiguration</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;configuration, bool indefinitely)</td></tr>
<tr class="memdesc:a3cc2e5b8444200e7429fd7dd457fc13f inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the strategy about a configuration that is (currently) invalid and thus can potentially be dropped from some internal storage.  <br /></td></tr>
<tr class="separator:a3cc2e5b8444200e7429fd7dd457fc13f inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f14f8d8fd82e945783a3715452d99f inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a55f14f8d8fd82e945783a3715452d99f">needsSmoothedHomogeneityAndMaxDensity</a> () const</td></tr>
<tr class="memdesc:a55f14f8d8fd82e945783a3715452d99f inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether the strategy needs smoothed values of homogeneity and max density.  <br /></td></tr>
<tr class="separator:a55f14f8d8fd82e945783a3715452d99f inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f063297e8df6c7903651232b372573c inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1TuningStrategyInterface.html#a3f063297e8df6c7903651232b372573c">receiveSmoothedHomogeneityAndMaxDensity</a> (double homogeneity, double maxDensity)</td></tr>
<tr class="memdesc:a3f063297e8df6c7903651232b372573c inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to pass smoothed homogeneity and the maximal density to the tuning strategy.  <br /></td></tr>
<tr class="separator:a3f063297e8df6c7903651232b372573c inherit pub_methods_classautopas_1_1TuningStrategyInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac7ed4864ccbbd03c7535fc1b726491d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classautopas_1_1Configuration.html">Configuration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#ac7ed4864ccbbd03c7535fc1b726491d8">createFallBackConfiguration</a> (const std::set&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;searchSpace)</td></tr>
<tr class="memdesc:ac7ed4864ccbbd03c7535fc1b726491d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a resilient configuration that should always be applicable.  <br /></td></tr>
<tr class="separator:ac7ed4864ccbbd03c7535fc1b726491d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This strategy spreads the configuration queue in a round robin fashion over all ranks (with similar domain). </p>
<p>The actual splitting of the search space and details of the communication logic is not currently handled by this class, but by AutoPasConfigurationCommunicator. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b8693082b4cdb66eecda1014379a760" name="a4b8693082b4cdb66eecda1014379a760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8693082b4cdb66eecda1014379a760">&#9670;&#160;</a></span>MPIParallelizedStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">autopas::MPIParallelizedStrategy::MPIParallelizedStrategy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>fallbackConfiguration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceautopas.html#ab7d7e9a630b960c5bb1d4622504c7b1a">AutoPas_MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mpiTuningMaxDifferenceForBucket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mpiTuningWeightForMaxDensity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fallbackConfiguration</td><td>Generally applicable configuration that can be used if no local configuration are applicable. It is suggested to use <a class="el" href="classautopas_1_1MPIParallelizedStrategy.html#ac7ed4864ccbbd03c7535fc1b726491d8" title="Create a resilient configuration that should always be applicable.">MPIParallelizedStrategy::createFallBackConfiguration()</a> for this. </td></tr>
    <tr><td class="paramname">comm</td><td>The communicator holding all ranks which participate in this tuning strategy. </td></tr>
    <tr><td class="paramname">mpiTuningMaxDifferenceForBucket</td><td></td></tr>
    <tr><td class="paramname">mpiTuningWeightForMaxDensity</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac7ed4864ccbbd03c7535fc1b726491d8" name="ac7ed4864ccbbd03c7535fc1b726491d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ed4864ccbbd03c7535fc1b726491d8">&#9670;&#160;</a></span>createFallBackConfiguration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1Configuration.html">Configuration</a> autopas::MPIParallelizedStrategy::createFallBackConfiguration </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>searchSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a resilient configuration that should always be applicable. </p>
<p>The idea is to pick some configuration that is basically always applicable (lc_c08) and guess from the search space which options Newton3 and Data Layout options are allowed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchSpace</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fall back configuration. </dd></dl>

</div>
</div>
<a id="a8316a81496117fa3d7f41fa434f0d8d3" name="a8316a81496117fa3d7f41fa434f0d8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8316a81496117fa3d7f41fa434f0d8d3">&#9670;&#160;</a></span>getBucket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceautopas.html#ab7d7e9a630b960c5bb1d4622504c7b1a">AutoPas_MPI_Comm</a> &amp; autopas::MPIParallelizedStrategy::getBucket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MPI communicator for this rank's bucket. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac112ad9c352f28cb15a3bbbe19f17a97" name="ac112ad9c352f28cb15a3bbbe19f17a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac112ad9c352f28cb15a3bbbe19f17a97">&#9670;&#160;</a></span>getOptionType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TuningStrategyOption autopas::MPIParallelizedStrategy::getOptionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get this object's associated TuningStrategyOption type. </p>
<dl class="section return"><dt>Returns</dt><dd>TuningStrategyOption </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1TuningStrategyInterface.html#adf71fe578648ddf3bdec60dd9a016def">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="a83434c982e6f2d4a501e9ee01258b8d9" name="a83434c982e6f2d4a501e9ee01258b8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83434c982e6f2d4a501e9ee01258b8d9">&#9670;&#160;</a></span>needsSmoothedHomogeneityAndMaxDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool autopas::MPIParallelizedStrategy::needsSmoothedHomogeneityAndMaxDensity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate whether the strategy needs smoothed values of homogeneity and max density. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a55f14f8d8fd82e945783a3715452d99f">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="af6e9c5cb464646ab4129d48ad26c46c9" name="af6e9c5cb464646ab4129d48ad26c46c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e9c5cb464646ab4129d48ad26c46c9">&#9670;&#160;</a></span>optimizeSuggestions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::MPIParallelizedStrategy::optimizeSuggestions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1EvidenceCollection.html">EvidenceCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>evidenceCollection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimizes the queue of configurations to process. </p>
<p>This function is called once before each iteration in a tuning phase so all tuning strategies can give their input on which configuration to try next. This is done by reordering configQueue so that the next configuration to try is at the end (FIFO).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configQueue</td><td>Queue of configurations to be tested. The tuning strategy should edit this queue. </td></tr>
    <tr><td class="paramname">evidenceCollection</td><td>All collected evidence until now. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a45e766b635dea87edc8e81fa85af0f41">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="a11fb42dab3f4d7a0193c98a7053bae4e" name="a11fb42dab3f4d7a0193c98a7053bae4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fb42dab3f4d7a0193c98a7053bae4e">&#9670;&#160;</a></span>receiveSmoothedHomogeneityAndMaxDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::MPIParallelizedStrategy::receiveSmoothedHomogeneityAndMaxDensity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>homogeneity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDensity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to pass smoothed homogeneity and the maximal density to the tuning strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">homogeneity</td><td></td></tr>
    <tr><td class="paramname">maxDensity</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a3f063297e8df6c7903651232b372573c">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="ab5cadb79788c1b72ff159ecd8dac9b76" name="ab5cadb79788c1b72ff159ecd8dac9b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cadb79788c1b72ff159ecd8dac9b76">&#9670;&#160;</a></span>rejectConfiguration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::MPIParallelizedStrategy::rejectConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>indefinitely</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the strategy about a configuration that is (currently) invalid and thus can potentially be dropped from some internal storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configuration</td><td></td></tr>
    <tr><td class="paramname">indefinitely</td><td>Whether the given configuration will never be valid </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a3cc2e5b8444200e7429fd7dd457fc13f">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<a id="afeaed418a45c28014c345e5ee1b92ec3" name="afeaed418a45c28014c345e5ee1b92ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaed418a45c28014c345e5ee1b92ec3">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void autopas::MPIParallelizedStrategy::reset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tuningPhase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>configQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1EvidenceCollection.html">autopas::EvidenceCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>evidenceCollection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all internal parameters to the beginning of a new tuning phase. </p>
<p>This can also mean to reorder the configQueue to some initially expected state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iteration</td><td>Gives the current iteration to the tuning strategy. </td></tr>
    <tr><td class="paramname">tuningPhase</td><td>Gives the current tuning phase to the tuning strategy. </td></tr>
    <tr><td class="paramname">configQueue</td><td>Queue of configurations to be tested. The tuning strategy should edit this queue. </td></tr>
    <tr><td class="paramname">evidenceCollection</td><td>All collected evidence until now. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1TuningStrategyInterface.html#a7e9b4f910967a9a9251939ceaec3e755">autopas::TuningStrategyInterface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>autopas/tuning/tuningStrategy/<a class="el" href="MPIParallelizedStrategy_8h_source.html">MPIParallelizedStrategy.h</a></li>
<li>autopas/tuning/tuningStrategy/<a class="el" href="MPIParallelizedStrategy_8cpp.html">MPIParallelizedStrategy.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

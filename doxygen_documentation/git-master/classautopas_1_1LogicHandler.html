<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1LogicHandler.html">LogicHandler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classautopas_1_1LogicHandler-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::LogicHandler&lt; Particle &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classautopas_1_1LogicHandler.html" title="The LogicHandler takes care of the containers s.t.">LogicHandler</a> takes care of the containers s.t.  
 <a href="classautopas_1_1LogicHandler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LogicHandler_8h_source.html">LogicHandler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9031122152531661284ccad0d5074c6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a9031122152531661284ccad0d5074c6a">LogicHandler</a> (std::unordered_map&lt; InteractionTypeOption::Value, std::unique_ptr&lt; <a class="el" href="classautopas_1_1AutoTuner.html">AutoTuner</a> &gt; &gt; &amp;autotuners, const <a class="el" href="classautopas_1_1LogicHandlerInfo.html">LogicHandlerInfo</a> &amp;logicHandlerInfo, unsigned int rebuildFrequency, const std::string &amp;outputSuffix)</td></tr>
<tr class="memdesc:a9031122152531661284ccad0d5074c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="classautopas_1_1LogicHandler.html" title="The LogicHandler takes care of the containers s.t.">LogicHandler</a>.  <br /></td></tr>
<tr class="separator:a9031122152531661284ccad0d5074c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99decd018721d63d338665932cf50b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#ae99decd018721d63d338665932cf50b5">getContainer</a> ()</td></tr>
<tr class="memdesc:ae99decd018721d63d338665932cf50b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const reference to the currently selected particle container.  <br /></td></tr>
<tr class="separator:ae99decd018721d63d338665932cf50b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfe51ae56e730bcb340aa2d489eb5a4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a5cfe51ae56e730bcb340aa2d489eb5a4">collectLeavingParticlesFromBuffer</a> (bool insertOwnedParticlesToContainer)</td></tr>
<tr class="memdesc:a5cfe51ae56e730bcb340aa2d489eb5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects leaving particles from buffer and potentially inserts owned particles to the container.  <br /></td></tr>
<tr class="separator:a5cfe51ae56e730bcb340aa2d489eb5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950e4f12d30c1c86baca3f4f0cac4a87"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a950e4f12d30c1c86baca3f4f0cac4a87">updateContainer</a> ()</td></tr>
<tr class="memdesc:a950e4f12d30c1c86baca3f4f0cac4a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the container.    <br /></td></tr>
<tr class="separator:a950e4f12d30c1c86baca3f4f0cac4a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d664bd0982123285a0257473470a122"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a3d664bd0982123285a0257473470a122">resizeBox</a> (const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax)</td></tr>
<tr class="memdesc:a3d664bd0982123285a0257473470a122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass values to the actual container.  <br /></td></tr>
<tr class="separator:a3d664bd0982123285a0257473470a122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4e897c6d6c40cbeba37b89c480db65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a7e4e897c6d6c40cbeba37b89c480db65">reserve</a> (size_t numParticles)</td></tr>
<tr class="memdesc:a7e4e897c6d6c40cbeba37b89c480db65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates number of halo particles via <a class="el" href="namespaceautopas_1_1utils_1_1NumParticlesEstimator.html#a2e1945cd199bdc217e444dcbe9a895eb" title="Given a number of particles and the dimensions of a box, estimate the number of halo particles.">autopas::utils::NumParticlesEstimator::estimateNumHalosUniform()</a> then calls <a class="el" href="classautopas_1_1LogicHandler.html#a045baf3b7b135ea63d819a796052f530" title="Reserves space in the particle buffers and the container.">LogicHandler::reserve(size_t numParticles, size_t numHaloParticles)</a>.  <br /></td></tr>
<tr class="separator:a7e4e897c6d6c40cbeba37b89c480db65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045baf3b7b135ea63d819a796052f530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a045baf3b7b135ea63d819a796052f530">reserve</a> (size_t numParticles, size_t numHaloParticles)</td></tr>
<tr class="memdesc:a045baf3b7b135ea63d819a796052f530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space in the particle buffers and the container.  <br /></td></tr>
<tr class="separator:a045baf3b7b135ea63d819a796052f530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab7cbab0574ca34c46d8132e6113da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a8ab7cbab0574ca34c46d8132e6113da9">addParticle</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;p)</td></tr>
<tr class="memdesc:a8ab7cbab0574ca34c46d8132e6113da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container.    <br /></td></tr>
<tr class="separator:a8ab7cbab0574ca34c46d8132e6113da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd90c0c3a67f1dc93fd21ab8f34487e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a3dd90c0c3a67f1dc93fd21ab8f34487e">addHaloParticle</a> (const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;haloParticle)</td></tr>
<tr class="memdesc:a3dd90c0c3a67f1dc93fd21ab8f34487e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle to the container that lies in the halo region of the container.    <br /></td></tr>
<tr class="separator:a3dd90c0c3a67f1dc93fd21ab8f34487e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cf18238be4f7868aabd3d427ff144c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#af2cf18238be4f7868aabd3d427ff144c">deleteAllParticles</a> ()</td></tr>
<tr class="memdesc:af2cf18238be4f7868aabd3d427ff144c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all particles.    <br /></td></tr>
<tr class="separator:af2cf18238be4f7868aabd3d427ff144c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef89f96e6ab7c9844782cfa6cbda776c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#aef89f96e6ab7c9844782cfa6cbda776c">deleteParticleFromBuffers</a> (<a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;particle)</td></tr>
<tr class="memdesc:aef89f96e6ab7c9844782cfa6cbda776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a particle, checks if it is in any of the particle buffers, and deletes it from them if found.  <br /></td></tr>
<tr class="separator:aef89f96e6ab7c9844782cfa6cbda776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5c1c7cdbc3a8cf3d8e906a1904448c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a6b5c1c7cdbc3a8cf3d8e906a1904448c">decreaseParticleCounter</a> (<a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;particle)</td></tr>
<tr class="memdesc:a6b5c1c7cdbc3a8cf3d8e906a1904448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease the correct internal particle counters.  <br /></td></tr>
<tr class="separator:a6b5c1c7cdbc3a8cf3d8e906a1904448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93768f5136d14af5db2648ee5f42fca"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classautopas_1_1Functor.html">Functor</a> &gt; </td></tr>
<tr class="memitem:ab93768f5136d14af5db2648ee5f42fca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#ab93768f5136d14af5db2648ee5f42fca">computeInteractionsPipeline</a> (<a class="el" href="classautopas_1_1Functor.html">Functor</a> *functor, const InteractionTypeOption &amp;interactionType)</td></tr>
<tr class="memdesc:ab93768f5136d14af5db2648ee5f42fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function covers the full pipeline of all mechanics happening during the computation of particle interactions.  <br /></td></tr>
<tr class="separator:ab93768f5136d14af5db2648ee5f42fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c4090578945b237e3ff25bcb99425c"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:ae6c4090578945b237e3ff25bcb99425c"><td class="memTemplItemLeft" align="right" valign="top">Iterator::ParticleVecType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#ae6c4090578945b237e3ff25bcb99425c">gatherAdditionalVectors</a> (IteratorBehavior behavior)</td></tr>
<tr class="memdesc:ae6c4090578945b237e3ff25bcb99425c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the additional vectors vector for a given iterator behavior.  <br /></td></tr>
<tr class="separator:ae6c4090578945b237e3ff25bcb99425c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae238f0eb5d477092ed94472bd2a78a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">autopas::ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#ae238f0eb5d477092ed94472bd2a78a59">begin</a> (IteratorBehavior behavior)</td></tr>
<tr class="memdesc:ae238f0eb5d477092ed94472bd2a78a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles by using for(auto iter = autoPas.begin(); iter.isValid(); ++iter)    <br /></td></tr>
<tr class="separator:ae238f0eb5d477092ed94472bd2a78a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc75fcf53266ad7381692507a7c9e015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">autopas::ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#afc75fcf53266ad7381692507a7c9e015">begin</a> (IteratorBehavior behavior) const</td></tr>
<tr class="memdesc:afc75fcf53266ad7381692507a7c9e015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles by using for(auto iter = autoPas.begin(); iter.isValid(); ++iter)    <br /></td></tr>
<tr class="separator:afc75fcf53266ad7381692507a7c9e015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7ebb1c19c1fb4f1245eb61ca454fbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">autopas::ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#afc7ebb1c19c1fb4f1245eb61ca454fbd">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:afc7ebb1c19c1fb4f1245eb61ca454fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region.    <br /></td></tr>
<tr class="separator:afc7ebb1c19c1fb4f1245eb61ca454fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85eb07a39b7b33dce92b0b75b80025cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1ContainerIterator.html">autopas::ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a85eb07a39b7b33dce92b0b75b80025cd">getRegionIterator</a> (const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior) const</td></tr>
<tr class="memdesc:a85eb07a39b7b33dce92b0b75b80025cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all particles in a specified region.    <br /></td></tr>
<tr class="separator:a85eb07a39b7b33dce92b0b75b80025cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef3cd79f071f1b5996daeb4e339d69f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#aeef3cd79f071f1b5996daeb4e339d69f">getNumberOfParticlesOwned</a> () const</td></tr>
<tr class="memdesc:aeef3cd79f071f1b5996daeb4e339d69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of owned particles.  <br /></td></tr>
<tr class="separator:aeef3cd79f071f1b5996daeb4e339d69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baa3c9ae05b9b970216044fc4674a0a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a4baa3c9ae05b9b970216044fc4674a0a">getNumberOfParticlesHalo</a> () const</td></tr>
<tr class="memdesc:a4baa3c9ae05b9b970216044fc4674a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of halo particles.  <br /></td></tr>
<tr class="separator:a4baa3c9ae05b9b970216044fc4674a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f090e47e10a11905090526c2b89635"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a28f090e47e10a11905090526c2b89635">checkTuningStates</a> (const InteractionTypeOption &amp;interactionType)</td></tr>
<tr class="memdesc:a28f090e47e10a11905090526c2b89635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if other autotuners for any other interaction types are still in a tuning phase.  <br /></td></tr>
<tr class="separator:a28f090e47e10a11905090526c2b89635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a557fe26729a6105cbb1fa1e82471d"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classautopas_1_1Functor.html">Functor</a> &gt; </td></tr>
<tr class="memitem:a30a557fe26729a6105cbb1fa1e82471d"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::optional&lt; std::unique_ptr&lt; <a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> &gt; &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a30a557fe26729a6105cbb1fa1e82471d">isConfigurationApplicable</a> (const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;conf, <a class="el" href="classautopas_1_1Functor.html">Functor</a> &amp;functor, const InteractionTypeOption &amp;interactionType)</td></tr>
<tr class="memdesc:a30a557fe26729a6105cbb1fa1e82471d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given configuration can be used with the given functor and the current state of the simulation.  <br /></td></tr>
<tr class="separator:a30a557fe26729a6105cbb1fa1e82471d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b1075231ded94518b82f306d47735a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a04b1075231ded94518b82f306d47735a">setParticleBuffers</a> (const std::vector&lt; <a class="el" href="classautopas_1_1FullParticleCell.html">FullParticleCell</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &gt; &amp;particleBuffers, const std::vector&lt; <a class="el" href="classautopas_1_1FullParticleCell.html">FullParticleCell</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &gt; &amp;haloParticleBuffers)</td></tr>
<tr class="memdesc:a04b1075231ded94518b82f306d47735a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly exchange the internal particle and halo buffers with the given vectors and update particle counters.  <br /></td></tr>
<tr class="separator:a04b1075231ded94518b82f306d47735a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df661fea7a9e5aa9a55fb482db9a06c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; const std::vector&lt; <a class="el" href="classautopas_1_1FullParticleCell.html">FullParticleCell</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &gt; &amp;, const std::vector&lt; <a class="el" href="classautopas_1_1FullParticleCell.html">FullParticleCell</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &gt; &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a5df661fea7a9e5aa9a55fb482db9a06c">getParticleBuffers</a> () const</td></tr>
<tr class="memdesc:a5df661fea7a9e5aa9a55fb482db9a06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the particle buffers.  <br /></td></tr>
<tr class="separator:a5df661fea7a9e5aa9a55fb482db9a06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9dd7862268a071a2d1d29791cc11f4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a8a9dd7862268a071a2d1d29791cc11f4">getMeanRebuildFrequency</a> () const</td></tr>
<tr class="memdesc:a8a9dd7862268a071a2d1d29791cc11f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the mean rebuild frequency.  <br /></td></tr>
<tr class="separator:a8a9dd7862268a071a2d1d29791cc11f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354e61596754ce846312a9b17f12666c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a354e61596754ce846312a9b17f12666c">getNeighborListsInvalidDoDynamicRebuild</a> ()</td></tr>
<tr class="memdesc:a354e61596754ce846312a9b17f12666c"><td class="mdescLeft">&#160;</td><td class="mdescRight">getter function for _neighborListInvalidDoDynamicRebuild  <br /></td></tr>
<tr class="separator:a354e61596754ce846312a9b17f12666c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51886e568f25c3f0e980d4fe6b1bfdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#ab51886e568f25c3f0e980d4fe6b1bfdd">checkNeighborListsInvalidDoDynamicRebuild</a> ()</td></tr>
<tr class="memdesc:ab51886e568f25c3f0e980d4fe6b1bfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any particle has moved more than skin/2.  <br /></td></tr>
<tr class="separator:ab51886e568f25c3f0e980d4fe6b1bfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfde29220792eb638b7b28cfff441a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#afbfde29220792eb638b7b28cfff441a2">resetNeighborListsInvalidDoDynamicRebuild</a> ()</td></tr>
<tr class="memdesc:afbfde29220792eb638b7b28cfff441a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any particle has moved more than skin/2.  <br /></td></tr>
<tr class="separator:afbfde29220792eb638b7b28cfff441a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65405829719e325bbf2a2f5d59fe58b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1LogicHandler.html#a65405829719e325bbf2a2f5d59fe58b4">neighborListsAreValid</a> ()</td></tr>
<tr class="memdesc:a65405829719e325bbf2a2f5d59fe58b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if in the next iteration the neighbor lists have to be rebuilt.  <br /></td></tr>
<tr class="separator:a65405829719e325bbf2a2f5d59fe58b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>&gt;<br />
class autopas::LogicHandler&lt; Particle &gt;</div><p>The <a class="el" href="classautopas_1_1LogicHandler.html" title="The LogicHandler takes care of the containers s.t.">LogicHandler</a> takes care of the containers s.t. </p>
<p>they are all in the same valid state. This is mainly done by incorporating a global container rebuild frequency, which defines when containers and their neighbor lists will be rebuilt. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9031122152531661284ccad0d5074c6a" name="a9031122152531661284ccad0d5074c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9031122152531661284ccad0d5074c6a">&#9670;&#160;</a></span>LogicHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::LogicHandler </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; InteractionTypeOption::Value, std::unique_ptr&lt; <a class="el" href="classautopas_1_1AutoTuner.html">AutoTuner</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>autotuners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1LogicHandlerInfo.html">LogicHandlerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>logicHandlerInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rebuildFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>outputSuffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="classautopas_1_1LogicHandler.html" title="The LogicHandler takes care of the containers s.t.">LogicHandler</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autotuners</td><td>Unordered map with interaction types and respective autotuner instances. </td></tr>
    <tr><td class="paramname">logicHandlerInfo</td><td></td></tr>
    <tr><td class="paramname">rebuildFrequency</td><td></td></tr>
    <tr><td class="paramname">outputSuffix</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3dd90c0c3a67f1dc93fd21ab8f34487e" name="a3dd90c0c3a67f1dc93fd21ab8f34487e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd90c0c3a67f1dc93fd21ab8f34487e">&#9670;&#160;</a></span>addHaloParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::addHaloParticle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;&#160;</td>
          <td class="paramname"><em>haloParticle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a particle to the container that lies in the halo region of the container.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haloParticle</td><td>Particle to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>An exception is thrown if the halo particle is added and it is inside of the owned domain (defined by boxMin and boxMax) of the container. </dd>
<dd>
This function is NOT thread-safe if the container is <a class="el" href="classautopas_1_1Octree.html" title="The octree is a CellBasedParticleContainer that consists internally of two octrees.">Octree</a>.   </dd></dl>

</div>
</div>
<a id="a8ab7cbab0574ca34c46d8132e6113da9" name="a8ab7cbab0574ca34c46d8132e6113da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab7cbab0574ca34c46d8132e6113da9">&#9670;&#160;</a></span>addParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::addParticle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a particle to the container.   </p>
<p>This is only allowed if the neighbor lists are not valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Reference to the particle to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>An exception is thrown if the particle is added and it is not inside of the owned domain (defined by boxMin and boxMax) of the container. </dd>
<dd>
This function is NOT thread-safe if the container is <a class="el" href="classautopas_1_1Octree.html" title="The octree is a CellBasedParticleContainer that consists internally of two octrees.">Octree</a>.   </dd></dl>

</div>
</div>
<a id="ae238f0eb5d477092ed94472bd2a78a59" name="ae238f0eb5d477092ed94472bd2a78a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae238f0eb5d477092ed94472bd2a78a59">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">autopas::ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, false &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles by using for(auto iter = autoPas.begin(); iter.isValid(); ++iter)   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>The behavior of the iterator. You can specify whether to iterate over owned particles, halo particles, or both. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first particle.   </dd></dl>

</div>
</div>
<a id="afc75fcf53266ad7381692507a7c9e015" name="afc75fcf53266ad7381692507a7c9e015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc75fcf53266ad7381692507a7c9e015">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">autopas::ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, false &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles by using for(auto iter = autoPas.begin(); iter.isValid(); ++iter)   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>The behavior of the iterator. You can specify whether to iterate over owned particles, halo particles, or both. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first particle.   </dd></dl>

</div>
</div>
<a id="ab51886e568f25c3f0e980d4fe6b1bfdd" name="ab51886e568f25c3f0e980d4fe6b1bfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51886e568f25c3f0e980d4fe6b1bfdd">&#9670;&#160;</a></span>checkNeighborListsInvalidDoDynamicRebuild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::checkNeighborListsInvalidDoDynamicRebuild</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any particle has moved more than skin/2. </p>
<p>updates bool: _neighborListInvalidDoDynamicRebuild </p>

</div>
</div>
<a id="a28f090e47e10a11905090526c2b89635" name="a28f090e47e10a11905090526c2b89635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f090e47e10a11905090526c2b89635">&#9670;&#160;</a></span>checkTuningStates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::checkTuningStates </td>
          <td>(</td>
          <td class="paramtype">const InteractionTypeOption &amp;&#160;</td>
          <td class="paramname"><em>interactionType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if other autotuners for any other interaction types are still in a tuning phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interactionType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool whether other tuners are still tuning. </dd></dl>

</div>
</div>
<a id="a5cfe51ae56e730bcb340aa2d489eb5a4" name="a5cfe51ae56e730bcb340aa2d489eb5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfe51ae56e730bcb340aa2d489eb5a4">&#9670;&#160;</a></span>collectLeavingParticlesFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::collectLeavingParticlesFromBuffer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>insertOwnedParticlesToContainer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects leaving particles from buffer and potentially inserts owned particles to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insertOwnedParticlesToContainer</td><td>Decides whether to insert owned particles to the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Leaving particles. </dd></dl>

</div>
</div>
<a id="ab93768f5136d14af5db2648ee5f42fca" name="ab93768f5136d14af5db2648ee5f42fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93768f5136d14af5db2648ee5f42fca">&#9670;&#160;</a></span>computeInteractionsPipeline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="classautopas_1_1Functor.html">Functor</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::computeInteractionsPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1Functor.html">Functor</a> *&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InteractionTypeOption &amp;&#160;</td>
          <td class="paramname"><em>interactionType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function covers the full pipeline of all mechanics happening during the computation of particle interactions. </p>
<p>This includes:</p><ul>
<li>selecting a configuration<ul>
<li>gather live info, homogeneity, and max density</li>
<li>get next config (tuning)</li>
<li>check applicability</li>
<li>instantiation of traversal and container</li>
</ul>
</li>
<li>triggering iteration and tuning result logger</li>
<li>computing the interactions<ul>
<li>init and end traversal</li>
<li>remainder traversal</li>
<li>measurements</li>
</ul>
</li>
<li>pass measurements to tuner</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classautopas_1_1Functor.html" title="Functor base class.">Functor</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td></td></tr>
    <tr><td class="paramname">interactionType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this was a tuning iteration. </dd></dl>
<p>Selection of configuration (tuning if necessary)</p>
<p>Computing the particle interactions</p>
<p>Debug Output</p>
<p>Pass on measurements</p>

</div>
</div>
<a id="a6b5c1c7cdbc3a8cf3d8e906a1904448c" name="a6b5c1c7cdbc3a8cf3d8e906a1904448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5c1c7cdbc3a8cf3d8e906a1904448c">&#9670;&#160;</a></span>decreaseParticleCounter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::decreaseParticleCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrease the correct internal particle counters. </p>
<p>This function should always be called if individual particles are deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td>reference to particles that should be deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2cf18238be4f7868aabd3d427ff144c" name="af2cf18238be4f7868aabd3d427ff144c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cf18238be4f7868aabd3d427ff144c">&#9670;&#160;</a></span>deleteAllParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::deleteAllParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all particles.   </p>
<dl class="section note"><dt>Note</dt><dd>This invalidates the container, a rebuild is forced on the next computeInteractions() call.   </dd></dl>

</div>
</div>
<a id="aef89f96e6ab7c9844782cfa6cbda776c" name="aef89f96e6ab7c9844782cfa6cbda776c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef89f96e6ab7c9844782cfa6cbda776c">&#9670;&#160;</a></span>deleteParticleFromBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, bool &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::deleteParticleFromBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a particle, checks if it is in any of the particle buffers, and deletes it from them if found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td>Particle to delete. If something was deleted this reference might point to a different particle or invalid memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple: &lt;True iff the particle was found and deleted, True iff the reference is valid&gt; </dd></dl>

</div>
</div>
<a id="ae6c4090578945b237e3ff25bcb99425c" name="ae6c4090578945b237e3ff25bcb99425c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c4090578945b237e3ff25bcb99425c">&#9670;&#160;</a></span>gatherAdditionalVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator::ParticleVecType <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::gatherAdditionalVectors </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the additional vectors vector for a given iterator behavior. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of pointers to buffer vectors. </dd></dl>

</div>
</div>
<a id="ae99decd018721d63d338665932cf50b5" name="ae99decd018721d63d338665932cf50b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99decd018721d63d338665932cf50b5">&#9670;&#160;</a></span>getContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ParticleContainerInterface.html">autopas::ParticleContainerInterface</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &amp; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-const reference to the currently selected particle container. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-const reference to the container. </dd></dl>

</div>
</div>
<a id="a8a9dd7862268a071a2d1d29791cc11f4" name="a8a9dd7862268a071a2d1d29791cc11f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9dd7862268a071a2d1d29791cc11f4">&#9670;&#160;</a></span>getMeanRebuildFrequency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getMeanRebuildFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the mean rebuild frequency. </p>
<p>Helpful for determining the frequency for the dynamic containers This function is only used for dynamic containers currently but returns user defined rebuild frequency for static case for safety. </p><dl class="section return"><dt>Returns</dt><dd>value of the mean frequency as double </dd></dl>

</div>
</div>
<a id="a354e61596754ce846312a9b17f12666c" name="a354e61596754ce846312a9b17f12666c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354e61596754ce846312a9b17f12666c">&#9670;&#160;</a></span>getNeighborListsInvalidDoDynamicRebuild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getNeighborListsInvalidDoDynamicRebuild</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getter function for _neighborListInvalidDoDynamicRebuild </p>
<dl class="section return"><dt>Returns</dt><dd>bool stored in _neighborListInvalidDoDynamicRebuild </dd></dl>

</div>
</div>
<a id="a4baa3c9ae05b9b970216044fc4674a0a" name="a4baa3c9ae05b9b970216044fc4674a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4baa3c9ae05b9b970216044fc4674a0a">&#9670;&#160;</a></span>getNumberOfParticlesHalo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getNumberOfParticlesHalo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of halo particles. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aeef3cd79f071f1b5996daeb4e339d69f" name="aeef3cd79f071f1b5996daeb4e339d69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef3cd79f071f1b5996daeb4e339d69f">&#9670;&#160;</a></span>getNumberOfParticlesOwned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getNumberOfParticlesOwned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of owned particles. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a5df661fea7a9e5aa9a55fb482db9a06c" name="a5df661fea7a9e5aa9a55fb482db9a06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df661fea7a9e5aa9a55fb482db9a06c">&#9670;&#160;</a></span>getParticleBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const std::vector&lt; <a class="el" href="classautopas_1_1FullParticleCell.html">FullParticleCell</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &gt; &amp;, const std::vector&lt; <a class="el" href="classautopas_1_1FullParticleCell.html">FullParticleCell</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &gt; &amp; &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getParticleBuffers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the particle buffers. </p>
<dl class="section note"><dt>Note</dt><dd>Intended for tests only.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>tuple of const references to the internal buffers. </dd></dl>

</div>
</div>
<a id="afc7ebb1c19c1fb4f1245eb61ca454fbd" name="afc7ebb1c19c1fb4f1245eb61ca454fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7ebb1c19c1fb4f1245eb61ca454fbd">&#9670;&#160;</a></span>getRegionIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">autopas::ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, true, true &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getRegionIterator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles in a specified region.   </p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> iter = container.getRegionIterator(lowCorner, highCorner); iter.isValid(); ++iter) { }</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerCorner</td><td>lower corner of the region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>higher corner of the region </td></tr>
    <tr><td class="paramname">behavior</td><td>the behavior of the iterator. You can specify whether to iterate over owned particles, halo particles, or both. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to iterate over all particles in a specific region   </dd></dl>

</div>
</div>
<a id="a85eb07a39b7b33dce92b0b75b80025cd" name="a85eb07a39b7b33dce92b0b75b80025cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85eb07a39b7b33dce92b0b75b80025cd">&#9670;&#160;</a></span>getRegionIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1ContainerIterator.html">autopas::ContainerIterator</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a>, false, true &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::getRegionIterator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all particles in a specified region.   </p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> iter = container.getRegionIterator(lowCorner, highCorner); iter.isValid(); ++iter) { }</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerCorner</td><td>lower corner of the region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>higher corner of the region </td></tr>
    <tr><td class="paramname">behavior</td><td>the behavior of the iterator. You can specify whether to iterate over owned particles, halo particles, or both. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to iterate over all particles in a specific region   </dd></dl>

</div>
</div>
<a id="a30a557fe26729a6105cbb1fa1e82471d" name="a30a557fe26729a6105cbb1fa1e82471d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a557fe26729a6105cbb1fa1e82471d">&#9670;&#160;</a></span>isConfigurationApplicable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="classautopas_1_1Functor.html">Functor</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::optional&lt; std::unique_ptr&lt; <a class="el" href="classautopas_1_1TraversalInterface.html">TraversalInterface</a> &gt; &gt;, bool &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::isConfigurationApplicable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classautopas_1_1Functor.html">Functor</a> &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InteractionTypeOption &amp;&#160;</td>
          <td class="paramname"><em>interactionType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given configuration can be used with the given functor and the current state of the simulation. </p>
<dl class="section note"><dt>Note</dt><dd>For the checks we need to switch to the container in the config, hece this function can't be const. Also we need to build the traversal, hence, it is returned.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classautopas_1_1Functor.html" title="Functor base class.">Functor</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td></td></tr>
    <tr><td class="paramname">functor</td><td></td></tr>
    <tr><td class="paramname">interactionType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple&lt;optional&lt;Traversal&gt;, rejectIndefinitely&gt; The optional is empty if the configuration is not applicable The bool rejectIndefinitely indicates if the configuration can be completely removed from the search space because it will never be applicable. </dd></dl>

</div>
</div>
<a id="a65405829719e325bbf2a2f5d59fe58b4" name="a65405829719e325bbf2a2f5d59fe58b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65405829719e325bbf2a2f5d59fe58b4">&#9670;&#160;</a></span>neighborListsAreValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::neighborListsAreValid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if in the next iteration the neighbor lists have to be rebuilt. </p>
<p>This can be the case either because we hit the rebuild frequency or the dynamic rebuild criteria or because the auto tuner tests a new configuration.</p>
<dl class="section return"><dt>Returns</dt><dd>True iff the neighbor lists will not be rebuild. </dd></dl>

</div>
</div>
<a id="a7e4e897c6d6c40cbeba37b89c480db65" name="a7e4e897c6d6c40cbeba37b89c480db65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4e897c6d6c40cbeba37b89c480db65">&#9670;&#160;</a></span>reserve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numParticles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimates number of halo particles via <a class="el" href="namespaceautopas_1_1utils_1_1NumParticlesEstimator.html#a2e1945cd199bdc217e444dcbe9a895eb" title="Given a number of particles and the dimensions of a box, estimate the number of halo particles.">autopas::utils::NumParticlesEstimator::estimateNumHalosUniform()</a> then calls <a class="el" href="classautopas_1_1LogicHandler.html#a045baf3b7b135ea63d819a796052f530" title="Reserves space in the particle buffers and the container.">LogicHandler::reserve(size_t numParticles, size_t numHaloParticles)</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numParticles</td><td>Total number of owned particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a045baf3b7b135ea63d819a796052f530" name="a045baf3b7b135ea63d819a796052f530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045baf3b7b135ea63d819a796052f530">&#9670;&#160;</a></span>reserve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numHaloParticles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space in the particle buffers and the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numParticles</td><td>Total number of owned particles. </td></tr>
    <tr><td class="paramname">numHaloParticles</td><td>Total number of halo particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbfde29220792eb638b7b28cfff441a2" name="afbfde29220792eb638b7b28cfff441a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfde29220792eb638b7b28cfff441a2">&#9670;&#160;</a></span>resetNeighborListsInvalidDoDynamicRebuild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::resetNeighborListsInvalidDoDynamicRebuild</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any particle has moved more than skin/2. </p>
<p>resets bool: _neighborListInvalidDoDynamicRebuild to false </p>

</div>
</div>
<a id="a3d664bd0982123285a0257473470a122" name="a3d664bd0982123285a0257473470a122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d664bd0982123285a0257473470a122">&#9670;&#160;</a></span>resizeBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::resizeBox </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass values to the actual container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td></td></tr>
    <tr><td class="paramname">boxMax</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of particles that are outside the box after the resize. </dd></dl>

</div>
</div>
<a id="a04b1075231ded94518b82f306d47735a" name="a04b1075231ded94518b82f306d47735a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b1075231ded94518b82f306d47735a">&#9670;&#160;</a></span>setParticleBuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::setParticleBuffers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classautopas_1_1FullParticleCell.html">FullParticleCell</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>particleBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classautopas_1_1FullParticleCell.html">FullParticleCell</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>haloParticleBuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly exchange the internal particle and halo buffers with the given vectors and update particle counters. </p>
<dl class="section note"><dt>Note</dt><dd>This function is for testing purposes only! </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function only sets as many buffers as are given to it. E.g. if particleBuffers.size() == 3 but there <a class="el" href="classautopas_1_1LogicHandler.html" title="The LogicHandler takes care of the containers s.t.">LogicHandler</a> has 8 the last five buffers will not be touched.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particleBuffers</td><td></td></tr>
    <tr><td class="paramname">haloParticleBuffers</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a950e4f12d30c1c86baca3f4f0cac4a87" name="a950e4f12d30c1c86baca3f4f0cac4a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950e4f12d30c1c86baca3f4f0cac4a87">&#9670;&#160;</a></span>updateContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt; <a class="el" href="classautopas_1_1LogicHandler.html">autopas::LogicHandler</a>&lt; <a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2">Particle</a> &gt;::updateContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the container.   </p>
<p>On an update, halo particles are deleted and particles that do no longer belong into the container will be removed and returned. </p><dl class="section return"><dt>Returns</dt><dd>A vector of invalid particles that do no longer belong in the current container.   </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>autopas/<a class="el" href="AutoPasDecl_8h_source.html">AutoPasDecl.h</a></li>
<li>autopas/<a class="el" href="LogicHandler_8h_source.html">LogicHandler.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

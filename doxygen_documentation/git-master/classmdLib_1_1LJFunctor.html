<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mdLib</b></li><li class="navelem"><a class="el" href="classmdLib_1_1LJFunctor.html">LJFunctor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmdLib_1_1LJFunctor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mdLib::LJFunctor&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A functor to handle lennard-jones interactions between two particles (molecules).  
 <a href="classmdLib_1_1LJFunctor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LJFunctor_8h_source.html">LJFunctor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mdLib::LJFunctor&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmdLib_1_1LJFunctor__inherit__graph.png" border="0" usemap="#amdLib_1_1LJFunctor_3_01Particle__T_00_01applyShift_00_01useMixing_00_01useNewton3_00_01calculateGlobals_00_01countFLOPs_00_01relevantForTuning_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="amdLib_1_1LJFunctor_3_01Particle__T_00_01applyShift_00_01useMixing_00_01useNewton3_00_01calculateGlobals_00_01countFLOPs_00_01relevantForTuning_01_4_inherit__map" id="amdLib_1_1LJFunctor_3_01Particle__T_00_01applyShift_00_01useMixing_00_01useNewton3_00_01calculateGlobals_00_01countFLOPs_00_01relevantForTuning_01_4_inherit__map">
<area shape="rect" title="A functor to handle lennard&#45;jones interactions between two particles (molecules)." alt="" coords="5,181,247,251"/>
<area shape="rect" href="classautopas_1_1PairwiseFunctor.html" title="PairwiseFunctor class." alt="" coords="34,93,218,133"/>
<area shape="poly" title=" " alt="" coords="129,147,129,181,123,181,123,147"/>
<area shape="rect" href="classautopas_1_1Functor.html" title="Functor base class." alt="" coords="29,5,223,45"/>
<area shape="poly" title=" " alt="" coords="129,59,129,93,123,93,123,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mdLib::LJFunctor&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmdLib_1_1LJFunctor__coll__graph.png" border="0" usemap="#amdLib_1_1LJFunctor_3_01Particle__T_00_01applyShift_00_01useMixing_00_01useNewton3_00_01calculateGlobals_00_01countFLOPs_00_01relevantForTuning_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="amdLib_1_1LJFunctor_3_01Particle__T_00_01applyShift_00_01useMixing_00_01useNewton3_00_01calculateGlobals_00_01countFLOPs_00_01relevantForTuning_01_4_coll__map" id="amdLib_1_1LJFunctor_3_01Particle__T_00_01applyShift_00_01useMixing_00_01useNewton3_00_01calculateGlobals_00_01countFLOPs_00_01relevantForTuning_01_4_coll__map">
<area shape="rect" title="A functor to handle lennard&#45;jones interactions between two particles (molecules)." alt="" coords="5,181,247,251"/>
<area shape="rect" href="classautopas_1_1PairwiseFunctor.html" title="PairwiseFunctor class." alt="" coords="34,93,218,133"/>
<area shape="poly" title=" " alt="" coords="129,147,129,181,123,181,123,147"/>
<area shape="rect" href="classautopas_1_1Functor.html" title="Functor base class." alt="" coords="29,5,223,45"/>
<area shape="poly" title=" " alt="" coords="129,59,129,93,123,93,123,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73d7c732d3820e00b4e012958e1417c1"><td class="memItemLeft" align="right" valign="top"><a id="a73d7c732d3820e00b4e012958e1417c1" name="a73d7c732d3820e00b4e012958e1417c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LJFunctor</b> ()=delete</td></tr>
<tr class="memdesc:a73d7c732d3820e00b4e012958e1417c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted default constructor. <br /></td></tr>
<tr class="separator:a73d7c732d3820e00b4e012958e1417c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ad03aa6dd6a245bebd0bdc9afa7624"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a65ad03aa6dd6a245bebd0bdc9afa7624">LJFunctor</a> (double cutoff)</td></tr>
<tr class="memdesc:a65ad03aa6dd6a245bebd0bdc9afa7624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for Functor with mixing disabled.  <br /></td></tr>
<tr class="separator:a65ad03aa6dd6a245bebd0bdc9afa7624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc805a9a752d7f9950d4b288767f76a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#abc805a9a752d7f9950d4b288767f76a7">LJFunctor</a> (double cutoff, <a class="el" href="classParticlePropertiesLibrary.html">ParticlePropertiesLibrary</a>&lt; double, size_t &gt; &amp;particlePropertiesLibrary)</td></tr>
<tr class="memdesc:abc805a9a752d7f9950d4b288767f76a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for Functor with mixing active.  <br /></td></tr>
<tr class="separator:abc805a9a752d7f9950d4b288767f76a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9769d2ace227dbe1dd2d5fea443bde9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#aa9769d2ace227dbe1dd2d5fea443bde9">getName</a> () final</td></tr>
<tr class="memdesc:aa9769d2ace227dbe1dd2d5fea443bde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name of functor.  <br /></td></tr>
<tr class="separator:aa9769d2ace227dbe1dd2d5fea443bde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ff4b128a9c3d2a1a883de54a66075c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a71ff4b128a9c3d2a1a883de54a66075c">isRelevantForTuning</a> () final</td></tr>
<tr class="memdesc:a71ff4b128a9c3d2a1a883de54a66075c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the functor should be considered for the auto-tuning process.  <br /></td></tr>
<tr class="separator:a71ff4b128a9c3d2a1a883de54a66075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cfa35f63b7600dca3a9c6183e6d328"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a35cfa35f63b7600dca3a9c6183e6d328">allowsNewton3</a> () final</td></tr>
<tr class="memdesc:a35cfa35f63b7600dca3a9c6183e6d328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the functor is capable of Newton3-like functors.  <br /></td></tr>
<tr class="separator:a35cfa35f63b7600dca3a9c6183e6d328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c31cb0cbfbb94e4fad1a981a5d1d311"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a4c31cb0cbfbb94e4fad1a981a5d1d311">allowsNonNewton3</a> () final</td></tr>
<tr class="memdesc:a4c31cb0cbfbb94e4fad1a981a5d1d311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the functor is capable of non-Newton3-like functors.  <br /></td></tr>
<tr class="separator:a4c31cb0cbfbb94e4fad1a981a5d1d311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0a06a564b39bec05b5d0df0810656b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a2c0a06a564b39bec05b5d0df0810656b">AoSFunctor</a> (Particle_T &amp;i, Particle_T &amp;j, bool newton3) final</td></tr>
<tr class="memdesc:a2c0a06a564b39bec05b5d0df0810656b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PairwiseFunctor for arrays of structures (AoS).  <br /></td></tr>
<tr class="separator:a2c0a06a564b39bec05b5d0df0810656b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa642d0be6074fc0c3830bc2c1c97851b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#aa642d0be6074fc0c3830bc2c1c97851b">SoAFunctorSingle</a> (<a class="el" href="classautopas_1_1SoAView.html">autopas::SoAView</a>&lt; SoAArraysType &gt; soa, bool newton3) final</td></tr>
<tr class="memdesc:aa642d0be6074fc0c3830bc2c1c97851b"><td class="mdescLeft">&#160;</td><td class="mdescRight">PairwiseFunctor for structure of arrays (SoA)    <br /></td></tr>
<tr class="separator:aa642d0be6074fc0c3830bc2c1c97851b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fc5b02a7960335ebc0f51a649c9cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#ac6fc5b02a7960335ebc0f51a649c9cc0">SoAFunctorPair</a> (<a class="el" href="classautopas_1_1SoAView.html">autopas::SoAView</a>&lt; SoAArraysType &gt; soa1, <a class="el" href="classautopas_1_1SoAView.html">autopas::SoAView</a>&lt; SoAArraysType &gt; soa2, const bool newton3) final</td></tr>
<tr class="memdesc:ac6fc5b02a7960335ebc0f51a649c9cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">PairwiseFunctor for structure of arrays (SoA)    <br /></td></tr>
<tr class="separator:ac6fc5b02a7960335ebc0f51a649c9cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84e54186212c0fc3a328c82f456b041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#ad84e54186212c0fc3a328c82f456b041">SoAFunctorVerlet</a> (<a class="el" href="classautopas_1_1SoAView.html">autopas::SoAView</a>&lt; SoAArraysType &gt; soa, const size_t indexFirst, const std::vector&lt; size_t, <a class="el" href="classautopas_1_1AlignedAllocator.html">autopas::AlignedAllocator</a>&lt; size_t &gt; &gt; &amp;neighborList, bool newton3) final</td></tr>
<tr class="memdesc:ad84e54186212c0fc3a328c82f456b041"><td class="mdescLeft">&#160;</td><td class="mdescRight">PairwiseFunctor for structure of arrays (SoA) for neighbor lists.    <br /></td></tr>
<tr class="separator:ad84e54186212c0fc3a328c82f456b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbb53a1b5e4fcd9ca13c5606059f5ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#acbbb53a1b5e4fcd9ca13c5606059f5ee">setParticleProperties</a> (SoAFloatPrecision epsilon24, SoAFloatPrecision sigmaSquared)</td></tr>
<tr class="memdesc:acbbb53a1b5e4fcd9ca13c5606059f5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the particle properties constants for this functor.  <br /></td></tr>
<tr class="separator:acbbb53a1b5e4fcd9ca13c5606059f5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bd2f7125d061ecfefce58d368152f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a63bd2f7125d061ecfefce58d368152f5">initTraversal</a> () final</td></tr>
<tr class="memdesc:a63bd2f7125d061ecfefce58d368152f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the global values.  <br /></td></tr>
<tr class="separator:a63bd2f7125d061ecfefce58d368152f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abc81c19ffc22c11754ae4ee96ebfe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a6abc81c19ffc22c11754ae4ee96ebfe1">endTraversal</a> (bool newton3) final</td></tr>
<tr class="memdesc:a6abc81c19ffc22c11754ae4ee96ebfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulates global values, e.g.  <br /></td></tr>
<tr class="separator:a6abc81c19ffc22c11754ae4ee96ebfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccc8961a393c373f4e8f7110f129fdd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#aeccc8961a393c373f4e8f7110f129fdd">getPotentialEnergy</a> ()</td></tr>
<tr class="memdesc:aeccc8961a393c373f4e8f7110f129fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the potential Energy.  <br /></td></tr>
<tr class="separator:aeccc8961a393c373f4e8f7110f129fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33dcc427002a1e6c46e0e97760c507a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#af33dcc427002a1e6c46e0e97760c507a">getVirial</a> ()</td></tr>
<tr class="memdesc:af33dcc427002a1e6c46e0e97760c507a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the virial.  <br /></td></tr>
<tr class="separator:af33dcc427002a1e6c46e0e97760c507a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ba3e5eb6db0425dd8245e5489e8d34"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#ad8ba3e5eb6db0425dd8245e5489e8d34">getNumFLOPs</a> () const override</td></tr>
<tr class="memdesc:ad8ba3e5eb6db0425dd8245e5489e8d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of useful FLOPs.  <br /></td></tr>
<tr class="separator:ad8ba3e5eb6db0425dd8245e5489e8d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2167bf30db782d6d664a63bb83904907"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a2167bf30db782d6d664a63bb83904907">getHitRate</a> () const override</td></tr>
<tr class="memdesc:a2167bf30db782d6d664a63bb83904907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hit rate.  <br /></td></tr>
<tr class="separator:a2167bf30db782d6d664a63bb83904907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1PairwiseFunctor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1PairwiseFunctor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1PairwiseFunctor.html">autopas::PairwiseFunctor&lt; Particle_T, CRTP_T &gt;</a></td></tr>
<tr class="memitem:a7283bade069c84dd7127f98d60847747 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1PairwiseFunctor.html#a7283bade069c84dd7127f98d60847747">PairwiseFunctor</a> (double cutoff)</td></tr>
<tr class="memdesc:a7283bade069c84dd7127f98d60847747 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a7283bade069c84dd7127f98d60847747 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155981cf0de6fa795c2451dd76aba15c inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1PairwiseFunctor.html#a155981cf0de6fa795c2451dd76aba15c">AoSFunctor</a> (Particle_T &amp;i, Particle_T &amp;j, bool newton3)</td></tr>
<tr class="memdesc:a155981cf0de6fa795c2451dd76aba15c inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classautopas_1_1PairwiseFunctor.html" title="PairwiseFunctor class.">PairwiseFunctor</a> for arrays of structures (AoS).  <br /></td></tr>
<tr class="separator:a155981cf0de6fa795c2451dd76aba15c inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63b54372d07b7e3e43c61c633866a1 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1PairwiseFunctor.html#a7c63b54372d07b7e3e43c61c633866a1">SoAFunctorSingle</a> (<a class="el" href="classautopas_1_1SoAView.html">SoAView</a>&lt; <a class="el" href="classautopas_1_1PairwiseFunctor.html#a985a19e6e355ed5fe3349e063abbc3c8">SoAArraysType</a> &gt; soa, bool newton3)</td></tr>
<tr class="memdesc:a7c63b54372d07b7e3e43c61c633866a1 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classautopas_1_1PairwiseFunctor.html" title="PairwiseFunctor class.">PairwiseFunctor</a> for structure of arrays (<a class="el" href="classautopas_1_1SoA.html" title="Structur of the array class.">SoA</a>)  <br /></td></tr>
<tr class="separator:a7c63b54372d07b7e3e43c61c633866a1 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35103aa9afd3582f8e9f13635d77d6f2 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1PairwiseFunctor.html#a35103aa9afd3582f8e9f13635d77d6f2">SoAFunctorVerlet</a> (<a class="el" href="classautopas_1_1SoAView.html">SoAView</a>&lt; <a class="el" href="classautopas_1_1PairwiseFunctor.html#a985a19e6e355ed5fe3349e063abbc3c8">SoAArraysType</a> &gt; soa, const size_t indexFirst, const std::vector&lt; size_t, <a class="el" href="classautopas_1_1AlignedAllocator.html">AlignedAllocator</a>&lt; size_t &gt; &gt; &amp;neighborList, bool newton3)</td></tr>
<tr class="memdesc:a35103aa9afd3582f8e9f13635d77d6f2 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classautopas_1_1PairwiseFunctor.html" title="PairwiseFunctor class.">PairwiseFunctor</a> for structure of arrays (<a class="el" href="classautopas_1_1SoA.html" title="Structur of the array class.">SoA</a>) for neighbor lists.  <br /></td></tr>
<tr class="separator:a35103aa9afd3582f8e9f13635d77d6f2 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eee30da539b9d5a29b46efe6dac548 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1PairwiseFunctor.html#a40eee30da539b9d5a29b46efe6dac548">SoAFunctorPair</a> (<a class="el" href="classautopas_1_1SoAView.html">SoAView</a>&lt; <a class="el" href="classautopas_1_1PairwiseFunctor.html#a985a19e6e355ed5fe3349e063abbc3c8">SoAArraysType</a> &gt; soa1, <a class="el" href="classautopas_1_1SoAView.html">SoAView</a>&lt; <a class="el" href="classautopas_1_1PairwiseFunctor.html#a985a19e6e355ed5fe3349e063abbc3c8">SoAArraysType</a> &gt; soa2, bool newton3)</td></tr>
<tr class="memdesc:a40eee30da539b9d5a29b46efe6dac548 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classautopas_1_1PairwiseFunctor.html" title="PairwiseFunctor class.">PairwiseFunctor</a> for structure of arrays (<a class="el" href="classautopas_1_1SoA.html" title="Structur of the array class.">SoA</a>)  <br /></td></tr>
<tr class="separator:a40eee30da539b9d5a29b46efe6dac548 inherit pub_methods_classautopas_1_1PairwiseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1Functor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1Functor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1Functor.html">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a></td></tr>
<tr class="memitem:afed6dcea9e486bc915516b908993f732 inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#afed6dcea9e486bc915516b908993f732">Functor</a> (double cutoff)</td></tr>
<tr class="memdesc:afed6dcea9e486bc915516b908993f732 inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:afed6dcea9e486bc915516b908993f732 inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e39aead89b090626a48f9ca14f434 inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a503e39aead89b090626a48f9ca14f434">initTraversal</a> ()</td></tr>
<tr class="memdesc:a503e39aead89b090626a48f9ca14f434 inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called at the start of each traversal.  <br /></td></tr>
<tr class="separator:a503e39aead89b090626a48f9ca14f434 inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711efa689f2a60e152e08f4a35d2c6d5 inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a711efa689f2a60e152e08f4a35d2c6d5">endTraversal</a> (bool newton3)</td></tr>
<tr class="memdesc:a711efa689f2a60e152e08f4a35d2c6d5 inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called at the end of each traversal.  <br /></td></tr>
<tr class="separator:a711efa689f2a60e152e08f4a35d2c6d5 inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e64e3793965b449463d79d58c468e2 inherit pub_methods_classautopas_1_1Functor"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classautopas_1_1ParticleCell.html">ParticleCell</a> &gt; </td></tr>
<tr class="memitem:a07e64e3793965b449463d79d58c468e2 inherit pub_methods_classautopas_1_1Functor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a07e64e3793965b449463d79d58c468e2">SoALoader</a> (<a class="el" href="classautopas_1_1ParticleCell.html">ParticleCell</a> &amp;cell, <a class="el" href="classautopas_1_1SoA.html">SoA</a>&lt; <a class="el" href="classautopas_1_1Functor.html#ade3c3ee8bf3817d658ba65604117daaf">SoAArraysType</a> &gt; &amp;soa, size_t offset, bool skipSoAResize)</td></tr>
<tr class="memdesc:a07e64e3793965b449463d79d58c468e2 inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the AoS data of the given cell in the given soa.  <br /></td></tr>
<tr class="separator:a07e64e3793965b449463d79d58c468e2 inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1c1e569b241decd62f240e676152ae inherit pub_methods_classautopas_1_1Functor"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classautopas_1_1ParticleCell.html">ParticleCell</a> &gt; </td></tr>
<tr class="memitem:a3e1c1e569b241decd62f240e676152ae inherit pub_methods_classautopas_1_1Functor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a3e1c1e569b241decd62f240e676152ae">SoAExtractor</a> (<a class="el" href="classautopas_1_1ParticleCell.html">ParticleCell</a> &amp;cell, <a class="el" href="classautopas_1_1SoA.html">SoA</a>&lt; <a class="el" href="classautopas_1_1Functor.html#ade3c3ee8bf3817d658ba65604117daaf">SoAArraysType</a> &gt; &amp;soa, size_t offset)</td></tr>
<tr class="memdesc:a3e1c1e569b241decd62f240e676152ae inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data stored in the soa back into the cell.  <br /></td></tr>
<tr class="separator:a3e1c1e569b241decd62f240e676152ae inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d73694fff5e34055354bdfb1cf1815 inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a33d73694fff5e34055354bdfb1cf1815">allowsNewton3</a> ()=0</td></tr>
<tr class="memdesc:a33d73694fff5e34055354bdfb1cf1815 inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the functor is capable of Newton3-like functors.  <br /></td></tr>
<tr class="separator:a33d73694fff5e34055354bdfb1cf1815 inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677402004f6a9657957d8c4445316c1c inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a677402004f6a9657957d8c4445316c1c">allowsNonNewton3</a> ()=0</td></tr>
<tr class="memdesc:a677402004f6a9657957d8c4445316c1c inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the functor is capable of non-Newton3-like functors.  <br /></td></tr>
<tr class="separator:a677402004f6a9657957d8c4445316c1c inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862aaed02482568eca65d371ec58b996 inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a862aaed02482568eca65d371ec58b996">isRelevantForTuning</a> ()=0</td></tr>
<tr class="memdesc:a862aaed02482568eca65d371ec58b996 inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the functor should be considered for the auto-tuning process.  <br /></td></tr>
<tr class="separator:a862aaed02482568eca65d371ec58b996 inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9652e177442624498d47a1d083b7373e inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a9652e177442624498d47a1d083b7373e">getName</a> ()=0</td></tr>
<tr class="memdesc:a9652e177442624498d47a1d083b7373e inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name of functor.  <br /></td></tr>
<tr class="separator:a9652e177442624498d47a1d083b7373e inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c8ae835f14b7060ddf467e72a486c9 inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a71c8ae835f14b7060ddf467e72a486c9">getCutoff</a> () const</td></tr>
<tr class="memdesc:a71c8ae835f14b7060ddf467e72a486c9 inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the functor's cutoff.  <br /></td></tr>
<tr class="separator:a71c8ae835f14b7060ddf467e72a486c9 inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9ef7e5224728edc1c2abbe6c948660 inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#a0b9ef7e5224728edc1c2abbe6c948660">getNumFLOPs</a> () const</td></tr>
<tr class="memdesc:a0b9ef7e5224728edc1c2abbe6c948660 inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of FLOPs.  <br /></td></tr>
<tr class="separator:a0b9ef7e5224728edc1c2abbe6c948660 inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b1eb70e6570eb0d942f3ff75ed6075 inherit pub_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#ac4b1eb70e6570eb0d942f3ff75ed6075">getHitRate</a> () const</td></tr>
<tr class="memdesc:ac4b1eb70e6570eb0d942f3ff75ed6075 inherit pub_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hit rate.  <br /></td></tr>
<tr class="separator:ac4b1eb70e6570eb0d942f3ff75ed6075 inherit pub_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6a39fb4634c2a858bcbd8f71a8385be2"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a6a39fb4634c2a858bcbd8f71a8385be2">getNeededAttr</a> ()</td></tr>
<tr class="memdesc:a6a39fb4634c2a858bcbd8f71a8385be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes needed for computation.    <br /></td></tr>
<tr class="separator:a6a39fb4634c2a858bcbd8f71a8385be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa250f5a11fe2d6d01cdae30f318bd0d3"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#aa250f5a11fe2d6d01cdae30f318bd0d3">getNeededAttr</a> (std::false_type)</td></tr>
<tr class="memdesc:aa250f5a11fe2d6d01cdae30f318bd0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes needed for computation without N3 optimization.    <br /></td></tr>
<tr class="separator:aa250f5a11fe2d6d01cdae30f318bd0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc7b281d3a6f039064c547e773f0190"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#adfc7b281d3a6f039064c547e773f0190">getComputedAttr</a> ()</td></tr>
<tr class="memdesc:adfc7b281d3a6f039064c547e773f0190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes computed by this functor.    <br /></td></tr>
<tr class="separator:adfc7b281d3a6f039064c547e773f0190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0698bcce53fa9ed92c13c3252ccc8225"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdLib_1_1LJFunctor.html#a0698bcce53fa9ed92c13c3252ccc8225">getMixing</a> ()</td></tr>
<tr class="separator:a0698bcce53fa9ed92c13c3252ccc8225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classautopas_1_1Functor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classautopas_1_1Functor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classautopas_1_1Functor.html">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a></td></tr>
<tr class="memitem:af952eac8fe6fe61cdf9504e7df99e9cb inherit pub_static_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; typename Particle_T::AttributeNames, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#af952eac8fe6fe61cdf9504e7df99e9cb">getNeededAttr</a> ()</td></tr>
<tr class="memdesc:af952eac8fe6fe61cdf9504e7df99e9cb inherit pub_static_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes needed for computation.  <br /></td></tr>
<tr class="separator:af952eac8fe6fe61cdf9504e7df99e9cb inherit pub_static_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b1ce75b504639454746c5ca2e0b841 inherit pub_static_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; typename Particle_T::AttributeNames, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#aa2b1ce75b504639454746c5ca2e0b841">getNeededAttr</a> (std::false_type)</td></tr>
<tr class="memdesc:aa2b1ce75b504639454746c5ca2e0b841 inherit pub_static_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes needed for computation without N3 optimization.  <br /></td></tr>
<tr class="separator:aa2b1ce75b504639454746c5ca2e0b841 inherit pub_static_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98f3509e171a112c7de169095eeb9af inherit pub_static_methods_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; typename Particle_T::AttributeNames, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1Functor.html#af98f3509e171a112c7de169095eeb9af">getComputedAttr</a> ()</td></tr>
<tr class="memdesc:af98f3509e171a112c7de169095eeb9af inherit pub_static_methods_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes computed by this functor.  <br /></td></tr>
<tr class="separator:af98f3509e171a112c7de169095eeb9af inherit pub_static_methods_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classautopas_1_1PairwiseFunctor"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classautopas_1_1PairwiseFunctor')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classautopas_1_1PairwiseFunctor.html">autopas::PairwiseFunctor&lt; Particle_T, CRTP_T &gt;</a></td></tr>
<tr class="memitem:a985a19e6e355ed5fe3349e063abbc3c8 inherit pub_types_classautopas_1_1PairwiseFunctor"><td class="memItemLeft" align="right" valign="top"><a id="a985a19e6e355ed5fe3349e063abbc3c8" name="a985a19e6e355ed5fe3349e063abbc3c8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SoAArraysType</b> = typename Particle_T::SoAArraysType</td></tr>
<tr class="memdesc:a985a19e6e355ed5fe3349e063abbc3c8 inherit pub_types_classautopas_1_1PairwiseFunctor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of the SoAs defined by the particle. <br /></td></tr>
<tr class="separator:a985a19e6e355ed5fe3349e063abbc3c8 inherit pub_types_classautopas_1_1PairwiseFunctor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classautopas_1_1Functor"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classautopas_1_1Functor')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classautopas_1_1Functor.html">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a></td></tr>
<tr class="memitem:ade3c3ee8bf3817d658ba65604117daaf inherit pub_types_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top"><a id="ade3c3ee8bf3817d658ba65604117daaf" name="ade3c3ee8bf3817d658ba65604117daaf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SoAArraysType</b> = typename Particle_T::SoAArraysType</td></tr>
<tr class="memdesc:ade3c3ee8bf3817d658ba65604117daaf inherit pub_types_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure of the SoAs defined by the particle. <br /></td></tr>
<tr class="separator:ade3c3ee8bf3817d658ba65604117daaf inherit pub_types_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fec526d3ef5920b6241cf1239e719a inherit pub_types_classautopas_1_1Functor"><td class="memItemLeft" align="right" valign="top"><a id="a26fec526d3ef5920b6241cf1239e719a" name="a26fec526d3ef5920b6241cf1239e719a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Functor_T</b> = CRTP_T</td></tr>
<tr class="memdesc:a26fec526d3ef5920b6241cf1239e719a inherit pub_types_classautopas_1_1Functor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the Implementation type template publicly available. <br /></td></tr>
<tr class="separator:a26fec526d3ef5920b6241cf1239e719a inherit pub_types_classautopas_1_1Functor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Particle_T, bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt;<br />
class mdLib::LJFunctor&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;</div><p>A functor to handle lennard-jones interactions between two particles (molecules). </p>
<p>This functor assumes that duplicated calculations are always happening, which is characteristic for a Full-Shell scheme. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle_T</td><td>The type of particle. </td></tr>
    <tr><td class="paramname">applyShift</td><td>Switch for the lj potential to be truncated shifted. </td></tr>
    <tr><td class="paramname">useMixing</td><td>Switch for the functor to be used with multiple particle types. If set to false, _epsilon and _sigma need to be set and the constructor with PPL can be omitted. </td></tr>
    <tr><td class="paramname">useNewton3</td><td>Switch for the functor to support newton3 on, off or both. See FunctorN3Modes for possible values. </td></tr>
    <tr><td class="paramname">calculateGlobals</td><td>Defines whether the global values are to be calculated (energy, virial). </td></tr>
    <tr><td class="paramname">countFLOPs</td><td>counts FLOPs and hitrate </td></tr>
    <tr><td class="paramname">relevantForTuning</td><td>Whether or not the auto-tuner should consider this functor. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a65ad03aa6dd6a245bebd0bdc9afa7624" name="a65ad03aa6dd6a245bebd0bdc9afa7624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ad03aa6dd6a245bebd0bdc9afa7624">&#9670;&#160;</a></span>LJFunctor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::LJFunctor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for Functor with mixing disabled. </p>
<p>When using this functor it is necessary to call <a class="el" href="classmdLib_1_1LJFunctor.html#acbbb53a1b5e4fcd9ca13c5606059f5ee" title="Sets the particle properties constants for this functor.">setParticleProperties()</a> to set internal constants because it does not use a particle properties library.</p>
<dl class="section note"><dt>Note</dt><dd>Only to be used with mixing == false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cutoff</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc805a9a752d7f9950d4b288767f76a7" name="abc805a9a752d7f9950d4b288767f76a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc805a9a752d7f9950d4b288767f76a7">&#9670;&#160;</a></span>LJFunctor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::LJFunctor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticlePropertiesLibrary.html">ParticlePropertiesLibrary</a>&lt; double, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>particlePropertiesLibrary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for Functor with mixing active. </p>
<p>This functor takes a <a class="el" href="classParticlePropertiesLibrary.html" title="This class stores the (physical) properties of molecule types, and, in the case of multi-site molecul...">ParticlePropertiesLibrary</a> to look up (mixed) properties like sigma, epsilon and shift. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cutoff</td><td></td></tr>
    <tr><td class="paramname">particlePropertiesLibrary</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35cfa35f63b7600dca3a9c6183e6d328" name="a35cfa35f63b7600dca3a9c6183e6d328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cfa35f63b7600dca3a9c6183e6d328">&#9670;&#160;</a></span>allowsNewton3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::allowsNewton3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the functor is capable of Newton3-like functors. </p>
<p>If the functor provides an interface to soa or aos functions that utilize Newton's third law of motion (actio = reactio) to reduce the computational complexity this function should return true. If this is not the case this function should return false. </p><dl class="section return"><dt>Returns</dt><dd>true if and only if this functor provides an interface to Newton3-like functions. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1Functor.html#a33d73694fff5e34055354bdfb1cf1815">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="a4c31cb0cbfbb94e4fad1a981a5d1d311" name="a4c31cb0cbfbb94e4fad1a981a5d1d311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c31cb0cbfbb94e4fad1a981a5d1d311">&#9670;&#160;</a></span>allowsNonNewton3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::allowsNonNewton3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the functor is capable of non-Newton3-like functors. </p>
<p>If the functor provides an interface to soa or aos functions that do not utilize Newton's third law of motion (actio = reactio) this function should return true. If this is not the case this function should return false. </p><dl class="section return"><dt>Returns</dt><dd>true if and only if this functor provides an interface to functions that do not utilize Newton3. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1Functor.html#a677402004f6a9657957d8c4445316c1c">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="a2c0a06a564b39bec05b5d0df0810656b" name="a2c0a06a564b39bec05b5d0df0810656b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0a06a564b39bec05b5d0df0810656b">&#9670;&#160;</a></span>AoSFunctor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::AoSFunctor </td>
          <td>(</td>
          <td class="paramtype">Particle_T &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Particle_T &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newton3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PairwiseFunctor for arrays of structures (AoS). </p>
<p>This functor should calculate the forces or any other pair-wise interaction between two particles. This should include a cutoff check if needed! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Particle i </td></tr>
    <tr><td class="paramname">j</td><td>Particle j </td></tr>
    <tr><td class="paramname">newton3</td><td>defines whether or whether not to use newton 3 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1PairwiseFunctor.html#a155981cf0de6fa795c2451dd76aba15c">autopas::PairwiseFunctor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="a6abc81c19ffc22c11754ae4ee96ebfe1" name="a6abc81c19ffc22c11754ae4ee96ebfe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abc81c19ffc22c11754ae4ee96ebfe1">&#9670;&#160;</a></span>endTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::endTraversal </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newton3</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulates global values, e.g. </p>
<p>potential energy and virial. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newton3</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1Functor.html#a711efa689f2a60e152e08f4a35d2c6d5">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="adfc7b281d3a6f039064c547e773f0190" name="adfc7b281d3a6f039064c547e773f0190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc7b281d3a6f039064c547e773f0190">&#9670;&#160;</a></span>getComputedAttr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::getComputedAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get attributes computed by this functor.   </p>
<dl class="section return"><dt>Returns</dt><dd>Attributes computed by this functor. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>C++20: make this function virtual </dd></dl>

</div>
</div>
<a id="a2167bf30db782d6d664a63bb83904907" name="a2167bf30db782d6d664a63bb83904907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2167bf30db782d6d664a63bb83904907">&#9670;&#160;</a></span>getHitRate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::getHitRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the hit rate. </p>
<p>Implementation required if FLOPLogger used.</p>
<p>If derived class provides no implementation, the FLOPLogger interprets the default NaN output as invalid and leaves "Not Implemented" in the log.</p>
<dl class="section return"><dt>Returns</dt><dd>(number of kernel calls) / (number of distance calculations) </dd></dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1Functor.html#ac4b1eb70e6570eb0d942f3ff75ed6075">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="a0698bcce53fa9ed92c13c3252ccc8225" name="a0698bcce53fa9ed92c13c3252ccc8225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0698bcce53fa9ed92c13c3252ccc8225">&#9670;&#160;</a></span>getMixing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::getMixing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>useMixing </dd></dl>

</div>
</div>
<a id="aa9769d2ace227dbe1dd2d5fea443bde9" name="aa9769d2ace227dbe1dd2d5fea443bde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9769d2ace227dbe1dd2d5fea443bde9">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns name of functor. </p>
<p>Intended for use with the iteration logger, to differentiate between calls to computeInteractions using different functors in the logs. </p><dl class="section return"><dt>Returns</dt><dd>name of functor. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1Functor.html#a9652e177442624498d47a1d083b7373e">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="a6a39fb4634c2a858bcbd8f71a8385be2" name="a6a39fb4634c2a858bcbd8f71a8385be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a39fb4634c2a858bcbd8f71a8385be2">&#9670;&#160;</a></span>getNeededAttr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::getNeededAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get attributes needed for computation.   </p>
<dl class="section return"><dt>Returns</dt><dd>Attributes needed for computation. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>C++20: make this function virtual </dd></dl>

</div>
</div>
<a id="aa250f5a11fe2d6d01cdae30f318bd0d3" name="aa250f5a11fe2d6d01cdae30f318bd0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa250f5a11fe2d6d01cdae30f318bd0d3">&#9670;&#160;</a></span>getNeededAttr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::getNeededAttr </td>
          <td>(</td>
          <td class="paramtype">std::false_type&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get attributes needed for computation without N3 optimization.   </p>
<dl class="section return"><dt>Returns</dt><dd>Attributes needed for computation. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>C++20: make this function virtual </dd></dl>

</div>
</div>
<a id="ad8ba3e5eb6db0425dd8245e5489e8d34" name="ad8ba3e5eb6db0425dd8245e5489e8d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ba3e5eb6db0425dd8245e5489e8d34">&#9670;&#160;</a></span>getNumFLOPs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::getNumFLOPs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of useful FLOPs. </p>
<p>For the distance squared calculation, this is:</p><ul>
<li>Displacement: 3</li>
<li>DistanceSquared in each dimension: 3</li>
<li>DistanceSquared Total: 2</li>
<li>Total: 8</li>
</ul>
<p>For the force kernel, this is:</p><ul>
<li>inverse distance squared: 1 (assume division is 1 FLOP)</li>
<li>lj2: 1</li>
<li>lj6: 2</li>
<li>lj12: 1</li>
<li>lj12m6: 1</li>
<li>scalar factor: 3</li>
<li>force: 3</li>
<li>accumulate force on mol i: 3</li>
<li>accumulate force on mol j if n3: 3</li>
<li>Total: 15 without n3, 18 with n3</li>
</ul>
<p>For the globals calculation, this is:</p><ul>
<li>virial: 3</li>
<li>potential: 1, or 2 with shift</li>
<li>accumulation: 4 without n3, 8 with n3</li>
<li>Total: 8 or 9 without n3, 12 or 13 with n3</li>
</ul>
<p>Caveats:</p>
<p>This function is supposed to return useful FLOPs, e.g. without counting masked vector instructions. You could also argue that, strictly speaking, we redundantly calculate forces and globals twice in the newton3 case on a owned/halo boundary. This function does not treat such "redundant" calculations as useless. Similarly, this function does not treat halo-halo interactions as redundant useless calculations.</p>
<dl class="section return"><dt>Returns</dt><dd>number of FLOPs since <a class="el" href="classmdLib_1_1LJFunctor.html#a63bd2f7125d061ecfefce58d368152f5" title="Reset the global values.">initTraversal()</a> is called. </dd></dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1Functor.html#a0b9ef7e5224728edc1c2abbe6c948660">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="aeccc8961a393c373f4e8f7110f129fdd" name="aeccc8961a393c373f4e8f7110f129fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccc8961a393c373f4e8f7110f129fdd">&#9670;&#160;</a></span>getPotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::getPotentialEnergy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the potential Energy. </p>
<dl class="section return"><dt>Returns</dt><dd>the potential Energy </dd></dl>

</div>
</div>
<a id="af33dcc427002a1e6c46e0e97760c507a" name="af33dcc427002a1e6c46e0e97760c507a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33dcc427002a1e6c46e0e97760c507a">&#9670;&#160;</a></span>getVirial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::getVirial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the virial. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a63bd2f7125d061ecfefce58d368152f5" name="a63bd2f7125d061ecfefce58d368152f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bd2f7125d061ecfefce58d368152f5">&#9670;&#160;</a></span>initTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::initTraversal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the global values. </p>
<p>Will set the global values to zero to prepare for the next iteration. </p>

<p>Reimplemented from <a class="el" href="classautopas_1_1Functor.html#a503e39aead89b090626a48f9ca14f434">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="a71ff4b128a9c3d2a1a883de54a66075c" name="a71ff4b128a9c3d2a1a883de54a66075c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ff4b128a9c3d2a1a883de54a66075c">&#9670;&#160;</a></span>isRelevantForTuning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::isRelevantForTuning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the functor should be considered for the auto-tuning process. </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if this functor is relevant for auto-tuning. </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1Functor.html#a862aaed02482568eca65d371ec58b996">autopas::Functor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="acbbb53a1b5e4fcd9ca13c5606059f5ee" name="acbbb53a1b5e4fcd9ca13c5606059f5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbb53a1b5e4fcd9ca13c5606059f5ee">&#9670;&#160;</a></span>setParticleProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::setParticleProperties </td>
          <td>(</td>
          <td class="paramtype">SoAFloatPrecision&#160;</td>
          <td class="paramname"><em>epsilon24</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SoAFloatPrecision&#160;</td>
          <td class="paramname"><em>sigmaSquared</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the particle properties constants for this functor. </p>
<p>This is only necessary if no particlePropertiesLibrary is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon24</td><td></td></tr>
    <tr><td class="paramname">sigmaSquared</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6fc5b02a7960335ebc0f51a649c9cc0" name="ac6fc5b02a7960335ebc0f51a649c9cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fc5b02a7960335ebc0f51a649c9cc0">&#9670;&#160;</a></span>SoAFunctorPair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::SoAFunctorPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1SoAView.html">autopas::SoAView</a>&lt; SoAArraysType &gt;&#160;</td>
          <td class="paramname"><em>soa1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classautopas_1_1SoAView.html">autopas::SoAView</a>&lt; SoAArraysType &gt;&#160;</td>
          <td class="paramname"><em>soa2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>newton3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PairwiseFunctor for structure of arrays (SoA)   </p>
<p>This functor should calculate the forces or any other pair-wise interaction between all particles of soa1 and soa2. This should include a cutoff check if needed!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soa1</td><td>First structure of arrays. </td></tr>
    <tr><td class="paramname">soa2</td><td>Second structure of arrays. </td></tr>
    <tr><td class="paramname">newton3</td><td>defines whether or whether not to use newton 3   </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1PairwiseFunctor.html#a40eee30da539b9d5a29b46efe6dac548">autopas::PairwiseFunctor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="aa642d0be6074fc0c3830bc2c1c97851b" name="aa642d0be6074fc0c3830bc2c1c97851b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa642d0be6074fc0c3830bc2c1c97851b">&#9670;&#160;</a></span>SoAFunctorSingle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::SoAFunctorSingle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1SoAView.html">autopas::SoAView</a>&lt; SoAArraysType &gt;&#160;</td>
          <td class="paramname"><em>soa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newton3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PairwiseFunctor for structure of arrays (SoA)   </p>
<p>This functor should calculate the forces or any other pair-wise interaction between all particles in an soa. This should include a cutoff check if needed!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soa</td><td>Structure of arrays </td></tr>
    <tr><td class="paramname">newton3</td><td>defines whether or whether not to use newton 3   This functor will always use a newton3 like traversal of the soa. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1PairwiseFunctor.html#a7c63b54372d07b7e3e43c61c633866a1">autopas::PairwiseFunctor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<a id="ad84e54186212c0fc3a328c82f456b041" name="ad84e54186212c0fc3a328c82f456b041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84e54186212c0fc3a328c82f456b041">&#9670;&#160;</a></span>SoAFunctorVerlet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T , bool applyShift = false, bool useMixing = false, <a class="el" href="namespaceautopas.html#aae98cfb33c0ad2e9682bff91f985fcdb">autopas::FunctorN3Modes</a> useNewton3 = autopas::FunctorN3Modes::Both, bool calculateGlobals = false, bool countFLOPs = false, bool relevantForTuning = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmdLib_1_1LJFunctor.html">mdLib::LJFunctor</a>&lt; Particle_T, applyShift, useMixing, useNewton3, calculateGlobals, countFLOPs, relevantForTuning &gt;::SoAFunctorVerlet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classautopas_1_1SoAView.html">autopas::SoAView</a>&lt; SoAArraysType &gt;&#160;</td>
          <td class="paramname"><em>soa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>indexFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t, <a class="el" href="classautopas_1_1AlignedAllocator.html">autopas::AlignedAllocator</a>&lt; size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighborList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newton3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PairwiseFunctor for structure of arrays (SoA) for neighbor lists.   </p>
<p>This functor should calculate the forces or any other pair-wise interaction between the particle in the SoA with index indexFirst and all particles with indices in the neighborList. This should include a cutoff check if needed!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soa</td><td>Structure of arrays </td></tr>
    <tr><td class="paramname">indexFirst</td><td>The index of the first particle for each interaction </td></tr>
    <tr><td class="paramname">neighborList</td><td>The list of neighbors </td></tr>
    <tr><td class="paramname">newton3</td><td>defines whether or whether not to use newton 3   </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you want to parallelize this by openmp, please ensure that there are no dependencies, i.e. introduce colors! </dd></dl>

<p>Reimplemented from <a class="el" href="classautopas_1_1PairwiseFunctor.html#a35103aa9afd3582f8e9f13635d77d6f2">autopas::PairwiseFunctor&lt; Particle_T, CRTP_T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/applicationLibrary/molecularDynamics/molecularDynamicsLibrary/<a class="el" href="LJFunctor_8h_source.html">LJFunctor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

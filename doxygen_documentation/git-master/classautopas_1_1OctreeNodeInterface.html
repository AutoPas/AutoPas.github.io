<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classautopas_1_1OctreeNodeInterface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::OctreeNodeInterface&lt; Particle_T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The base class that provides the necessary function definitions that can be applied to an octree.  
 <a href="classautopas_1_1OctreeNodeInterface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OctreeNodeInterface_8h_source.html">OctreeNodeInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::OctreeNodeInterface&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1OctreeNodeInterface__inherit__graph.png" border="0" usemap="#aautopas_1_1OctreeNodeInterface_3_01Particle__T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1OctreeNodeInterface_3_01Particle__T_01_4_inherit__map" id="aautopas_1_1OctreeNodeInterface_3_01Particle__T_01_4_inherit__map">
<area shape="rect" title="The base class that provides the necessary function definitions that can be applied to an octree." alt="" coords="99,5,317,45"/>
<area shape="rect" href="classautopas_1_1OctreeInnerNode.html" title="Inner nodes of the octree data structure." alt="" coords="5,93,197,133"/>
<area shape="poly" title=" " alt="" coords="175,56,127,95,123,91,172,52"/>
<area shape="rect" href="classautopas_1_1OctreeLeafNode.html" title="An octree leaf node." alt="" coords="221,93,408,133"/>
<area shape="poly" title=" " alt="" coords="244,52,293,91,289,95,241,56"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad416befeb8d31565ea5bfdeef66fa104"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad416befeb8d31565ea5bfdeef66fa104">OctreeNodeInterface</a> (const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax, <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *parent, const int unsigned treeSplitThreshold, const double interactionLength, const double cellSizeFactor)</td></tr>
<tr class="memdesc:ad416befeb8d31565ea5bfdeef66fa104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an octree node interface by initializing the given fields.  <br /></td></tr>
<tr class="separator:ad416befeb8d31565ea5bfdeef66fa104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d4bc0efaad30b855b2ab43672d843b"><td class="memItemLeft" align="right" valign="top"><a id="a66d4bc0efaad30b855b2ab43672d843b" name="a66d4bc0efaad30b855b2ab43672d843b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~OctreeNodeInterface</b> ()=default</td></tr>
<tr class="memdesc:a66d4bc0efaad30b855b2ab43672d843b"><td class="mdescLeft">&#160;</td><td class="mdescRight">To make clang happy. <br /></td></tr>
<tr class="separator:a66d4bc0efaad30b855b2ab43672d843b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24265c31be2340ab1f62a0a653be0f88"><td class="memItemLeft" align="right" valign="top"><a id="a24265c31be2340ab1f62a0a653be0f88" name="a24265c31be2340ab1f62a0a653be0f88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OctreeNodeInterface</b> (const <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &amp;)=default</td></tr>
<tr class="memdesc:a24265c31be2340ab1f62a0a653be0f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor. <br /></td></tr>
<tr class="separator:a24265c31be2340ab1f62a0a653be0f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d236108b1d67a05e03eb0ca49a7422"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab5d236108b1d67a05e03eb0ca49a7422">insert</a> (const Particle_T &amp;p)=0</td></tr>
<tr class="memdesc:ab5d236108b1d67a05e03eb0ca49a7422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a particle into the octree.  <br /></td></tr>
<tr class="separator:ab5d236108b1d67a05e03eb0ca49a7422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25687dec42fc04d53c8ad6416290eb6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad25687dec42fc04d53c8ad6416290eb6">deleteParticle</a> (Particle_T &amp;particle)=0</td></tr>
<tr class="memdesc:ad25687dec42fc04d53c8ad6416290eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given particle from the data structure.    <br /></td></tr>
<tr class="separator:ad25687dec42fc04d53c8ad6416290eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ead81def7160fc03a73c447bf7e53"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a6c6ead81def7160fc03a73c447bf7e53">collectAllParticles</a> (std::vector&lt; Particle_T * &gt; &amp;ps) const =0</td></tr>
<tr class="memdesc:a6c6ead81def7160fc03a73c447bf7e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all particles that are below this node into the vector.  <br /></td></tr>
<tr class="separator:a6c6ead81def7160fc03a73c447bf7e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb6398c228be2a285ce1f86c02a8d25"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7fb6398c228be2a285ce1f86c02a8d25">appendAllLeafBoxes</a> (std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, std::array&lt; double, 3 &gt; &gt; &gt; &amp;boxes) const =0</td></tr>
<tr class="memdesc:a7fb6398c228be2a285ce1f86c02a8d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the min/max corner coordinates of every leaf into the vector.  <br /></td></tr>
<tr class="separator:a7fb6398c228be2a285ce1f86c02a8d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a10fa85f01ff57a9a06c57de607d59b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a2a10fa85f01ff57a9a06c57de607d59b">appendAllLeaves</a> (std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;leaves) const =0</td></tr>
<tr class="memdesc:a2a10fa85f01ff57a9a06c57de607d59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all leaves below this subtree into a given list.  <br /></td></tr>
<tr class="separator:a2a10fa85f01ff57a9a06c57de607d59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ab6f178fce0a5742d1881021dac4e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab2ab6f178fce0a5742d1881021dac4e3">clearChildren</a> (std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; &amp;ref)=0</td></tr>
<tr class="memdesc:ab2ab6f178fce0a5742d1881021dac4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the entire tree below this node.  <br /></td></tr>
<tr class="separator:ab2ab6f178fce0a5742d1881021dac4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6e61aed5fb70cbd069e8f172dc9291"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7e6e61aed5fb70cbd069e8f172dc9291">size</a> () const =0</td></tr>
<tr class="memdesc:a7e6e61aed5fb70cbd069e8f172dc9291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of particles saved in the container (owned + halo + dummy).    <br /></td></tr>
<tr class="separator:a7e6e61aed5fb70cbd069e8f172dc9291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31651019cd7e284b620411f1e023a3b"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ac31651019cd7e284b620411f1e023a3b">getNumberOfParticles</a> (IteratorBehavior behavior=IteratorBehavior::owned) const =0</td></tr>
<tr class="memdesc:ac31651019cd7e284b620411f1e023a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.      <br /></td></tr>
<tr class="separator:ac31651019cd7e284b620411f1e023a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df399ebdc0b38620a35af63bcf13271"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a4df399ebdc0b38620a35af63bcf13271">SON</a> (<a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Octant</a> O)=0</td></tr>
<tr class="memdesc:a4df399ebdc0b38620a35af63bcf13271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child node of this node (if there are children) given a specific octant using the spacial structure of the stored children.  <br /></td></tr>
<tr class="separator:a4df399ebdc0b38620a35af63bcf13271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a1188bc4e80325b23040b921e2aaf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#add2a1188bc4e80325b23040b921e2aaf">hasChildren</a> ()=0</td></tr>
<tr class="memdesc:add2a1188bc4e80325b23040b921e2aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node is a leaf or an inner node.  <br /></td></tr>
<tr class="separator:add2a1188bc4e80325b23040b921e2aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a83ac4270e177bc03215e0378064aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a42a83ac4270e177bc03215e0378064aa">getChild</a> (int index)=0</td></tr>
<tr class="memdesc:a42a83ac4270e177bc03215e0378064aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child by its index from the node.  <br /></td></tr>
<tr class="separator:a42a83ac4270e177bc03215e0378064aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120821d0ce7268603cafb9f720526b85"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a120821d0ce7268603cafb9f720526b85">getLeavesInRange</a> (const std::array&lt; double, 3 &gt; &amp;min, const std::array&lt; double, 3 &gt; &amp;max)=0</td></tr>
<tr class="memdesc:a120821d0ce7268603cafb9f720526b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaves below this subtree that are in the given range.  <br /></td></tr>
<tr class="separator:a120821d0ce7268603cafb9f720526b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49a028da76d8b6d201593c618414563"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ae49a028da76d8b6d201593c618414563">isInside</a> (const std::array&lt; double, 3 &gt; &amp;point)</td></tr>
<tr class="memdesc:ae49a028da76d8b6d201593c618414563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a 3d point is inside the node's axis aligned bounding box.  <br /></td></tr>
<tr class="separator:ae49a028da76d8b6d201593c618414563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c63883d72a6c02c4c104bda68bbff2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a07c63883d72a6c02c4c104bda68bbff2">enclosesVolumeWithOtherOnAxis</a> (const int axis, const <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *other)</td></tr>
<tr class="memdesc:a07c63883d72a6c02c4c104bda68bbff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an octree node's box encloses volume with another octree node's box on a specific axis.  <br /></td></tr>
<tr class="separator:a07c63883d72a6c02c4c104bda68bbff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89bb30dbb1b22ab41f94f87d01ba145"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ac89bb30dbb1b22ab41f94f87d01ba145">overlapsBox</a> (const std::array&lt; double, 3 &gt; &amp;otherMin, const std::array&lt; double, 3 &gt; &amp;otherMax)</td></tr>
<tr class="memdesc:ac89bb30dbb1b22ab41f94f87d01ba145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node's axis aligned bounding box overlaps with the given axis aligned bounding box.  <br /></td></tr>
<tr class="separator:ac89bb30dbb1b22ab41f94f87d01ba145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b732ab55963e9575b3dc07f67e5e9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#acf5b732ab55963e9575b3dc07f67e5e9">getEnclosedVolumeWith</a> (const std::array&lt; double, 3 &gt; &amp;otherMin, const std::array&lt; double, 3 &gt; &amp;otherMax)</td></tr>
<tr class="memdesc:acf5b732ab55963e9575b3dc07f67e5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the overlap volume between the node's axis aligned bounding box and the given box.  <br /></td></tr>
<tr class="separator:acf5b732ab55963e9575b3dc07f67e5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5ebf043fb5de4cfdd13593ec13c450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#aed5ebf043fb5de4cfdd13593ec13c450">EQ_FACE_NEIGHBOR</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a818a2d31517a95d918fa800aec9cd9db">octree::Face</a> I)</td></tr>
<tr class="memdesc:aed5ebf043fb5de4cfdd13593ec13c450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:aed5ebf043fb5de4cfdd13593ec13c450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fd47e1959b389889268556bd3c562c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a08fd47e1959b389889268556bd3c562c">EQ_EDGE_NEIGHBOR</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a652aa1ac1df1cb0b731ef71fb4962c13">octree::Edge</a> I)</td></tr>
<tr class="memdesc:a08fd47e1959b389889268556bd3c562c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:a08fd47e1959b389889268556bd3c562c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64300d0c48ead9478bd8b77482a906e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a64300d0c48ead9478bd8b77482a906e4">EQ_VERTEX_NEIGHBOR</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> I)</td></tr>
<tr class="memdesc:a64300d0c48ead9478bd8b77482a906e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:a64300d0c48ead9478bd8b77482a906e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebfbc310d152aa2d67a917db3c3c8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#aaebfbc310d152aa2d67a917db3c3c8a1">GTEQ_FACE_NEIGHBOR</a> (<a class="el" href="namespaceautopas_1_1octree.html#a818a2d31517a95d918fa800aec9cd9db">octree::Face</a> I)</td></tr>
<tr class="memdesc:aaebfbc310d152aa2d67a917db3c3c8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:aaebfbc310d152aa2d67a917db3c3c8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5573639d1edd41e219a137db2c93bf6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a5573639d1edd41e219a137db2c93bf6d">GTEQ_EDGE_NEIGHBOR</a> (<a class="el" href="namespaceautopas_1_1octree.html#a652aa1ac1df1cb0b731ef71fb4962c13">octree::Edge</a> I)</td></tr>
<tr class="memdesc:a5573639d1edd41e219a137db2c93bf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:a5573639d1edd41e219a137db2c93bf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb1c48eeb21bd6c9fa5146738a1ab1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#afdb1c48eeb21bd6c9fa5146738a1ab1d">GTEQ_VERTEX_NEIGHBOR</a> (<a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> I)</td></tr>
<tr class="memdesc:afdb1c48eeb21bd6c9fa5146738a1ab1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:afdb1c48eeb21bd6c9fa5146738a1ab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd593f1ba72c28f5fdeca506a5246c8"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a0cd593f1ba72c28f5fdeca506a5246c8">getLeavesFromDirections</a> (const std::vector&lt; <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> &gt; &amp;directions)=0</td></tr>
<tr class="memdesc:a0cd593f1ba72c28f5fdeca506a5246c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaf nodes along a list of given directions.  <br /></td></tr>
<tr class="separator:a0cd593f1ba72c28f5fdeca506a5246c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf66b7e2aebf1bc8e07456550955f8a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#aadf66b7e2aebf1bc8e07456550955f8a">getNeighborLeaves</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a247c6f197293ce9a2b453bc01f7a40cb">octree::Any</a> direction)</td></tr>
<tr class="memdesc:aadf66b7e2aebf1bc8e07456550955f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function combines all required functions when traversing down a subtree of the octree and finding all leaves.  <br /></td></tr>
<tr class="separator:aadf66b7e2aebf1bc8e07456550955f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a7fd43486192546e50b5541a9cc3eb"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a61a7fd43486192546e50b5541a9cc3eb">getNeighborLeaves</a> ()</td></tr>
<tr class="memdesc:a61a7fd43486192546e50b5541a9cc3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the neighbor leaves in all directions.  <br /></td></tr>
<tr class="separator:a61a7fd43486192546e50b5541a9cc3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481b0e8598dd0a88c27ae9196764e387"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a481b0e8598dd0a88c27ae9196764e387">getBoxMin</a> () const</td></tr>
<tr class="memdesc:a481b0e8598dd0a88c27ae9196764e387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum coordinate of the enclosing box.  <br /></td></tr>
<tr class="separator:a481b0e8598dd0a88c27ae9196764e387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20088a8ceb4e7cb71a5450075473240c"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a20088a8ceb4e7cb71a5450075473240c">getBoxMax</a> () const</td></tr>
<tr class="memdesc:a20088a8ceb4e7cb71a5450075473240c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum coordinate of the enclosing box.  <br /></td></tr>
<tr class="separator:a20088a8ceb4e7cb71a5450075473240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72617b706afd5a1884400a7b5b0da7ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a72617b706afd5a1884400a7b5b0da7ef">getParent</a> () const</td></tr>
<tr class="memdesc:a72617b706afd5a1884400a7b5b0da7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent node of this node.  <br /></td></tr>
<tr class="separator:a72617b706afd5a1884400a7b5b0da7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad0c1d04c45912df3fdd297f3af8dbed5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad0c1d04c45912df3fdd297f3af8dbed5">volumeExistsOnAxis</a> (const int axis, const std::array&lt; double, 3 &gt; &amp;aMin, const std::array&lt; double, 3 &gt; &amp;aMax, const std::array&lt; double, 3 &gt; &amp;bMin, const std::array&lt; double, 3 &gt; &amp;bMax)</td></tr>
<tr class="memdesc:ad0c1d04c45912df3fdd297f3af8dbed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the volume enclosed by two boxes a and b is nonzero on a specific axis.  <br /></td></tr>
<tr class="separator:ad0c1d04c45912df3fdd297f3af8dbed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aefc0e5edf8144556465f58419e579"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a04aefc0e5edf8144556465f58419e579">getEnclosedVolumeWith</a> (const std::array&lt; double, 3 &gt; &amp;aMin, const std::array&lt; double, 3 &gt; &amp;aMax, const std::array&lt; double, 3 &gt; &amp;bMin, const std::array&lt; double, 3 &gt; &amp;bMax)</td></tr>
<tr class="memdesc:a04aefc0e5edf8144556465f58419e579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enclosed volume between two boxes a and b.  <br /></td></tr>
<tr class="separator:a04aefc0e5edf8144556465f58419e579"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a79ddbbda5873b854d2f743873ea371fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a79ddbbda5873b854d2f743873ea371fd">hasParent</a> ()</td></tr>
<tr class="memdesc:a79ddbbda5873b854d2f743873ea371fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this is not the root node.  <br /></td></tr>
<tr class="separator:a79ddbbda5873b854d2f743873ea371fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7f7309cc7f3b730c5513ae81f43a716a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7f7309cc7f3b730c5513ae81f43a716a">_parent</a></td></tr>
<tr class="memdesc:a7f7309cc7f3b730c5513ae81f43a716a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the parent node.  <br /></td></tr>
<tr class="separator:a7f7309cc7f3b730c5513ae81f43a716a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5287a3f6fbd9e0e28ab813cd4086e8"><td class="memItemLeft" align="right" valign="top"><a id="a0f5287a3f6fbd9e0e28ab813cd4086e8" name="a0f5287a3f6fbd9e0e28ab813cd4086e8"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_boxMin</b></td></tr>
<tr class="memdesc:a0f5287a3f6fbd9e0e28ab813cd4086e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The min coordinate of the enclosed volume. <br /></td></tr>
<tr class="separator:a0f5287a3f6fbd9e0e28ab813cd4086e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4809bbd85e6cb2ee83603f92e22c3178"><td class="memItemLeft" align="right" valign="top"><a id="a4809bbd85e6cb2ee83603f92e22c3178" name="a4809bbd85e6cb2ee83603f92e22c3178"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_boxMax</b></td></tr>
<tr class="memdesc:a4809bbd85e6cb2ee83603f92e22c3178"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max coordinate of the enclosed volume. <br /></td></tr>
<tr class="separator:a4809bbd85e6cb2ee83603f92e22c3178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc048ebbdf29cdf3e9218fc44e9e843"><td class="memItemLeft" align="right" valign="top"><a id="a6cc048ebbdf29cdf3e9218fc44e9e843" name="a6cc048ebbdf29cdf3e9218fc44e9e843"></a>
int unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>_treeSplitThreshold</b></td></tr>
<tr class="memdesc:a6cc048ebbdf29cdf3e9218fc44e9e843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of particles inside a leaf node before the leaf tries to split itself. <br /></td></tr>
<tr class="separator:a6cc048ebbdf29cdf3e9218fc44e9e843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63368dc6c9bedc926a3a8f4d2266ddc0"><td class="memItemLeft" align="right" valign="top"><a id="a63368dc6c9bedc926a3a8f4d2266ddc0" name="a63368dc6c9bedc926a3a8f4d2266ddc0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_interactionLength</b></td></tr>
<tr class="memdesc:a63368dc6c9bedc926a3a8f4d2266ddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum distance at which a force is considered nonzero, cutoff+skin. <br /></td></tr>
<tr class="separator:a63368dc6c9bedc926a3a8f4d2266ddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced807582ba52e048c9620b0b56d5971"><td class="memItemLeft" align="right" valign="top"><a id="aced807582ba52e048c9620b0b56d5971" name="aced807582ba52e048c9620b0b56d5971"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_cellSizeFactor</b></td></tr>
<tr class="memdesc:aced807582ba52e048c9620b0b56d5971"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cell size factor for this node. <br /></td></tr>
<tr class="separator:aced807582ba52e048c9620b0b56d5971"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Particle_T&gt;<br />
class autopas::OctreeNodeInterface&lt; Particle_T &gt;</div><p>The base class that provides the necessary function definitions that can be applied to an octree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle_T</td><td></td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad416befeb8d31565ea5bfdeef66fa104" name="ad416befeb8d31565ea5bfdeef66fa104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad416befeb8d31565ea5bfdeef66fa104">&#9670;&#160;</a></span>OctreeNodeInterface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::OctreeNodeInterface </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int unsigned&#160;</td>
          <td class="paramname"><em>treeSplitThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>interactionLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cellSizeFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an octree node interface by initializing the given fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>The minimum coordinate of the enclosing box </td></tr>
    <tr><td class="paramname">boxMax</td><td>The maximum coordinate of the enclosing box </td></tr>
    <tr><td class="paramname">parent</td><td>A pointer to the parent of this node, may be nullptr for the root. </td></tr>
    <tr><td class="paramname">treeSplitThreshold</td><td>Maximum number of particles inside a leaf before it tries to split itself </td></tr>
    <tr><td class="paramname">interactionLength</td><td>The minimum distance at which a force is considered nonzero, cutoff+skin. </td></tr>
    <tr><td class="paramname">cellSizeFactor</td><td>The cell size factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7fb6398c228be2a285ce1f86c02a8d25" name="a7fb6398c228be2a285ce1f86c02a8d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb6398c228be2a285ce1f86c02a8d25">&#9670;&#160;</a></span>appendAllLeafBoxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::appendAllLeafBoxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, std::array&lt; double, 3 &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the min/max corner coordinates of every leaf into the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>A reference to the vector that should contain pairs of the min/max corner coordinates </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#acd8c43ef98d4346ff98af3e1fdacbe4f">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#a37b378fdfd9d69219620e1015ba2d09e">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a2a10fa85f01ff57a9a06c57de607d59b" name="a2a10fa85f01ff57a9a06c57de607d59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a10fa85f01ff57a9a06c57de607d59b">&#9670;&#160;</a></span>appendAllLeaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::appendAllLeaves </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put all leaves below this subtree into a given list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaves</td><td>A reference to the vector that should contain pointers to the leaves </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#a2fb2ef9c5016796e89c834c26fde33d0">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#a6b3f6b89d2601604466f72a4da9c4907">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ab2ab6f178fce0a5742d1881021dac4e3" name="ab2ab6f178fce0a5742d1881021dac4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ab6f178fce0a5742d1881021dac4e3">&#9670;&#160;</a></span>clearChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::clearChildren </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the entire tree below this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>A reference that contains this node </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#a145682a8d9edb467f85fdf92fb48ab0b">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#a907d0336f707f4a26faccf7ecdf80cea">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a6c6ead81def7160fc03a73c447bf7e53" name="a6c6ead81def7160fc03a73c447bf7e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6ead81def7160fc03a73c447bf7e53">&#9670;&#160;</a></span>collectAllParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::collectAllParticles </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Particle_T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put all particles that are below this node into the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>A reference to the vector that should contain the particles after the operation </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#aae157da9c142908f38643fbde87b10fc">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#a12e5cb3d11dacf950d8680cc4901ae6f">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ad25687dec42fc04d53c8ad6416290eb6" name="ad25687dec42fc04d53c8ad6416290eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25687dec42fc04d53c8ad6416290eb6">&#9670;&#160;</a></span>deleteParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype">Particle_T &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the given particle from the data structure.   </p>
<p>This function does not change the tree layout if the node is empty after the operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given pointer still points to a new, valid particle.   </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#a24782ba53caf637805a666a3b088fadc">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#a250826c09fbb03f4137faad70f0bb130">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a07c63883d72a6c02c4c104bda68bbff2" name="a07c63883d72a6c02c4c104bda68bbff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c63883d72a6c02c4c104bda68bbff2">&#9670;&#160;</a></span>enclosesVolumeWithOtherOnAxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::enclosesVolumeWithOtherOnAxis </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an octree node's box encloses volume with another octree node's box on a specific axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>An axis index (0, 1 or 2) </td></tr>
    <tr><td class="paramname">other</td><td>The octree node to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the enclosed volume is greater than zero, false if the enclosed volume is equal to zero. </dd></dl>

</div>
</div>
<a id="a08fd47e1959b389889268556bd3c562c" name="a08fd47e1959b389889268556bd3c562c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fd47e1959b389889268556bd3c562c">&#9670;&#160;</a></span>EQ_EDGE_NEIGHBOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::EQ_EDGE_NEIGHBOR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceautopas_1_1octree.html#a652aa1ac1df1cb0b731ef71fb4962c13">octree::Edge</a>&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper. </p>
<p>This function searches along an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>The edge in which direction the search should find a node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An octree node </dd></dl>

</div>
</div>
<a id="aed5ebf043fb5de4cfdd13593ec13c450" name="aed5ebf043fb5de4cfdd13593ec13c450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5ebf043fb5de4cfdd13593ec13c450">&#9670;&#160;</a></span>EQ_FACE_NEIGHBOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::EQ_FACE_NEIGHBOR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceautopas_1_1octree.html#a818a2d31517a95d918fa800aec9cd9db">octree::Face</a>&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper. </p>
<p>This function searches along a face. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>The face in which direction the search should find a node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An octree node </dd></dl>

</div>
</div>
<a id="a64300d0c48ead9478bd8b77482a906e4" name="a64300d0c48ead9478bd8b77482a906e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64300d0c48ead9478bd8b77482a906e4">&#9670;&#160;</a></span>EQ_VERTEX_NEIGHBOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::EQ_VERTEX_NEIGHBOR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a>&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper. </p>
<p>This function searches along a vertex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>The face in which direction the search should find a node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An octree node </dd></dl>

</div>
</div>
<a id="a20088a8ceb4e7cb71a5450075473240c" name="a20088a8ceb4e7cb71a5450075473240c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20088a8ceb4e7cb71a5450075473240c">&#9670;&#160;</a></span>getBoxMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getBoxMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum coordinate of the enclosing box. </p>
<dl class="section return"><dt>Returns</dt><dd>A point in 3D space </dd></dl>

</div>
</div>
<a id="a481b0e8598dd0a88c27ae9196764e387" name="a481b0e8598dd0a88c27ae9196764e387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481b0e8598dd0a88c27ae9196764e387">&#9670;&#160;</a></span>getBoxMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; double, 3 &gt; &amp; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getBoxMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum coordinate of the enclosing box. </p>
<dl class="section return"><dt>Returns</dt><dd>A point in 3D space </dd></dl>

</div>
</div>
<a id="a42a83ac4270e177bc03215e0378064aa" name="a42a83ac4270e177bc03215e0378064aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a83ac4270e177bc03215e0378064aa">&#9670;&#160;</a></span>getChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a child by its index from the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the child. Must be between 0 and 7 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the child. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#ac8f439ed1cf936832710072819f5df3b">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#ad6be9392373429add9ea47a43e09e739">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a04aefc0e5edf8144556465f58419e579" name="a04aefc0e5edf8144556465f58419e579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aefc0e5edf8144556465f58419e579">&#9670;&#160;</a></span>getEnclosedVolumeWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getEnclosedVolumeWith </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the enclosed volume between two boxes a and b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aMin</td><td>The minimum coordinate of box a </td></tr>
    <tr><td class="paramname">aMax</td><td>The maximum coordinate of box b </td></tr>
    <tr><td class="paramname">bMin</td><td>The minimum coordinate of box a </td></tr>
    <tr><td class="paramname">bMax</td><td>The maximum coordinate of box b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enclosed volume or zero if the boxes do not overlap </dd></dl>

</div>
</div>
<a id="acf5b732ab55963e9575b3dc07f67e5e9" name="acf5b732ab55963e9575b3dc07f67e5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5b732ab55963e9575b3dc07f67e5e9">&#9670;&#160;</a></span>getEnclosedVolumeWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getEnclosedVolumeWith </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the overlap volume between the node's axis aligned bounding box and the given box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherMin</td><td>The minimum coordinate of the other box </td></tr>
    <tr><td class="paramname">otherMax</td><td>The maximum coordinate of the other box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The volume enclosed by the two boxes </dd></dl>

</div>
</div>
<a id="a0cd593f1ba72c28f5fdeca506a5246c8" name="a0cd593f1ba72c28f5fdeca506a5246c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd593f1ba72c28f5fdeca506a5246c8">&#9670;&#160;</a></span>getLeavesFromDirections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getLeavesFromDirections </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all leaf nodes along a list of given directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directions</td><td>A list of allowed directions for traversal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of leaf nodes </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#a9bda3fc926760b467bc214ea158304a3">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#a8e8b6459d0bfa515afb599900092e516">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a120821d0ce7268603cafb9f720526b85" name="a120821d0ce7268603cafb9f720526b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120821d0ce7268603cafb9f720526b85">&#9670;&#160;</a></span>getLeavesInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getLeavesInRange </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all leaves below this subtree that are in the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum coordinate in 3D space of the query area </td></tr>
    <tr><td class="paramname">max</td><td>The maximum coordinate in 3D space of the query area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of all leaf nodes that are in the query region </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#a85b4f7ec4ed85618130ff54f519b9964">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#a8a662b71d40e7c3897e588a3ea193450">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a61a7fd43486192546e50b5541a9cc3eb" name="a61a7fd43486192546e50b5541a9cc3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a7fd43486192546e50b5541a9cc3eb">&#9670;&#160;</a></span>getNeighborLeaves() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getNeighborLeaves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the neighbor leaves in all directions. </p>
<dl class="section return"><dt>Returns</dt><dd>A set of (unique) neighboring leaves </dd></dl>

</div>
</div>
<a id="aadf66b7e2aebf1bc8e07456550955f8a" name="aadf66b7e2aebf1bc8e07456550955f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf66b7e2aebf1bc8e07456550955f8a">&#9670;&#160;</a></span>getNeighborLeaves() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getNeighborLeaves </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceautopas_1_1octree.html#a247c6f197293ce9a2b453bc01f7a40cb">octree::Any</a>&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function combines all required functions when traversing down a subtree of the octree and finding all leaves. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The "original" direction. The leaves will be found along the opposite direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of leaf nodes </dd></dl>

</div>
</div>
<a id="ac31651019cd7e284b620411f1e023a3b" name="ac31651019cd7e284b620411f1e023a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31651019cd7e284b620411f1e023a3b">&#9670;&#160;</a></span>getNumberOfParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getNumberOfParticles </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em> = <code>IteratorBehavior::owned</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of particles with respect to the specified IteratorBehavior.     </p>
<dl class="section warning"><dt>Warning</dt><dd>: Since this function counts the number of the respective particles in the internal particle storage, this is in O(n) + lock is required. Only use it when it is absolutely necessary to have the exact number of different particle types like owned or halo. If it is enough to have the whole number of particles (owned + halo + dummy), the function <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7e6e61aed5fb70cbd069e8f172dc9291" title="Get the total number of particles saved in the container (owned + halo + dummy).">size()</a> can be used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of particles with respect to the specified IteratorBehavior.     </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#a1bc49e4e083d0aefea83062b1e9053de">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#a0809fb178527cb2b55ce01a58b530c3c">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a72617b706afd5a1884400a7b5b0da7ef" name="a72617b706afd5a1884400a7b5b0da7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72617b706afd5a1884400a7b5b0da7ef">&#9670;&#160;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the parent node of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parent, can be nullptr. </dd></dl>

</div>
</div>
<a id="a5573639d1edd41e219a137db2c93bf6d" name="a5573639d1edd41e219a137db2c93bf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5573639d1edd41e219a137db2c93bf6d">&#9670;&#160;</a></span>GTEQ_EDGE_NEIGHBOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::GTEQ_EDGE_NEIGHBOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceautopas_1_1octree.html#a652aa1ac1df1cb0b731ef71fb4962c13">octree::Edge</a>&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper. </p>
<p>This function searches along an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>The edge in which direction the search should find a node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An octree node </dd></dl>

</div>
</div>
<a id="aaebfbc310d152aa2d67a917db3c3c8a1" name="aaebfbc310d152aa2d67a917db3c3c8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebfbc310d152aa2d67a917db3c3c8a1">&#9670;&#160;</a></span>GTEQ_FACE_NEIGHBOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::GTEQ_FACE_NEIGHBOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceautopas_1_1octree.html#a818a2d31517a95d918fa800aec9cd9db">octree::Face</a>&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper. </p>
<p>This function searches along a face. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>The face in which direction the search should find a node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An octree node </dd></dl>

</div>
</div>
<a id="afdb1c48eeb21bd6c9fa5146738a1ab1d" name="afdb1c48eeb21bd6c9fa5146738a1ab1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb1c48eeb21bd6c9fa5146738a1ab1d">&#9670;&#160;</a></span>GTEQ_VERTEX_NEIGHBOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::GTEQ_VERTEX_NEIGHBOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a>&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper. </p>
<p>This function searches along a vertex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I</td><td>The vertex in which direction the search should find a node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An octree node </dd></dl>

</div>
</div>
<a id="add2a1188bc4e80325b23040b921e2aaf" name="add2a1188bc4e80325b23040b921e2aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2a1188bc4e80325b23040b921e2aaf">&#9670;&#160;</a></span>hasChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::hasChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the node is a leaf or an inner node. </p>
<p>Use this over dynamic_cast to distinguish node types. It is 20-50 times faster! <a href="https://stackoverflow.com/a/49296405/7019073">https://stackoverflow.com/a/49296405/7019073</a> </p><dl class="section return"><dt>Returns</dt><dd>true iff the node is a leaf, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#a5d42bc916a949ee8a5d9349ecdfcaa18">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#acae0bac3a0c10b9986be818a06e9fc80">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a79ddbbda5873b854d2f743873ea371fd" name="a79ddbbda5873b854d2f743873ea371fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ddbbda5873b854d2f743873ea371fd">&#9670;&#160;</a></span>hasParent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::hasParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this is not the root node. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff there does not exist a parent for this node. </dd></dl>

</div>
</div>
<a id="ab5d236108b1d67a05e03eb0ca49a7422" name="ab5d236108b1d67a05e03eb0ca49a7422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d236108b1d67a05e03eb0ca49a7422">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a particle into the octree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The particle to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::unique_ptr to a newly created subtree or nullptr if the subtree did not change </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#aea6478eca9b3b2e070d3312a91824e61">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#a7e1a1067a22964be7bf9710a8498b14f">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ae49a028da76d8b6d201593c618414563" name="ae49a028da76d8b6d201593c618414563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49a028da76d8b6d201593c618414563">&#9670;&#160;</a></span>isInside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::isInside </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a 3d point is inside the node's axis aligned bounding box. </p>
<p>(Set by the boxMin and boxMax fields.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The node to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the point is inside the node's bounding box and false otherwise </dd></dl>

</div>
</div>
<a id="ac89bb30dbb1b22ab41f94f87d01ba145" name="ac89bb30dbb1b22ab41f94f87d01ba145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89bb30dbb1b22ab41f94f87d01ba145">&#9670;&#160;</a></span>overlapsBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::overlapsBox </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the node's axis aligned bounding box overlaps with the given axis aligned bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherMin</td><td>The minimum coordinate of the other box </td></tr>
    <tr><td class="paramname">otherMax</td><td>The maximum coordinate of the other box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the overlapping volume is non-negative </dd></dl>

</div>
</div>
<a id="a7e6e61aed5fb70cbd069e8f172dc9291" name="a7e6e61aed5fb70cbd069e8f172dc9291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6e61aed5fb70cbd069e8f172dc9291">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of particles saved in the container (owned + halo + dummy).   </p>
<dl class="section return"><dt>Returns</dt><dd>Number of particles saved in the container (owned + halo + dummy).   </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeInnerNode.html#abb258a35d550c78984ba4f2cde6d8ab9">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeLeafNode.html#aadd487f39aaf1747d75a4366dbd931b3">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a4df399ebdc0b38620a35af63bcf13271" name="a4df399ebdc0b38620a35af63bcf13271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df399ebdc0b38620a35af63bcf13271">&#9670;&#160;</a></span>SON()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::SON </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Octant</a>&#160;</td>
          <td class="paramname"><em>O</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a child node of this node (if there are children) given a specific octant using the spacial structure of the stored children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>The octant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a child node </dd></dl>

<p>Implemented in <a class="el" href="classautopas_1_1OctreeLeafNode.html#a6bab1e9bf95d8ff66cbcf4cef4d0c451">autopas::OctreeLeafNode&lt; Particle_T &gt;</a>, and <a class="el" href="classautopas_1_1OctreeInnerNode.html#a33f9293b645335024a43c1b97c5556b0">autopas::OctreeInnerNode&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="ad0c1d04c45912df3fdd297f3af8dbed5" name="ad0c1d04c45912df3fdd297f3af8dbed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c1d04c45912df3fdd297f3af8dbed5">&#9670;&#160;</a></span>volumeExistsOnAxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::volumeExistsOnAxis </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the volume enclosed by two boxes a and b is nonzero on a specific axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>An axis index (0, 1 or 2) </td></tr>
    <tr><td class="paramname">aMin</td><td>The minimum coordinate of a's volume </td></tr>
    <tr><td class="paramname">aMax</td><td>The maximum coordinate of a's volume </td></tr>
    <tr><td class="paramname">bMin</td><td>The minimum coordinate of b's volume </td></tr>
    <tr><td class="paramname">bMax</td><td>The maximum coordinate of b's volume </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the enclosed volume is greater than zero, false if the enclosed volume is equal to zero. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7f7309cc7f3b730c5513ae81f43a716a" name="a7f7309cc7f3b730c5513ae81f43a716a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7309cc7f3b730c5513ae81f43a716a">&#9670;&#160;</a></span>_parent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt;Particle_T&gt;* <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface</a>&lt; Particle_T &gt;::_parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the parent node. </p>
<p>Can be nullptr (iff this is the root node). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autopas/containers/octree/<a class="el" href="OctreeNodeInterface_8h_source.html">OctreeNodeInterface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

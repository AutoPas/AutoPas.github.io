<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Iterating Through Particles </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md27"></a> Since particles could be stored in many different ways within AutoPas, it is generally not feasible to provide random access to individual particles. To access particles, iterators are used. AutoPas provides three interfaces to do this:</p><ol type="1">
<li>Classic iterators These <code>ContainerIterator</code>s are useable in loops where they provide a maximum of flexibility over the loop flow control. They support restriction to certain particle types and regions, as well as parallelization and particle deletion but not addition.</li>
<li><code>forEach</code>-style functions (Experimental, no parallelization yet!). Similar to iterators, but prohibit interfering with flow control.</li>
<li>Functor application functions like <code>AutoPas::iteratePairwise()</code>. Applies the given functor to all particle pairs that are within the cutoff distance.</li>
</ol>
<p>This documentation page shall primarily focus on the first and slightly touch upon the second point. For the third, refer to <a href="https://github.com/AutoPas/AutoPas/blob/master/docs/userdoc/SimulationLoop.md"><code>SimulationLoop.md</code></a> for more details.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Container Iterators</h1>
<h2><a class="anchor" id="autotoc_md29"></a>
Range-Based For Loops</h2>
<p>The easiest way to iterate over all (= owned and halo) particles of an AutoPas instance is with a <a href="https://en.cppreference.com/w/cpp/language/range-for">range-based for loop</a>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; particle : autoPas) {</div>
<div class="line">  <span class="comment">// user code:</span></div>
<div class="line">  <span class="keyword">auto</span> position = particle.getR();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
Manual Iterating</h2>
<p>If more fine-grained control is needed over the iteration sequence, the iterator can be accessed and advanced manually:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> iter = autoPas.begin(); iter != autoPas.end(); ++iter) {</div>
<div class="line">  <span class="comment">// user code:</span></div>
<div class="line">  <span class="keyword">auto</span> position = iter-&gt;getR();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Analogously to <code>begin()</code>, <code>cbegin()</code> is also defined, which guarantees to return a <code>const</code> iterator.</p>
<p>Some further information to be aware of:</p><ul>
<li>The iterator can only go forward. Its design doesn't necessarily prohibit reverse iteration, but it is (currently) not implemented.</li>
<li>Adding particles during iteration is considered undefined behavior. See <a href="https://github.com/AutoPas/AutoPas/issues/766">Issue #766</a> for details</li>
<li>There is no guarantee on the order of iteration. If the internal data structure is updated or changed, the iteration order can change as well.</li>
<li>Alternatively to <code>iter != autoPas.end()</code>, we can also use <code>iter.isValid()</code>. This is equivalent, because <code>AutoPas::end()</code> returns a <code>bool</code> and <code>ContainerIterator::operator==(bool)</code> calls <code>ContainerIterator::isValid()</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md31"></a>
Particle Deletion</h3>
<p>AutoPas supports the deletion of particles while iterating without invalidating the iterator. However, this needs to be done through the member function <code>AutoPas::deleteParticle()</code>. This function also leaves the iterator in a state so that <code>ContainerIterator::operator++()</code> needs to be called.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> iter = autoPas.begin(); iter != autoPas.end(); ++iter) {</div>
<div class="line">  autoPas.deleteParticle(iterator);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
Restricting Particle Types</h2>
<p>Iterators can be restricted to only return particles of a given ownership type. The default is to cover owned and halo particles. See <a href="https://github.com/AutoPas/AutoPas/blob/master/docs/userdoc/ParticleOwnershipModel.md">ParticleOwnershipModel.md</a> for particle ownership types.</p>
<div class="fragment"><div class="line"><span class="comment">// only iterate owned particles</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> iter = autoPas.begin(autopas::IteratorBehavior::owned);</div>
<div class="line">    iter != autoPas.end();</div>
<div class="line">    ++iter) {</div>
<div class="line">  <span class="comment">// user code</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Depending on the container, this might be more efficient than iterating everything and calling <code>continue</code> on undesired ownership types.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Region Iterators</h2>
<p>Iterators can be restricted to only return particles inside of a given region. Regions are always cuboids defined by their left-lower-frontal and right-upper-back corner.</p>
<div class="fragment"><div class="line"><span class="comment">// only iterate particles in a given box</span></div>
<div class="line"><span class="keyword">const</span> std::array&lt;double, 3&gt; lowCorner = ...;</div>
<div class="line"><span class="keyword">const</span> std::array&lt;double, 3&gt; highCorner = ...;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> iter = autoPas.getRegionIterator(lowCorner, highCorner);</div>
<div class="line">    iter != autoPas.end();</div>
<div class="line">    ++iter) {</div>
<div class="line">  <span class="comment">// user code</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Region Iterators also take an <code>IteratorBehavior</code> as an optional third argument.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Parallelization</h2>
<p>Iteration of the AutoPas object can also be done in parallel via OpenMP. For this, place any of the examples above in a parallel region.</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="WrapOpenMP_8h.html#adf64fc4981617d456044d0a30deb3d0d">AUTOPAS_OPENMP</a>(parallel)</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; particle : autoPas) {</div>
<div class="line">  <span class="comment">// user code</span></div>
<div class="line">}</div>
<div class="ttc" id="aWrapOpenMP_8h_html_adf64fc4981617d456044d0a30deb3d0d"><div class="ttname"><a href="WrapOpenMP_8h.html#adf64fc4981617d456044d0a30deb3d0d">AUTOPAS_OPENMP</a></div><div class="ttdeci">#define AUTOPAS_OPENMP(args)</div><div class="ttdoc">Empty macro to throw away any arguments.</div><div class="ttdef"><b>Definition:</b> WrapOpenMP.h:126</div></div>
</div><!-- fragment --><p>Note that this is equal to <code>#pragma omp parallel</code> and <b>NOT</b> a <code>parallel for</code> clause! AutoPas detects that it is in a parallel region and spawns multiple iterators spread over the container. All features described above also work in parallel, including particle deletion.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
Nested Loops</h3>
<p>If iterators are nested, inner loops should not spawn multiple iterators to avoid spreading the work too thin. This can be achieved by adapting the <code>IteratorBehavior</code>, which works similar to a bit vector: </p><div class="fragment"><div class="line"><a class="code hl_define" href="WrapOpenMP_8h.html#adf64fc4981617d456044d0a30deb3d0d">AUTOPAS_OPENMP</a>(parallel)</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; particle : autoPas) {   <span class="comment">// spawns N iterators</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> iter = autoPas.begin(autopas::IteratorBehavior::ownedOrHalo | autopas::IteratorBehavior::forceSequential);</div>
<div class="line">      iter != autoPas.end();</div>
<div class="line">      ++iter) {                   <span class="comment">// spawns 1 iterator</span></div>
<div class="line">    <span class="comment">// user code</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md36"></a>
&lt;tt&gt;ForEach&lt;/tt&gt;</h1>
<p>The <code>forEach</code>-style methods aim to provide a similar feature set as <code>ContainerIterator</code>. For this, multiple member functions are available:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Function   </th><th class="markdownTableHeadLeft">Purpose    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>forEach(Lambda, IteratorBehavior)</code>   </td><td class="markdownTableBodyLeft">Sequential iteration over all particles in the container.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>forEachParallel(Lambda, IteratorBehavior)</code>   </td><td class="markdownTableBodyLeft">Parallel iteration over all particles in the container.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>forEachInRegion(Lambda, lowCorner, highCorner, IteratorBehavior)</code>   </td><td class="markdownTableBodyLeft">Sequential iteration over a given box, same as region iterators.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>forEachInRegionParallel(Lambda, lowCorner, highCorner, IteratorBehavior)</code>   </td><td class="markdownTableBodyLeft">Parallel iteration over a given box, same as region iterators.   </td></tr>
</table>
<p><b>Parallel functions currently do NOT YET implement any parallelization and an equivalent to their sequential counterparts!</b></p>
<p>Here, <code>Lambda</code> stands for a function of the signature <code>(Particle &amp;) -&gt; void</code>. All of those functions also exist in a <code>const</code> version with the otherwise same signature.</p>
<div class="fragment"><div class="line">autoPas.forEachInRegionParallel([](<span class="keyword">auto</span> &amp;particle) {</div>
<div class="line">  <span class="comment">// user code (here e.g. calculating newR)</span></div>
<div class="line">  particle.setR(newR);</div>
<div class="line">}, lowCorner, highCorner, behavior);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
Reductions</h2>
<p>On top of that, for every <code>forEach</code>-style function, there is also a corresponding <code>reduce[inRegion][Parallel]()</code> function. Here, the lambda function has the form <code>(Particle &amp;, ResultT &amp;) -&gt; void</code> </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> result = 0;</div>
<div class="line">autoPas.reduceInRegionParallel([](<span class="keyword">auto</span> &amp;particle, <span class="keyword">auto</span> &amp;accumulator) {</div>
<div class="line">  <span class="comment">// user code</span></div>
<div class="line">  accumulator += particle.getID();</div>
<div class="line">}, result, lowCorner, highCorner, behavior);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md38"></a>
Related Files and Folders</h1>
<ul>
<li><a class="el" href="ContainerIterator_8h.html">ContainerIterator.h</a></li>
<li><a class="el" href="IteratorBehavior_8h.html">IteratorBehavior.h</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceautopas.html">autopas</a></li><li class="navelem"><a class="el" href="classautopas_1_1OctreeInnerNode.html">OctreeInnerNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classautopas_1_1OctreeInnerNode-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">autopas::OctreeInnerNode&lt; Particle_T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Inner nodes of the octree data structure.  
 <a href="classautopas_1_1OctreeInnerNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OctreeInnerNode_8h_source.html">OctreeInnerNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for autopas::OctreeInnerNode&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1OctreeInnerNode__inherit__graph.png" border="0" usemap="#aautopas_1_1OctreeInnerNode_3_01Particle__T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aautopas_1_1OctreeInnerNode_3_01Particle__T_01_4_inherit__map" id="aautopas_1_1OctreeInnerNode_3_01Particle__T_01_4_inherit__map">
<area shape="rect" title="Inner nodes of the octree data structure." alt="" coords="18,93,210,133"/>
<area shape="rect" href="classautopas_1_1OctreeNodeInterface.html" title="The base class that provides the necessary function definitions that can be applied to an octree." alt="" coords="5,5,223,45"/>
<area shape="poly" title=" " alt="" coords="117,59,117,93,111,93,111,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for autopas::OctreeInnerNode&lt; Particle_T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classautopas_1_1OctreeInnerNode__coll__graph.png" border="0" usemap="#aautopas_1_1OctreeInnerNode_3_01Particle__T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aautopas_1_1OctreeInnerNode_3_01Particle__T_01_4_coll__map" id="aautopas_1_1OctreeInnerNode_3_01Particle__T_01_4_coll__map">
<area shape="rect" title="Inner nodes of the octree data structure." alt="" coords="18,93,210,133"/>
<area shape="rect" href="classautopas_1_1OctreeNodeInterface.html" title="The base class that provides the necessary function definitions that can be applied to an octree." alt="" coords="5,5,223,45"/>
<area shape="poly" title=" " alt="" coords="117,59,117,93,111,93,111,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf4026b99e2702ea4fec2efb994d5504"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#abf4026b99e2702ea4fec2efb994d5504">OctreeInnerNode</a> (const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax, <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *parent, int unsigned treeSplitThreshold, double interactionLength, double cellSizeFactor)</td></tr>
<tr class="memdesc:abf4026b99e2702ea4fec2efb994d5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an octree inner node that points to eight leaves.  <br /></td></tr>
<tr class="separator:abf4026b99e2702ea4fec2efb994d5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec47e19b1c301f6b493dfcaa07acc6ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#aec47e19b1c301f6b493dfcaa07acc6ca">OctreeInnerNode</a> (const <a class="el" href="classautopas_1_1OctreeInnerNode.html">OctreeInnerNode</a>&lt; Particle_T &gt; &amp;other)</td></tr>
<tr class="memdesc:aec47e19b1c301f6b493dfcaa07acc6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all children from the other octree into this octree.  <br /></td></tr>
<tr class="separator:aec47e19b1c301f6b493dfcaa07acc6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6478eca9b3b2e070d3312a91824e61"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#aea6478eca9b3b2e070d3312a91824e61">insert</a> (const Particle_T &amp;p) override</td></tr>
<tr class="memdesc:aea6478eca9b3b2e070d3312a91824e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a particle into the octree.    <br /></td></tr>
<tr class="separator:aea6478eca9b3b2e070d3312a91824e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24782ba53caf637805a666a3b088fadc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a24782ba53caf637805a666a3b088fadc">deleteParticle</a> (Particle_T &amp;particle) override</td></tr>
<tr class="memdesc:a24782ba53caf637805a666a3b088fadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given particle from the data structure.    <br /></td></tr>
<tr class="separator:a24782ba53caf637805a666a3b088fadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae157da9c142908f38643fbde87b10fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#aae157da9c142908f38643fbde87b10fc">collectAllParticles</a> (std::vector&lt; Particle_T * &gt; &amp;ps) const override</td></tr>
<tr class="memdesc:aae157da9c142908f38643fbde87b10fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all particles that are below this node into the vector.    <br /></td></tr>
<tr class="separator:aae157da9c142908f38643fbde87b10fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8c43ef98d4346ff98af3e1fdacbe4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#acd8c43ef98d4346ff98af3e1fdacbe4f">appendAllLeafBoxes</a> (std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, std::array&lt; double, 3 &gt; &gt; &gt; &amp;boxes) const override</td></tr>
<tr class="memdesc:acd8c43ef98d4346ff98af3e1fdacbe4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the min/max corner coordinates of every leaf into the vector.    <br /></td></tr>
<tr class="separator:acd8c43ef98d4346ff98af3e1fdacbe4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145682a8d9edb467f85fdf92fb48ab0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a145682a8d9edb467f85fdf92fb48ab0b">clearChildren</a> (std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; &amp;ref) override</td></tr>
<tr class="memdesc:a145682a8d9edb467f85fdf92fb48ab0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the entire tree below this node.    <br /></td></tr>
<tr class="separator:a145682a8d9edb467f85fdf92fb48ab0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb258a35d550c78984ba4f2cde6d8ab9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#abb258a35d550c78984ba4f2cde6d8ab9">size</a> () const override</td></tr>
<tr class="memdesc:abb258a35d550c78984ba4f2cde6d8ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of particles saved in the container (owned + halo + dummy).      <br /></td></tr>
<tr class="separator:abb258a35d550c78984ba4f2cde6d8ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc49e4e083d0aefea83062b1e9053de"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a1bc49e4e083d0aefea83062b1e9053de">getNumberOfParticles</a> (IteratorBehavior behavior) const override</td></tr>
<tr class="memdesc:a1bc49e4e083d0aefea83062b1e9053de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.        <br /></td></tr>
<tr class="separator:a1bc49e4e083d0aefea83062b1e9053de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d42bc916a949ee8a5d9349ecdfcaa18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a5d42bc916a949ee8a5d9349ecdfcaa18">hasChildren</a> () override</td></tr>
<tr class="memdesc:a5d42bc916a949ee8a5d9349ecdfcaa18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node is a leaf or an inner node.    <br /></td></tr>
<tr class="separator:a5d42bc916a949ee8a5d9349ecdfcaa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f439ed1cf936832710072819f5df3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#ac8f439ed1cf936832710072819f5df3b">getChild</a> (int index) override</td></tr>
<tr class="memdesc:ac8f439ed1cf936832710072819f5df3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child by its index from the node.    <br /></td></tr>
<tr class="separator:ac8f439ed1cf936832710072819f5df3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bda3fc926760b467bc214ea158304a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a9bda3fc926760b467bc214ea158304a3">getLeavesFromDirections</a> (const std::vector&lt; <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> &gt; &amp;directions) override</td></tr>
<tr class="memdesc:a9bda3fc926760b467bc214ea158304a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaf nodes along a list of given directions.  <br /></td></tr>
<tr class="separator:a9bda3fc926760b467bc214ea158304a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f9293b645335024a43c1b97c5556b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a33f9293b645335024a43c1b97c5556b0">SON</a> (<a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Octant</a> octant) override</td></tr>
<tr class="memdesc:a33f9293b645335024a43c1b97c5556b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child node of this node (if there are children) given a specific octant using the spacial structure of the stored children.  <br /></td></tr>
<tr class="separator:a33f9293b645335024a43c1b97c5556b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb2ef9c5016796e89c834c26fde33d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a2fb2ef9c5016796e89c834c26fde33d0">appendAllLeaves</a> (std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;leaves) const override</td></tr>
<tr class="memdesc:a2fb2ef9c5016796e89c834c26fde33d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all leaves below this subtree into a given list.  <br /></td></tr>
<tr class="separator:a2fb2ef9c5016796e89c834c26fde33d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b4f7ec4ed85618130ff54f519b9964"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a85b4f7ec4ed85618130ff54f519b9964">getLeavesInRange</a> (const std::array&lt; double, 3 &gt; &amp;min, const std::array&lt; double, 3 &gt; &amp;max) override</td></tr>
<tr class="memdesc:a85b4f7ec4ed85618130ff54f519b9964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaves below this subtree that are in the given range.  <br /></td></tr>
<tr class="separator:a85b4f7ec4ed85618130ff54f519b9964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e70288aab9a7c635dfcfb5ad7f98430"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:a2e70288aab9a7c635dfcfb5ad7f98430"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a2e70288aab9a7c635dfcfb5ad7f98430">forEach</a> (Lambda forEachLambda)</td></tr>
<tr class="memdesc:a2e70288aab9a7c635dfcfb5ad7f98430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the forEach lambda to each particle.    <br /></td></tr>
<tr class="separator:a2e70288aab9a7c635dfcfb5ad7f98430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f1cfe94ed3e7eeef38944bb7f1ce9c"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:a36f1cfe94ed3e7eeef38944bb7f1ce9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a36f1cfe94ed3e7eeef38944bb7f1ce9c">reduce</a> (Lambda reduceLambda, A &amp;result)</td></tr>
<tr class="memdesc:a36f1cfe94ed3e7eeef38944bb7f1ce9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reduce lambda to each particle.    <br /></td></tr>
<tr class="separator:a36f1cfe94ed3e7eeef38944bb7f1ce9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac545b5779458211b9b0064d142d981a7"><td class="memTemplParams" colspan="2">template&lt;typename Lambda &gt; </td></tr>
<tr class="memitem:ac545b5779458211b9b0064d142d981a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#ac545b5779458211b9b0064d142d981a7">forEach</a> (Lambda forEachLambda, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:ac545b5779458211b9b0064d142d981a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the forEach lambda to each particle in the region.  <br /></td></tr>
<tr class="separator:ac545b5779458211b9b0064d142d981a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c07084bb46daf07d84dad4f81b0d663"><td class="memTemplParams" colspan="2">template&lt;typename Lambda , typename A &gt; </td></tr>
<tr class="memitem:a7c07084bb46daf07d84dad4f81b0d663"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeInnerNode.html#a7c07084bb46daf07d84dad4f81b0d663">reduce</a> (Lambda reduceLambda, A &amp;result, const std::array&lt; double, 3 &gt; &amp;lowerCorner, const std::array&lt; double, 3 &gt; &amp;higherCorner, IteratorBehavior behavior)</td></tr>
<tr class="memdesc:a7c07084bb46daf07d84dad4f81b0d663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the reduce lambda to each particle in the region.  <br /></td></tr>
<tr class="separator:a7c07084bb46daf07d84dad4f81b0d663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classautopas_1_1OctreeNodeInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classautopas_1_1OctreeNodeInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:ad416befeb8d31565ea5bfdeef66fa104 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad416befeb8d31565ea5bfdeef66fa104">OctreeNodeInterface</a> (const std::array&lt; double, 3 &gt; &amp;boxMin, const std::array&lt; double, 3 &gt; &amp;boxMax, <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *parent, const int unsigned treeSplitThreshold, const double interactionLength, const double cellSizeFactor)</td></tr>
<tr class="memdesc:ad416befeb8d31565ea5bfdeef66fa104 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an octree node interface by initializing the given fields.  <br /></td></tr>
<tr class="separator:ad416befeb8d31565ea5bfdeef66fa104 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d4bc0efaad30b855b2ab43672d843b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a66d4bc0efaad30b855b2ab43672d843b" name="a66d4bc0efaad30b855b2ab43672d843b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~OctreeNodeInterface</b> ()=default</td></tr>
<tr class="memdesc:a66d4bc0efaad30b855b2ab43672d843b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">To make clang happy. <br /></td></tr>
<tr class="separator:a66d4bc0efaad30b855b2ab43672d843b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24265c31be2340ab1f62a0a653be0f88 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a24265c31be2340ab1f62a0a653be0f88" name="a24265c31be2340ab1f62a0a653be0f88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OctreeNodeInterface</b> (const <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &amp;)=default</td></tr>
<tr class="memdesc:a24265c31be2340ab1f62a0a653be0f88 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor. <br /></td></tr>
<tr class="separator:a24265c31be2340ab1f62a0a653be0f88 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d236108b1d67a05e03eb0ca49a7422 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab5d236108b1d67a05e03eb0ca49a7422">insert</a> (const Particle_T &amp;p)=0</td></tr>
<tr class="memdesc:ab5d236108b1d67a05e03eb0ca49a7422 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a particle into the octree.  <br /></td></tr>
<tr class="separator:ab5d236108b1d67a05e03eb0ca49a7422 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25687dec42fc04d53c8ad6416290eb6 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad25687dec42fc04d53c8ad6416290eb6">deleteParticle</a> (Particle_T &amp;particle)=0</td></tr>
<tr class="memdesc:ad25687dec42fc04d53c8ad6416290eb6 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given particle from the data structure.    <br /></td></tr>
<tr class="separator:ad25687dec42fc04d53c8ad6416290eb6 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ead81def7160fc03a73c447bf7e53 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a6c6ead81def7160fc03a73c447bf7e53">collectAllParticles</a> (std::vector&lt; Particle_T * &gt; &amp;ps) const =0</td></tr>
<tr class="memdesc:a6c6ead81def7160fc03a73c447bf7e53 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all particles that are below this node into the vector.  <br /></td></tr>
<tr class="separator:a6c6ead81def7160fc03a73c447bf7e53 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb6398c228be2a285ce1f86c02a8d25 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7fb6398c228be2a285ce1f86c02a8d25">appendAllLeafBoxes</a> (std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, std::array&lt; double, 3 &gt; &gt; &gt; &amp;boxes) const =0</td></tr>
<tr class="memdesc:a7fb6398c228be2a285ce1f86c02a8d25 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the min/max corner coordinates of every leaf into the vector.  <br /></td></tr>
<tr class="separator:a7fb6398c228be2a285ce1f86c02a8d25 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a10fa85f01ff57a9a06c57de607d59b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a2a10fa85f01ff57a9a06c57de607d59b">appendAllLeaves</a> (std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;leaves) const =0</td></tr>
<tr class="memdesc:a2a10fa85f01ff57a9a06c57de607d59b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put all leaves below this subtree into a given list.  <br /></td></tr>
<tr class="separator:a2a10fa85f01ff57a9a06c57de607d59b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ab6f178fce0a5742d1881021dac4e3 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab2ab6f178fce0a5742d1881021dac4e3">clearChildren</a> (std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; &amp;ref)=0</td></tr>
<tr class="memdesc:ab2ab6f178fce0a5742d1881021dac4e3 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the entire tree below this node.  <br /></td></tr>
<tr class="separator:ab2ab6f178fce0a5742d1881021dac4e3 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6e61aed5fb70cbd069e8f172dc9291 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7e6e61aed5fb70cbd069e8f172dc9291">size</a> () const =0</td></tr>
<tr class="memdesc:a7e6e61aed5fb70cbd069e8f172dc9291 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of particles saved in the container (owned + halo + dummy).    <br /></td></tr>
<tr class="separator:a7e6e61aed5fb70cbd069e8f172dc9291 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31651019cd7e284b620411f1e023a3b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ac31651019cd7e284b620411f1e023a3b">getNumberOfParticles</a> (IteratorBehavior behavior=IteratorBehavior::owned) const =0</td></tr>
<tr class="memdesc:ac31651019cd7e284b620411f1e023a3b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of particles with respect to the specified IteratorBehavior.      <br /></td></tr>
<tr class="separator:ac31651019cd7e284b620411f1e023a3b inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df399ebdc0b38620a35af63bcf13271 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a4df399ebdc0b38620a35af63bcf13271">SON</a> (<a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Octant</a> O)=0</td></tr>
<tr class="memdesc:a4df399ebdc0b38620a35af63bcf13271 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child node of this node (if there are children) given a specific octant using the spacial structure of the stored children.  <br /></td></tr>
<tr class="separator:a4df399ebdc0b38620a35af63bcf13271 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a1188bc4e80325b23040b921e2aaf inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#add2a1188bc4e80325b23040b921e2aaf">hasChildren</a> ()=0</td></tr>
<tr class="memdesc:add2a1188bc4e80325b23040b921e2aaf inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node is a leaf or an inner node.  <br /></td></tr>
<tr class="separator:add2a1188bc4e80325b23040b921e2aaf inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a83ac4270e177bc03215e0378064aa inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a42a83ac4270e177bc03215e0378064aa">getChild</a> (int index)=0</td></tr>
<tr class="memdesc:a42a83ac4270e177bc03215e0378064aa inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a child by its index from the node.  <br /></td></tr>
<tr class="separator:a42a83ac4270e177bc03215e0378064aa inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120821d0ce7268603cafb9f720526b85 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a120821d0ce7268603cafb9f720526b85">getLeavesInRange</a> (const std::array&lt; double, 3 &gt; &amp;min, const std::array&lt; double, 3 &gt; &amp;max)=0</td></tr>
<tr class="memdesc:a120821d0ce7268603cafb9f720526b85 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaves below this subtree that are in the given range.  <br /></td></tr>
<tr class="separator:a120821d0ce7268603cafb9f720526b85 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49a028da76d8b6d201593c618414563 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ae49a028da76d8b6d201593c618414563">isInside</a> (const std::array&lt; double, 3 &gt; &amp;point)</td></tr>
<tr class="memdesc:ae49a028da76d8b6d201593c618414563 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a 3d point is inside the node's axis aligned bounding box.  <br /></td></tr>
<tr class="separator:ae49a028da76d8b6d201593c618414563 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c63883d72a6c02c4c104bda68bbff2 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a07c63883d72a6c02c4c104bda68bbff2">enclosesVolumeWithOtherOnAxis</a> (const int axis, const <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *other)</td></tr>
<tr class="memdesc:a07c63883d72a6c02c4c104bda68bbff2 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an octree node's box encloses volume with another octree node's box on a specific axis.  <br /></td></tr>
<tr class="separator:a07c63883d72a6c02c4c104bda68bbff2 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89bb30dbb1b22ab41f94f87d01ba145 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ac89bb30dbb1b22ab41f94f87d01ba145">overlapsBox</a> (const std::array&lt; double, 3 &gt; &amp;otherMin, const std::array&lt; double, 3 &gt; &amp;otherMax)</td></tr>
<tr class="memdesc:ac89bb30dbb1b22ab41f94f87d01ba145 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node's axis aligned bounding box overlaps with the given axis aligned bounding box.  <br /></td></tr>
<tr class="separator:ac89bb30dbb1b22ab41f94f87d01ba145 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b732ab55963e9575b3dc07f67e5e9 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#acf5b732ab55963e9575b3dc07f67e5e9">getEnclosedVolumeWith</a> (const std::array&lt; double, 3 &gt; &amp;otherMin, const std::array&lt; double, 3 &gt; &amp;otherMax)</td></tr>
<tr class="memdesc:acf5b732ab55963e9575b3dc07f67e5e9 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the overlap volume between the node's axis aligned bounding box and the given box.  <br /></td></tr>
<tr class="separator:acf5b732ab55963e9575b3dc07f67e5e9 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5ebf043fb5de4cfdd13593ec13c450 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#aed5ebf043fb5de4cfdd13593ec13c450">EQ_FACE_NEIGHBOR</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a818a2d31517a95d918fa800aec9cd9db">octree::Face</a> I)</td></tr>
<tr class="memdesc:aed5ebf043fb5de4cfdd13593ec13c450 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:aed5ebf043fb5de4cfdd13593ec13c450 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fd47e1959b389889268556bd3c562c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a08fd47e1959b389889268556bd3c562c">EQ_EDGE_NEIGHBOR</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a652aa1ac1df1cb0b731ef71fb4962c13">octree::Edge</a> I)</td></tr>
<tr class="memdesc:a08fd47e1959b389889268556bd3c562c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:a08fd47e1959b389889268556bd3c562c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64300d0c48ead9478bd8b77482a906e4 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a64300d0c48ead9478bd8b77482a906e4">EQ_VERTEX_NEIGHBOR</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> I)</td></tr>
<tr class="memdesc:a64300d0c48ead9478bd8b77482a906e4 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of equal size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:a64300d0c48ead9478bd8b77482a906e4 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebfbc310d152aa2d67a917db3c3c8a1 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#aaebfbc310d152aa2d67a917db3c3c8a1">GTEQ_FACE_NEIGHBOR</a> (<a class="el" href="namespaceautopas_1_1octree.html#a818a2d31517a95d918fa800aec9cd9db">octree::Face</a> I)</td></tr>
<tr class="memdesc:aaebfbc310d152aa2d67a917db3c3c8a1 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:aaebfbc310d152aa2d67a917db3c3c8a1 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5573639d1edd41e219a137db2c93bf6d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a5573639d1edd41e219a137db2c93bf6d">GTEQ_EDGE_NEIGHBOR</a> (<a class="el" href="namespaceautopas_1_1octree.html#a652aa1ac1df1cb0b731ef71fb4962c13">octree::Edge</a> I)</td></tr>
<tr class="memdesc:a5573639d1edd41e219a137db2c93bf6d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:a5573639d1edd41e219a137db2c93bf6d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb1c48eeb21bd6c9fa5146738a1ab1d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#afdb1c48eeb21bd6c9fa5146738a1ab1d">GTEQ_VERTEX_NEIGHBOR</a> (<a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> I)</td></tr>
<tr class="memdesc:afdb1c48eeb21bd6c9fa5146738a1ab1d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node (via the pointer structure) that is of greater than or equal to the size of the current node's bounding box, according to the Samet paper.  <br /></td></tr>
<tr class="separator:afdb1c48eeb21bd6c9fa5146738a1ab1d inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd593f1ba72c28f5fdeca506a5246c8 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a0cd593f1ba72c28f5fdeca506a5246c8">getLeavesFromDirections</a> (const std::vector&lt; <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> &gt; &amp;directions)=0</td></tr>
<tr class="memdesc:a0cd593f1ba72c28f5fdeca506a5246c8 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all leaf nodes along a list of given directions.  <br /></td></tr>
<tr class="separator:a0cd593f1ba72c28f5fdeca506a5246c8 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf66b7e2aebf1bc8e07456550955f8a inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#aadf66b7e2aebf1bc8e07456550955f8a">getNeighborLeaves</a> (const <a class="el" href="namespaceautopas_1_1octree.html#a247c6f197293ce9a2b453bc01f7a40cb">octree::Any</a> direction)</td></tr>
<tr class="memdesc:aadf66b7e2aebf1bc8e07456550955f8a inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function combines all required functions when traversing down a subtree of the octree and finding all leaves.  <br /></td></tr>
<tr class="separator:aadf66b7e2aebf1bc8e07456550955f8a inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a7fd43486192546e50b5541a9cc3eb inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a61a7fd43486192546e50b5541a9cc3eb">getNeighborLeaves</a> ()</td></tr>
<tr class="memdesc:a61a7fd43486192546e50b5541a9cc3eb inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the neighbor leaves in all directions.  <br /></td></tr>
<tr class="separator:a61a7fd43486192546e50b5541a9cc3eb inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481b0e8598dd0a88c27ae9196764e387 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a481b0e8598dd0a88c27ae9196764e387">getBoxMin</a> () const</td></tr>
<tr class="memdesc:a481b0e8598dd0a88c27ae9196764e387 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum coordinate of the enclosing box.  <br /></td></tr>
<tr class="separator:a481b0e8598dd0a88c27ae9196764e387 inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20088a8ceb4e7cb71a5450075473240c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a20088a8ceb4e7cb71a5450075473240c">getBoxMax</a> () const</td></tr>
<tr class="memdesc:a20088a8ceb4e7cb71a5450075473240c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum coordinate of the enclosing box.  <br /></td></tr>
<tr class="separator:a20088a8ceb4e7cb71a5450075473240c inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72617b706afd5a1884400a7b5b0da7ef inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a72617b706afd5a1884400a7b5b0da7ef">getParent</a> () const</td></tr>
<tr class="memdesc:a72617b706afd5a1884400a7b5b0da7ef inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent node of this node.  <br /></td></tr>
<tr class="separator:a72617b706afd5a1884400a7b5b0da7ef inherit pub_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classautopas_1_1OctreeNodeInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classautopas_1_1OctreeNodeInterface')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:ad0c1d04c45912df3fdd297f3af8dbed5 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad0c1d04c45912df3fdd297f3af8dbed5">volumeExistsOnAxis</a> (const int axis, const std::array&lt; double, 3 &gt; &amp;aMin, const std::array&lt; double, 3 &gt; &amp;aMax, const std::array&lt; double, 3 &gt; &amp;bMin, const std::array&lt; double, 3 &gt; &amp;bMax)</td></tr>
<tr class="memdesc:ad0c1d04c45912df3fdd297f3af8dbed5 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the volume enclosed by two boxes a and b is nonzero on a specific axis.  <br /></td></tr>
<tr class="separator:ad0c1d04c45912df3fdd297f3af8dbed5 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aefc0e5edf8144556465f58419e579 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a04aefc0e5edf8144556465f58419e579">getEnclosedVolumeWith</a> (const std::array&lt; double, 3 &gt; &amp;aMin, const std::array&lt; double, 3 &gt; &amp;aMax, const std::array&lt; double, 3 &gt; &amp;bMin, const std::array&lt; double, 3 &gt; &amp;bMax)</td></tr>
<tr class="memdesc:a04aefc0e5edf8144556465f58419e579 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enclosed volume between two boxes a and b.  <br /></td></tr>
<tr class="separator:a04aefc0e5edf8144556465f58419e579 inherit pub_static_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classautopas_1_1OctreeNodeInterface"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classautopas_1_1OctreeNodeInterface')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a79ddbbda5873b854d2f743873ea371fd inherit pro_methods_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a79ddbbda5873b854d2f743873ea371fd">hasParent</a> ()</td></tr>
<tr class="memdesc:a79ddbbda5873b854d2f743873ea371fd inherit pro_methods_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this is not the root node.  <br /></td></tr>
<tr class="separator:a79ddbbda5873b854d2f743873ea371fd inherit pro_methods_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classautopas_1_1OctreeNodeInterface"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classautopas_1_1OctreeNodeInterface')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classautopas_1_1OctreeNodeInterface.html">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a></td></tr>
<tr class="memitem:a7f7309cc7f3b730c5513ae81f43a716a inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7f7309cc7f3b730c5513ae81f43a716a">_parent</a></td></tr>
<tr class="memdesc:a7f7309cc7f3b730c5513ae81f43a716a inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the parent node.  <br /></td></tr>
<tr class="separator:a7f7309cc7f3b730c5513ae81f43a716a inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5287a3f6fbd9e0e28ab813cd4086e8 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a0f5287a3f6fbd9e0e28ab813cd4086e8" name="a0f5287a3f6fbd9e0e28ab813cd4086e8"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_boxMin</b></td></tr>
<tr class="memdesc:a0f5287a3f6fbd9e0e28ab813cd4086e8 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The min coordinate of the enclosed volume. <br /></td></tr>
<tr class="separator:a0f5287a3f6fbd9e0e28ab813cd4086e8 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4809bbd85e6cb2ee83603f92e22c3178 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a4809bbd85e6cb2ee83603f92e22c3178" name="a4809bbd85e6cb2ee83603f92e22c3178"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_boxMax</b></td></tr>
<tr class="memdesc:a4809bbd85e6cb2ee83603f92e22c3178 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max coordinate of the enclosed volume. <br /></td></tr>
<tr class="separator:a4809bbd85e6cb2ee83603f92e22c3178 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc048ebbdf29cdf3e9218fc44e9e843 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a6cc048ebbdf29cdf3e9218fc44e9e843" name="a6cc048ebbdf29cdf3e9218fc44e9e843"></a>
int unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>_treeSplitThreshold</b></td></tr>
<tr class="memdesc:a6cc048ebbdf29cdf3e9218fc44e9e843 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of particles inside a leaf node before the leaf tries to split itself. <br /></td></tr>
<tr class="separator:a6cc048ebbdf29cdf3e9218fc44e9e843 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63368dc6c9bedc926a3a8f4d2266ddc0 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="a63368dc6c9bedc926a3a8f4d2266ddc0" name="a63368dc6c9bedc926a3a8f4d2266ddc0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_interactionLength</b></td></tr>
<tr class="memdesc:a63368dc6c9bedc926a3a8f4d2266ddc0 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum distance at which a force is considered nonzero, cutoff+skin. <br /></td></tr>
<tr class="separator:a63368dc6c9bedc926a3a8f4d2266ddc0 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced807582ba52e048c9620b0b56d5971 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memItemLeft" align="right" valign="top"><a id="aced807582ba52e048c9620b0b56d5971" name="aced807582ba52e048c9620b0b56d5971"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_cellSizeFactor</b></td></tr>
<tr class="memdesc:aced807582ba52e048c9620b0b56d5971 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cell size factor for this node. <br /></td></tr>
<tr class="separator:aced807582ba52e048c9620b0b56d5971 inherit pro_attribs_classautopas_1_1OctreeNodeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Particle_T&gt;<br />
class autopas::OctreeInnerNode&lt; Particle_T &gt;</div><p>Inner nodes of the octree data structure. </p>
<p>An inner node always points to eight children, which can either be leaves or inner nodes as well.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Particle_T</td><td></td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abf4026b99e2702ea4fec2efb994d5504" name="abf4026b99e2702ea4fec2efb994d5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4026b99e2702ea4fec2efb994d5504">&#9670;&#160;</a></span>OctreeInnerNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::OctreeInnerNode </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int unsigned&#160;</td>
          <td class="paramname"><em>treeSplitThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>interactionLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cellSizeFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an octree inner node that points to eight leaves. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxMin</td><td>The min coordinate of the octree box </td></tr>
    <tr><td class="paramname">boxMax</td><td>The max coordinate of the octree box </td></tr>
    <tr><td class="paramname">parent</td><td>A pointer to the parent node. Should be nullptr for root nodes. </td></tr>
    <tr><td class="paramname">treeSplitThreshold</td><td>Maximum number of particles inside a leaf before it tries to split itself </td></tr>
    <tr><td class="paramname">interactionLength</td><td>The minimum distance at which a force is considered nonzero, cutoff+skin. </td></tr>
    <tr><td class="paramname">cellSizeFactor</td><td>The cell size factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec47e19b1c301f6b493dfcaa07acc6ca" name="aec47e19b1c301f6b493dfcaa07acc6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec47e19b1c301f6b493dfcaa07acc6ca">&#9670;&#160;</a></span>OctreeInnerNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::OctreeInnerNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classautopas_1_1OctreeInnerNode.html">OctreeInnerNode</a>&lt; Particle_T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all children from the other octree into this octree. </p>
<p>(Create a new, copied subtree) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other octree (to copy from) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acd8c43ef98d4346ff98af3e1fdacbe4f" name="acd8c43ef98d4346ff98af3e1fdacbe4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8c43ef98d4346ff98af3e1fdacbe4f">&#9670;&#160;</a></span>appendAllLeafBoxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::appendAllLeafBoxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::array&lt; double, 3 &gt;, std::array&lt; double, 3 &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>boxes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the min/max corner coordinates of every leaf into the vector.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>A reference to the vector that should contain pairs of the min/max corner coordinates   </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7fb6398c228be2a285ce1f86c02a8d25">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a2fb2ef9c5016796e89c834c26fde33d0" name="a2fb2ef9c5016796e89c834c26fde33d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb2ef9c5016796e89c834c26fde33d0">&#9670;&#160;</a></span>appendAllLeaves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::appendAllLeaves </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put all leaves below this subtree into a given list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaves</td><td>A reference to the vector that should contain pointers to the leaves </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a2a10fa85f01ff57a9a06c57de607d59b">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a145682a8d9edb467f85fdf92fb48ab0b" name="a145682a8d9edb467f85fdf92fb48ab0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145682a8d9edb467f85fdf92fb48ab0b">&#9670;&#160;</a></span>clearChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::clearChildren </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the entire tree below this node.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>A reference that contains this node   </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab2ab6f178fce0a5742d1881021dac4e3">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="aae157da9c142908f38643fbde87b10fc" name="aae157da9c142908f38643fbde87b10fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae157da9c142908f38643fbde87b10fc">&#9670;&#160;</a></span>collectAllParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::collectAllParticles </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Particle_T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put all particles that are below this node into the vector.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>A reference to the vector that should contain the particles after the operation   </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a6c6ead81def7160fc03a73c447bf7e53">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a24782ba53caf637805a666a3b088fadc" name="a24782ba53caf637805a666a3b088fadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24782ba53caf637805a666a3b088fadc">&#9670;&#160;</a></span>deleteParticle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::deleteParticle </td>
          <td>(</td>
          <td class="paramtype">Particle_T &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the given particle from the data structure.   </p>
<p>This function does not change the tree layout if the node is empty after the operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particle</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given pointer still points to a new, valid particle.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#ad25687dec42fc04d53c8ad6416290eb6">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a2e70288aab9a7c635dfcfb5ad7f98430" name="a2e70288aab9a7c635dfcfb5ad7f98430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e70288aab9a7c635dfcfb5ad7f98430">&#9670;&#160;</a></span>forEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the forEach lambda to each particle.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>Function to apply   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac545b5779458211b9b0064d142d981a7" name="ac545b5779458211b9b0064d142d981a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac545b5779458211b9b0064d142d981a7">&#9670;&#160;</a></span>forEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>forEachLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the forEach lambda to each particle in the region. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">forEachLambda</td><td>Function to apply </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of region </td></tr>
    <tr><td class="paramname">behavior</td><td>Parameter is only there to reuse functionality already implemented in <a class="el" href="classautopas_1_1FullParticleCell.html" title="This class handles the storage of particles in their full form.">FullParticleCell</a>, should be set to ownedOrHalo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8f439ed1cf936832710072819f5df3b" name="ac8f439ed1cf936832710072819f5df3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f439ed1cf936832710072819f5df3b">&#9670;&#160;</a></span>getChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::getChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a child by its index from the node.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the child. Must be between 0 and 7 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the child.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a42a83ac4270e177bc03215e0378064aa">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a9bda3fc926760b467bc214ea158304a3" name="a9bda3fc926760b467bc214ea158304a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bda3fc926760b467bc214ea158304a3">&#9670;&#160;</a></span>getLeavesFromDirections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::getLeavesFromDirections </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all leaf nodes along a list of given directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directions</td><td>A list of allowed directions for traversal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of leaf nodes </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a0cd593f1ba72c28f5fdeca506a5246c8">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a85b4f7ec4ed85618130ff54f519b9964" name="a85b4f7ec4ed85618130ff54f519b9964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b4f7ec4ed85618130ff54f519b9964">&#9670;&#160;</a></span>getLeavesInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="classautopas_1_1OctreeLeafNode.html">OctreeLeafNode</a>&lt; Particle_T &gt; * &gt; <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::getLeavesInRange </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all leaves below this subtree that are in the given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The minimum coordinate in 3D space of the query area </td></tr>
    <tr><td class="paramname">max</td><td>The maximum coordinate in 3D space of the query area </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of all leaf nodes that are in the query region </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a120821d0ce7268603cafb9f720526b85">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a1bc49e4e083d0aefea83062b1e9053de" name="a1bc49e4e083d0aefea83062b1e9053de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc49e4e083d0aefea83062b1e9053de">&#9670;&#160;</a></span>getNumberOfParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::getNumberOfParticles </td>
          <td>(</td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of particles with respect to the specified IteratorBehavior.       </p>
<dl class="section warning"><dt>Warning</dt><dd>: Since this function counts the number of the respective particles in the internal particle storage, this is in O(n) + lock is required. Only use it when it is absolutely necessary to have the exact number of different particle types like owned or halo. If it is enough to have the whole number of particles (owned + halo + dummy), the function <a class="el" href="classautopas_1_1OctreeInnerNode.html#abb258a35d550c78984ba4f2cde6d8ab9" title="Get the total number of particles saved in the container (owned + halo + dummy).">size()</a> can be used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">behavior</td><td>Behavior of the iterator, see IteratorBehavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of particles with respect to the specified IteratorBehavior.       </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#ac31651019cd7e284b620411f1e023a3b">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a5d42bc916a949ee8a5d9349ecdfcaa18" name="a5d42bc916a949ee8a5d9349ecdfcaa18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d42bc916a949ee8a5d9349ecdfcaa18">&#9670;&#160;</a></span>hasChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::hasChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the node is a leaf or an inner node.   </p>
<p>Use this over dynamic_cast to distinguish node types. It is 20-50 times faster! <a href="https://stackoverflow.com/a/49296405/7019073">https://stackoverflow.com/a/49296405/7019073</a> </p><dl class="section return"><dt>Returns</dt><dd>true iff the node is a leaf, false otherwise.   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#add2a1188bc4e80325b23040b921e2aaf">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="aea6478eca9b3b2e070d3312a91824e61" name="aea6478eca9b3b2e070d3312a91824e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6478eca9b3b2e070d3312a91824e61">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; &gt; <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const Particle_T &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a particle into the octree.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The particle to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::unique_ptr to a newly created subtree or nullptr if the subtree did not change   </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#ab5d236108b1d67a05e03eb0ca49a7422">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a36f1cfe94ed3e7eeef38944bb7f1ce9c" name="a36f1cfe94ed3e7eeef38944bb7f1ce9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f1cfe94ed3e7eeef38944bb7f1ce9c">&#9670;&#160;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the reduce lambda to each particle.   </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>Function type </td></tr>
    <tr><td class="paramname">A</td><td>Initial value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>Function to apply </td></tr>
    <tr><td class="paramname">result</td><td>Initial value   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c07084bb46daf07d84dad4f81b0d663" name="a7c07084bb46daf07d84dad4f81b0d663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c07084bb46daf07d84dad4f81b0d663">&#9670;&#160;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<div class="memtemplate">
template&lt;typename Lambda , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">Lambda&#160;</td>
          <td class="paramname"><em>reduceLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lowerCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>higherCorner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorBehavior&#160;</td>
          <td class="paramname"><em>behavior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the reduce lambda to each particle in the region. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Lambda</td><td>Function type </td></tr>
    <tr><td class="paramname">A</td><td>Initial value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduceLambda</td><td>Function to apply </td></tr>
    <tr><td class="paramname">result</td><td>Initial value </td></tr>
    <tr><td class="paramname">lowerCorner</td><td>Lower corner of region </td></tr>
    <tr><td class="paramname">higherCorner</td><td>Higher corner of region </td></tr>
    <tr><td class="paramname">behavior</td><td>Parameter is only there to reuse functionality already implemented in <a class="el" href="classautopas_1_1FullParticleCell.html" title="This class handles the storage of particles in their full form.">FullParticleCell</a>, should be set to ownedOrHalo </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb258a35d550c78984ba4f2cde6d8ab9" name="abb258a35d550c78984ba4f2cde6d8ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb258a35d550c78984ba4f2cde6d8ab9">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of particles saved in the container (owned + halo + dummy).     </p>
<dl class="section return"><dt>Returns</dt><dd>Number of particles saved in the container (owned + halo + dummy).     </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a7e6e61aed5fb70cbd069e8f172dc9291">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<a id="a33f9293b645335024a43c1b97c5556b0" name="a33f9293b645335024a43c1b97c5556b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f9293b645335024a43c1b97c5556b0">&#9670;&#160;</a></span>SON()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Particle_T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classautopas_1_1OctreeNodeInterface.html">OctreeNodeInterface</a>&lt; Particle_T &gt; * <a class="el" href="classautopas_1_1OctreeInnerNode.html">autopas::OctreeInnerNode</a>&lt; Particle_T &gt;::SON </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceautopas_1_1octree.html#a634edb45fec2977d2015038cd8a3d25d">octree::Octant</a>&#160;</td>
          <td class="paramname"><em>O</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a child node of this node (if there are children) given a specific octant using the spacial structure of the stored children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">O</td><td>The octant </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a child node </dd></dl>

<p>Implements <a class="el" href="classautopas_1_1OctreeNodeInterface.html#a4df399ebdc0b38620a35af63bcf13271">autopas::OctreeNodeInterface&lt; Particle_T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>autopas/containers/octree/<a class="el" href="OctreeInnerNode_8h_source.html">OctreeInnerNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

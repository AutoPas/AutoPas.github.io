<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AutoPas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Small.svg">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript">
    function doOnLoad() {
        if (!window.location.href.startsWith("file://")) {
            // this is only done if we are on an actual webserver, where we expect to have ../autopas_onpageload.js
            var script = document.createElement('script');
            script.onload = function () {
                on_page_load();
            };
            script.src = "../onpageload.js";
            document.head.appendChild(script); //or something of the likes
        } else {
            var version_selector = document.getElementById("autopas_version_selector");
            var option = document.createElement("option");
            option.text = "local";
            option.value = "local";
            version_selector.appendChild(option);
        }
    }
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body onload="doOnLoad()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="main_selector">
    </div>
	<!--BEGIN VERSION INFO-->
	<div id="version_selector">
        <label for="autopas_version_selector">Version:</label>
        <select id="autopas_version_selector">
        </select>
	</div>
	<!--END VERSION INFO-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://autopas.github.io/"><img style="height: 56px;" alt="AutoPas" src="AutoPasLogo_Large.svg"/></a>
   &#160;<span id="projectnumber">2.0.0-cec0da9</span>
   </div>
  </td>
     <td style="float:right"><div id="githublink"><a href="https://github.com/AutoPas/AutoPas"><img border="0" alt="GitHub" src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" height="56px"></a></div></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><img src="https://raw.githubusercontent.com/AutoPas/AutoPas/master/docs/graphics/AutoPasLogo_Large.svg" alt="AutoPas" style="pointer-events: none;" title="Title" class="inline"/> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md__github_workspace_README"></a> AutoPas is a node-level auto-tuned particle simulation library developed in the context of the <a href="http://www.talpas.de"><b>TaLPas</b></a> project. <a href="https://www5.in.tum.de/jenkins/mardyn/job/AutoPas-Multibranch/job/master/"><img src="https://www5.in.tum.de/jenkins/mardyn/buildStatus/icon?job=AutoPas-Multibranch/master" alt="Build Status" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Documentation</h1>
<p >The documentation can be found at our website: <a href="https://autopas.github.io/doxygen_documentation/git-master/">https://autopas.github.io/doxygen_documentation/git-master/</a></p>
<p >Alternatively you can build the documentation on your own:</p><ul>
<li>requirements: <a href="http://www.doxygen.nl/">Doxygen</a></li>
<li><code>make doc_doxygen</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Requirements</h1>
<ul>
<li>CMake 3.14 or newer</li>
<li>make (build-essentials) or ninja</li>
<li>a c++17 compiler (gcc7, clang8 and <strike>icpc 2019</strike> are tested.)</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Building AutoPas</h1>
<p >build instructions for make: </p><div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake ..</div>
<div class="line">make</div>
</div><!-- fragment --><p> if you want to use a specific compiler, specify it at the first CMake call, e.g.: </p><div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">CC=clang CXX=clang++ cmake ..</div>
<div class="line">make</div>
</div><!-- fragment --><p> if you would like to use ninja instead of make: </p><div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake -G Ninja ..</div>
<div class="line">ninja</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md4"></a>
Building AutoPas on a Cluster</h2>
<p >HPC clusters often use module systems. CMake is sometimes not able to correctly detect the compiler you wished to use. If a wrong compiler is found please specify the compiler explicitly, e.g. for gcc: </p><div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">CC=`which gcc` CXX=`which g++` cmake ..</div>
<div class="line">make</div>
</div><!-- fragment --><p >AutoPas relies on a small number of dependencies. By default, AutoPas looks for installed versions of those libraries, but it can also be forced to (selectively) use bundled versions. To make use of this feature, call <code>cmake</code> with: </p><div class="fragment"><div class="line">cmake -D spdlog_ForceBundled=ON    # replace spdlog by the lib you want to force</div>
</div><!-- fragment --><p> Or better, have a look at the variables exposed in <code>ccmake</code>.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Testing</h1>
<p >AutoPas uses <a href="https://github.com/google/googletest">googletest</a> as testing framework and exposes tests to ctest, the CMake test driver.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Running Tests</h2>
<p >There are multiple possibilities. In order of recommendation:</p>
<ol type="1">
<li>Using <code>ctest</code>: <div class="fragment"><div class="line">ctest # add --verbose for more details on the tests</div>
</div><!-- fragment --> To only run specific tests use arguments like <code>-R</code> (run tests matching regex) and <code>-E</code> (exclude tests matching regex) <div class="fragment"><div class="line">ctest -R &#39;Array.*testAdd&#39; -E &#39;Double&#39;</div>
</div><!-- fragment --></li>
<li>Using the <code>make</code> target: <div class="fragment"><div class="line">make test</div>
</div><!-- fragment --></li>
<li>Directly launching the test executable: <div class="fragment"><div class="line">tests/testAutopas/runTests</div>
</div><!-- fragment --> To only run specific tests use arguments <div class="fragment"><div class="line">tests/testAutopas/runTests --gtest_filter=ArrayMathTest.testAdd*</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md7"></a>
Debugging Tests</h2>
<p >Many IDEs (e.g., CLion) have integrated support for googletest, and you can debug the tests directly within the IDE.</p>
<p >If you prefer <code>gdb</code>:</p><ol type="1">
<li>Find out the command to start your desired test with <code>-N</code> aka. <code>--show-only</code>: <div class="fragment"><div class="line">ctest -R &#39;Array.*testAdd&#39; -N</div>
</div><!-- fragment --></li>
<li>Start the test with <code>gdb</code> <div class="fragment"><div class="line">gdb --args ${TestCommand}</div>
</div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="autotoc_md8"></a>
Examples</h1>
<p >As AutoPas is only a library, it is not able to run simulations by itself. We have, however, included a few example proxy applications in the <b>examples</b> directory. The examples include:</p><ul>
<li><a href="examples/md-flexible">md-flexible</a>: Molecular dynamics simulations with single centered Lennard-Jones particles.</li>
<li>Smoothed particle hydrodynamics simulations</li>
</ul>
<h1><a class="anchor" id="autotoc_md9"></a>
Using AutoPas</h1>
<p >Steps to using AutoPas in your particle simulation program:</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Custom Particles</h2>
<p >First you will need to define a particle class which will be passed to AutoPas as template Argument. For that we provide some basic Particle classes defined in <code>src/autopas/molecularDynamics</code> or <code>src/autopas/sph</code> that you can use either directly or you can write your own Particle class by inheriting from one of the provided classes or from <code><a class="el" href="namespaceautopas.html#a1103977ab8f79d296cee5b0afa78dae2" title="Alias for Particle with all variables in 64 bit precision.">autopas::Particle</a></code>.</p>
<p >Important parts to implement:</p><ul>
<li><code>enum AttributeNames</code></li>
<li>Definition of a matching <code>SoAArraysType</code></li>
<li>Getter and setter connecting the <code>AttributeNames</code> and actual members.</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
Custom Functors</h2>
<p >Once you have defined your particle you can start with the functor class.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Definition</h3>
<p >Important parts to implement:</p><ul>
<li>Actual force calculations: <code>AoSFunctor()</code> and all Versions of <code>SoAFunctor*()</code></li>
<li>Newton3 characteristics of the force: <code>allowsNewton3()</code> and <code>allowsNonNewton3()</code></li>
<li>Input and output variables of the force calculation via: <code>getComputedAttr()</code> and <code>getNeededAttr()</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
Usage</h3>
<p >Each functor is applied to AutoPas via: </p><div class="fragment"><div class="line">autoPas.iteratePairwise(&amp;myFunctor);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Particle Ownership</h2>
<p >Particles saved in an AutoPas container can be one of two possible states:</p><ul>
<li>owned: Particles that belong to this AutoPas instance. These particles are typically inside the boundary of the AutoPas instance. If a particle is added via <code>addParticle()</code>, it is automatically added as an owned particle. An owned particle can explicitly be removed by deleting the particle using an iterator (<code>autoPas.deleteParticle(iterator)</code>). On an update of the AutoPas container (using <code>updateContainer()</code>) owned particles that moved outside the boundary of its parent AutoPas container are returned.</li>
<li>halo: Particles that do not belong to the current AutoPas instance. These normally are ghost particles arising from either periodic boundary conditions or particles of a neighboring AutoPas object (if you split the entire domain over multiple AutoPas objects, i.e., you use a domain decomposition algorithm). The halo particles are needed for the correct calculation of the pairwise forces. On update of the AutoPas container, halo particles are deleted (see <a href="#simulation-loop">Simulation Loop</a>).</li>
<li>dummy: Particles that are deleted or that act as filler for certain algorithms. These particles do not affect the force calculation.</li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
Iterating Through Particles</h2>
<p >Iterators to iterate over particle are provided. The particle can be accesses using <code>iter-&gt;</code> or <code>*iter</code>. When created inside a OpenMP parallel region, work is automatically spread over all threads. </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> iter = autoPas.begin(); iter.isValid(); ++iter) {</div>
<div class="line">  <span class="comment">// user code:</span></div>
<div class="line">  <span class="keyword">auto</span> position = iter-&gt;getR();</div>
<div class="line">}</div>
</div><!-- fragment --><p> For convenience the <code>end()</code> method is also implemented for the AutoPas class so you might also use range-based for loops: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; particle : autoPas) {</div>
<div class="line">  <span class="comment">// user code:</span></div>
<div class="line">  <span class="keyword">auto</span> position = particle.getR();</div>
<div class="line">}</div>
</div><!-- fragment --><p >To iterate over a subset of particles, the <code>getRegionIterator(lowCorner, highCorner)</code> method can be used: </p><div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> iter = autoPas.getRegionIterator(lowCorner, highCorner); iter != autoPas.end(); ++iter) {</div>
<div class="line">  <span class="comment">// user code:</span></div>
<div class="line">  <span class="keyword">auto</span> position = iter-&gt;getR();</div>
<div class="line">}</div>
</div><!-- fragment --><p >Both <code>begin()</code> and <code>getRegionIterator()</code> can also take the additional parameter <code>IteratorBehavior</code>, which indicates over which particles the iteration should be performed. See <a href="https://autopas.github.io/doxygen_documentation/git-master/namespaceautopas.html#a520fefd51e4555074cd16e7c3fd19c42">autopas::IteratorBehavior</a> for possible options and details. The default parameter is <code>ownedOrHalo</code>, which is also used for range-based for loops.</p>
<p >Analogously to <code>begin()</code>, <code>cbegin()</code> is also defined, which guarantees to return a <code>const_iterator</code>.</p>
<p >Iterators are not guaranteed to be valid after particle insertion. However, particle deletion while iterating is supported via <code>autoPas.deleteParticle(iterator)</code>.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Simulation Loop</h2>
<p >One simulation loop should always consist of the following phases:</p>
<ol type="1">
<li>Updating the Container: <div class="fragment"><div class="line"><span class="keyword">auto</span> invalidParticles = autoPas.updateContainer();</div>
</div><!-- fragment --> This call will trigger an update of the container inside AutoPas. The returned vector <code>invalidParticles</code> consists of the particles that were previously owned by this AutoPas container but have left the boundary of this container, i.e., their current position resides outside the container.</li>
<li>Handling the leaving particles<ul>
<li>Apply boundary conditions on them</li>
<li>Potentially send them to other mpi-processes, skip this if MPI is not needed</li>
<li>Add them to the containers using <div class="fragment"><div class="line">autoPas.addParticle(particle)</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Handle halo particles:<ul>
<li>Identify the halo particles by use of AutoPas' iterators and send them in a similar way as the leaving particles.</li>
<li>Add the particles as haloParticles using <div class="fragment"><div class="line">autoPas.addHaloParticle(haloParticle)</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Perform an iteratePairwise step. <div class="fragment"><div class="line">autoPas.iteratePairwise(functor);</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md17"></a>
Inserting additional particles</h2>
<p >Additional particles (e.g. through a grand-canonical thermostat), can be inserted at any point in the simulation loop. For periodic boundary conditions, or in an MPI-parallel simulation, you, as the user, is responsible for inserting the appropriate halo particles.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Internal Verlet-like container behavior</h2>
<p >The behavior described in this section is normally opaque to users of AutoPas. The only exception to this rule is that particles should not be moved more than skin/2 within the specified Verlet rebuild frequency. This restriction is due to the internally used Verlet-like container behavior in which the actual container is not updated in every time step and particles are not necessarily sorted into the correct cells. This allows the reuse of neighbor lists throughout multiple time steps and is necessary for a performant implementation of our Verlet containers.</p>
<p >We do, however, still provide a linked cells-like interface to a user of AutoPas, i.e., a container appears to be updated every time step, leaving particles are returned at every time step and particles can be deleted and added independently to the internal state of the container. Internally we make this possible, by using partial container updates, which collect leaving particles while marking left particles and halo particles as dummy. Additionally, we maintain a particle buffer that allows to add particles to AutoPas without modifying the underlying container. This particle buffer is considered in the force calculation and when iterating through particles.</p>
<p >Another performance optimization is made possible by allowing to reuse the neighbor list entries of halo particles of previous time steps. While the actual particles have already been implicitly deleted (marked as dummy), they still exist. For their reuse, we try to add halo particles in their original memory location. If that is, however, not possible, we add them to another particle buffer (the haloParticleBuffer).</p>
<p >Additional information can be found in <a href="https://github.com/AutoPas/AutoPas/pull/642">PR 642</a></p>
<h2><a class="anchor" id="autotoc_md19"></a>
Using multiple functors</h2>
<p >AutoPas is able to work with simulation setups using multiple functors that describe different forces. A good demonstration for that is the sph example found under examples/sph or examples/sph-mpi. There exist some things you have to be careful about when using multiple functors:</p><ul>
<li>If you use multiple functors it is necessary that all functors support the same newton3 options. If there is one functor not supporting newton3, you have to disable newton3 support for AutoPas by calling <div class="fragment"><div class="line">autoPas.setAllowedNewton3Options({<span class="keyword">false</span>});</div>
</div><!-- fragment --></li>
<li>If you have <code>n</code> functors within one iteration and update the particle position only at the end or start of the iteration, the rebuildFrequency and the samplingRate have to be a multiple of <code>n</code>.</li>
<li>Functors must be marked as (not) relevant for tuning by specifying <code>Functor::isRelevantForTuning()</code>. Functors marked as relevant should have a near-identical performance profile otherwise the sampling of configurations will be distorted. It is recommended, to only mark the most expensive functor as relevant.</li>
</ul>
<h1><a class="anchor" id="autotoc_md20"></a>
Developing AutoPas</h1>
<p >Please look at our <a href="https://github.com/AutoPas/AutoPas/blob/master/.github/CONTRIBUTING.md">contribution guidelines</a>.</p>
<p >For profiling the compile-time, the cmake option <code>AUTOPAS_COMPILE_TIME_PROFILING</code> can be turned on. This enables gcc's -<code>ftime-report</code> and clang's <code>-ftime-trace</code>. It is recommended to use clang, as its output is more detailed. <code>-ftime-trace</code> generates a .json file for each compilation unit next to the generated object file (inside one of the CMakeFiles directories). Chrome has a built-in tool for viewing these files in a flame graph. It can be accessed through the URL <code>chrome://tracing</code>.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Acknowledgements</h1>
<p >This work was financially supported by:</p><ul>
<li>the Federal Ministry of Education and Research, Germany, project “Task-based load balancing and auto-tuning in particle simulations” (TaLPas) 8 , grant numbers 01IH16008A and 01IH16008B.</li>
</ul>
<h1><a class="anchor" id="autotoc_md22"></a>
Papers to cite</h1>
<ul>
<li>F. A. Gratl, S. Seckler, N. Tchipev, H.-J. Bungartz and P. Neumann: <a href="https://ieeexplore.ieee.org/document/8778280">AutoPas: Auto-Tuning for Particle Simulations</a>, In 2019 IEEE International Parallel and Distributed Processing Symposium Workshops (IPDPSW), Rio de Janeiro, May 2019. (<a href="https://mediatum.ub.tum.de/export/1535848/bibtex">BibTeX</a>, <a href="https://mediatum.ub.tum.de/1535848">MediaTUM</a>)</li>
<li>S. Seckler, F. Gratl, M. Heinen, J. Vrabec, H.-J. Bungartz, P. Neumann: <a href="https://www.sciencedirect.com/science/article/abs/pii/S1877750320305901">AutoPas in ls1 mardyn: Massively parallel particle simulations with node-level auto-tuning</a>, In Journal of Computational Science, Volume 50, 2021. (<a href="https://mediatum.ub.tum.de/export/1595680/bibtex">BibTeX</a>, <a href="https://mediatum.ub.tum.de/1595680">MediaTUM</a>) </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
